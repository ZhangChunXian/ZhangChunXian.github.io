<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSAPP 2.3 整数的运算</title>
    <url>/posts/CSAPP_2_3_%E6%95%B4%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97_url.html</url>
    <content><![CDATA[<h1 id="2-3-整数的运算"><a href="#2-3-整数的运算" class="headerlink" title="2.3 整数的运算"></a>2.3 整数的运算</h1><span id="more"></span>

<h2 id="2-3-1-无符号整数的加法"><a href="#2-3-1-无符号整数的加法" class="headerlink" title="2.3.1 无符号整数的加法"></a>2.3.1 无符号整数的加法</h2><p>假设有两个w位的无符号整数x与y，当我们计算它们的和时，会发现如下两种情况。</p>
<ol>
<li><p>0 &lt;= x+y &lt;= 2^w^-1</p>
<p>这时我们可以直接用一个唯一的w位二进制数来表示<code>x+y</code>的值。</p>
</li>
<li><p>x+y &gt; 2^w^-1</p>
<p>这种情况称为”溢出“(overflow)。大部分编程语言，包括C语言，仅仅支持固定位数的运算，也就是说两个w位的整数相加，其结果必定是w位的整数，不可能会产生w+1位的整数。<strong>二进制的溢出仅仅会溢出一位。</strong></p>
<p>两个w位的整数相加从算术上看至多会产生w+1位整数。当产生”溢出“时，计算机会抛弃运算结果的最高位，即第w+1位，留下其余w位作为运算结果。</p>
<p>例如 考虑以下4位无符号整数运算</p>
<p>x = [1001] y = [1100]</p>
<p>从算术结果上来看， sum(x, y) = [10101]， 但是计算机不支持在溢出时进位，所以运算结果需要砍掉最高位的1。计算机的实际运算结果 x+y = [0101]。</p>
</li>
</ol>
<p>综上所述，w位无符号整数的加法运算结果实际上就是   实际运算结果 mod 2^w^。</p>
<blockquote>
<p>在执行C语言过程中，”溢出“并不会报错。</p>
<p>这就需要开发者去留心，去警惕可能会发生的溢出现象。</p>
<p>当然也可以用专门的函数去检测”溢出现象“</p>
</blockquote>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be added without overflow*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uadd_ok</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">unsigned</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = x+y;</span><br><span class="line">    <span class="keyword">return</span> sum &gt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当发生溢出时，函数就会返回0， 不发生溢出时返回1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-2-有符号整数（补码）的加法"><a href="#2-3-2-有符号整数（补码）的加法" class="headerlink" title="2.3.2 有符号整数（补码）的加法"></a>2.3.2 有符号整数（补码）的加法</h2><p>对于w位有符号整数的加法，就要更复杂一些了。当两者的和小于-2^w-1^，或者大于2^w-1^-1时，就会发生溢出现象。</p>
<p>但即使更加复杂，有符号整数的加法遵循的原则与无符号整数无异，仍然时去掉溢出的最高位。<strong>不同点是有符号整数的加法的剩余位数必须视作补码</strong>。</p>
<ol>
<li><p>x+y &lt; -2^w-1^</p>
<p>此时会发生”负溢出“（<code>negative overflow</code>）。计算机会自动抛弃运算产生的最高位，留下其余w位作为运算结果</p>
<p>eg1 当w=4, x = [1000], y = [1011], 从算术结果上来看，sum(x, y) = [10011], 抛弃最高位后，计算机的实际运算结果 x+y = [0011] = (3)<del>10</del></p>
</li>
<li><p>-2^w-1^ &lt;= x+y &lt;= 2^w-1^-1</p>
<p>此时计算机不发生溢出现象。计算机得到的实际结果等于算术结果。</p>
<p>eg2 当w=4， x =1000, y = 0101, 算术结果和计算机的实际运行结果都为sum(x+y) = [1101] = (-3)<del>10</del></p>
</li>
<li><p>x+y &gt; 2^w-1^-1</p>
<p>此时会发生”正溢出“（<code>positive overflow</code>）。计算机会自动抛弃运算产生的最高位，留下其余w位作为运算结果</p>
<p>eg1 当w=4, x = [0101], y = [0101], 从算术结果上来看，sum(x, y) = [1010]..计算机的实际运算结果也是 x+y= [1010] = (-6)<del>10</del></p>
</li>
</ol>
<p>那我们如何检查和分辨出正溢出和负溢出呢？规律如下</p>
<ol>
<li>当 x &gt; 0, y &gt; 0, 且计算机的实际运算结果 x+y 小于零时，就说明发生了正溢出现象。</li>
<li>当 x &lt; 0,  y &lt; 0, 且计算机的实际运算结果 x+y 大于零时, 就说明发生了负溢出现象。</li>
</ol>
<p>我们可以用以下代码来检验溢出(int 类型有符号整数）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be added without overflow*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tadd_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = x+y;</span><br><span class="line">    <span class="type">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos_over = x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> !neg_over &amp;&amp; !pos_over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h2><h3 id="求有符号正数的相反数"><a href="#求有符号正数的相反数" class="headerlink" title="求有符号正数的相反数"></a>求有符号正数的相反数</h3><p>第一种方法：</p>
<p>我们知道了一个有符号整数的二进制表示，求出该整数的相反数的二进制表示只需要下列两步</p>
<ol>
<li><p>将二进制的所有位取反。</p>
</li>
<li><p>将1.得到的结果的最后一位再加1.</p>
</li>
</ol>
<p>eg1. (5)<del>10</del> = (0101)<del>2</del>, 将二进制所有位取反后得到(1010)<del>2</del>， 最后一位加1得到 (1011)<del>2</del>, 按照补码的运算， (1011)<del>2</del> = (5)<del>10</del></p>
<p>第二种方法：</p>
<p>找出二进制表示中最右边的1，该1的位置左侧取反，右侧不变。</p>
<p>eg2. (5)<del>10</del> = (010<em><strong>1</strong></em>)<del>2</del>, 最右边的1已经用粗斜体表示，按照规则转化为 (1011)<del>2</del>。按照补码的运算， (1011)<del>2</del> = (5)<del>10</del></p>
<p>对于一个w位整数x，x的非（在算术中称为相反数）的规律如下 TMin指x所能表示的最小值。<br>$$<br>-x = \begin{cases}<br>TMin &amp; \text{ if } x= TMin \<br>-x &amp; \text{ if } x&gt; TMin<br>\end{cases}<br>$$</p>
<p>解释以下唯一的例外，以4位二进制为例， TMin = (1000)<del>2</del>, 所有位取反得到(0111)<del>2</del>, 最后一位加1后得到 (1000)<del>2</del>, 正好是本身。<strong>这是表达式中唯一的例外。</strong></p>
<h2 id="2-3-4-无符号数乘法"><a href="#2-3-4-无符号数乘法" class="headerlink" title="2.3.4 无符号数乘法"></a>2.3.4 无符号数乘法</h2><p>w位无符号整数的范围为 0 ~ 2^w^-1, 两个w位整数相乘，范围为 0 ~(2^w^-1)^2^, 至少需要2w位才能完成表示。但C语言中仍然用w位表示二者乘积，即抛弃前w位，只留下后w的数据, 在公式中结果用$x * _{u}^{w}\textrm{y}$表示。则<br>$$<br>x * _{w}^{u}\textrm{y} = (x \cdot y ) mod  2^{w}<br>$$</p>
<h2 id="2-3-5-有符号数乘法"><a href="#2-3-5-有符号数乘法" class="headerlink" title="2.3.5 有符号数乘法"></a>2.3.5 有符号数乘法</h2><p>与无符号数乘法规则基本相同。</p>
<p>唯一的不同点是，<strong>最后的结果是用补码表示的</strong>。我们用$x * _{t}^{w}\textrm{y}$代表C语言中的乘积值。则<br>$$<br>x * _{w}^{t}\textrm{y} = (x \cdot y ) mod  2^{w}<br>$$</p>
<p><img data-src="/../../images/IMG_1097(20201005-104026).JPG" alt="IMG_1097(20201005-104026)"></p>
<p>下面用一个程序来检验乘法运算时的溢出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be multiplied without overflow */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmult_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x*y;</span><br><span class="line">    <span class="comment">/* Either x is zero, or dividing p by x gives y */</span></span><br><span class="line">    <span class="keyword">return</span> !x || p/x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-6-常数的乘除法"><a href="#2-3-6-常数的乘除法" class="headerlink" title="2.3.6 常数的乘除法"></a>2.3.6 常数的乘除法</h2><p>计算机中乘法的运算速度相对于加减法，位运算，移位运算来说时比较慢的。因此，我们可以考虑用较快的位运算，移位等操作来代替缓慢的乘法。</p>
<h3 id="用移位实现“乘以2的幂“"><a href="#用移位实现“乘以2的幂“" class="headerlink" title="用移位实现“乘以2的幂“"></a>用移位实现“乘以2的幂“</h3><ul>
<li>无论有符号数还是无符号数<ul>
<li> u&lt;&lt; k 可得到 u * 2^k^ </li>
</ul>
</li>
</ul>
<p>如果运算结果溢出，那么遵守和前面乘法一样的规则，去掉溢出的高位，保留原本的位数。</p>
<p>c编译器会通过移位，加法和减法的组合来消除许多整数与常数相乘的情况。</p>
<p>例如 表达式 x*14， 因为 14 = 2^3^ + 2^2^ + 2^1^, 所以编译器将这个乘法运算转变为</p>
<p> (x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)**注意，移位运算与加减法在一个表达式中时一定要加括号！)**，即将一次乘法运算转变为3个移位运算和两个加法运算。 </p>
<h3 id="用移位实现”除以2的幂“"><a href="#用移位实现”除以2的幂“" class="headerlink" title="用移位实现”除以2的幂“"></a>用移位实现”除以2的幂“</h3><p>在机器中除法的运算比乘法更慢。</p>
<ul>
<li><p>整数“除以2的幂”的商</p>
<ul>
<li><p>u &gt;&gt; k 得到  小于等于（u / 2^k^ ）的最大整数</p>
</li>
<li><p> 无符号整数使用逻辑右移，有符号整数使用算术右移。</p>
</li>
<li><p>右移会产生二进制小数，在机器运算最后的结果中被去掉。</p>
</li>
</ul>
</li>
</ul>
<p>具体如图所示（以无符号整数为例子）</p>
<p><img data-src="/../../images/image-20201005185835285.png" alt="image-20201005185835285"></p>
<p>从中我们可以看出，在C语言中整数与整数做除法得到的一定还是个整数，而且得到的整数是小于等于（u / 2 ^k^ ）的最大整数。</p>
<p>此外，还可以通过特殊的运算得到 大于等于（u/2^k^)的最小整数。具体见CSAPP英文版p141.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return x&gt;&gt;4</span><br></pre></td></tr></table></figure>

<h2 id="2-3-8-总结"><a href="#2-3-8-总结" class="headerlink" title="2.3.8 总结"></a>2.3.8 总结</h2><h3 id="算术运算基本规则"><a href="#算术运算基本规则" class="headerlink" title="算术运算基本规则"></a>算术运算基本规则</h3><p>加法：</p>
<ul>
<li>无/有符号数的加法：正常加法后再截断，位级的运算相同</li>
</ul>
<p>乘法：</p>
<ul>
<li>无/有符号数的乘法: 正常乘法后加截断操作,位级运算相同</li>
</ul>
<h3 id="使用无符号整数时的常见错误"><a href="#使用无符号整数时的常见错误" class="headerlink" title="使用无符号整数时的常见错误"></a>使用无符号整数时的常见错误</h3><ul>
<li><p>忽略有符号数隐式转换(casting)到无符号数。</p>
</li>
<li><p>无符号数在运算过程中在数学算术上会产生负数结果，在计算机中转换为正数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* WARNING: This is buggy code */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">sum_elements</span><span class="params">(<span class="type">float</span> a[], <span class="type">unsigned</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;= length<span class="number">-1</span>; i++)		<span class="comment">// bug句需纠正</span></span><br><span class="line">        result += a[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，当<code>length=0</code>时， 第一次判断条件中length-1算术结果为-1，但是无符号整数的运算规则可知，实际产生结果将是一个相当大的正数。</p>
<p>纠正</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; length; i++)</span><br></pre></td></tr></table></figure></li>
<li><p>不知道一些函数方法默认返回无符号整数，采用有符号整数的算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether string s is longer than string t*/</span></span><br><span class="line"><span class="comment">/* a buggy function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strlonger</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;		<span class="comment">// 待修改代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<strong>strlen函数的返回值是无符号整数。</strong>无符号整数的减法得到的仍然是无符号整数！除非s数组与t数组长度相同，否则该函数输出均为1.</p>
<p>纠正</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(s) &gt; <span class="built_in">strlen</span>(t)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.11 记录</title>
    <url>/posts/2020.11%E8%AE%B0%E5%BD%95_url.html</url>
    <content><![CDATA[<h1 id="C-语言-用EOF代替回车作为终止输入的符号"><a href="#C-语言-用EOF代替回车作为终止输入的符号" class="headerlink" title="C 语言: 用EOF代替回车作为终止输入的符号"></a>C 语言: 用EOF代替回车作为终止输入的符号</h1><p>EOF 知识链接:</p>
<p> <a href="https://stackoverflow.com/questions/1782080/what-is-eof-in-the-c-programming-language">What is EOF in the C programming language?</a></p>
<p>用EOF终止输入需要保证EOF在回车后输入, 否则EOF不会被识别到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用EOF终止字符的输入</span></span><br><span class="line"><span class="keyword">if</span> ( (str = getchar()) != EOF ) 	<span class="comment">// 继续输入</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*语句*/</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="comment">/*终止语句*/</span></span><br></pre></td></tr></table></figure>

<p>题目:</p>
<p><a href="http://oj.kfcoding.com/contest/24/problem/6-1">http://oj.kfcoding.com/contest/24/problem/6-1</a></p>
<p><img data-src="/../../images/image-20201105145810345.png"></p>
<p>答案:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCount</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> English_char = <span class="number">0</span>, Space_and_Enter = <span class="number">0</span>,</span><br><span class="line">	num_char = <span class="number">0</span>, other_char = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((s[i] = getchar()) != EOF)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">if</span> ((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">			English_char++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">			num_char++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span> || s[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			Space_and_Enter++;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, English_char, Space_and_Enter, num_char</span><br><span class="line">						, <span class="built_in">strlen</span>(s) - English_char - Space_and_Enter - num_char - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	StringCount(str);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C语言-消除输出的最后一位空格"><a href="#C语言-消除输出的最后一位空格" class="headerlink" title="C语言: 消除输出的最后一位空格"></a>C语言: 消除输出的最后一位空格</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>上面这里是输出ASCII码为8的字符，这是一个Backspace控制符。于是可以往回消去一个字符。</p>
<p>PS: 经过验证, 该方法有效, 但是在学校的oj平台上无用, 且会被判定为未知字符.</p>
<h1 id="Git-amp-Github"><a href="#Git-amp-Github" class="headerlink" title="Git &amp; Github"></a>Git &amp; Github</h1><p><a href="https://stackoverflow.com/questions/67699/how-to-clone-all-remote-branches-in-git">How to clone all remote branches in Git?</a></p>
<h1 id="VSCODE-输出中文乱码解决方法"><a href="#VSCODE-输出中文乱码解决方法" class="headerlink" title="VSCODE: 输出中文乱码解决方法"></a>VSCODE: 输出中文乱码解决方法</h1><p><a href="https://www.w3xue.com/exp/article/20203/80007.html">https://www.w3xue.com/exp/article/20203/80007.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30127242">https://zhuanlan.zhihu.com/p/30127242</a>)</p>
<h1 id="C语言-strrev-function"><a href="#C语言-strrev-function" class="headerlink" title="C语言: strrev() function"></a>C语言: strrev() function</h1><h4 id="strrev-function"><a href="#strrev-function" class="headerlink" title="strrev() function"></a>strrev() function</h4><p>It is used to reverse the given string expression.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    char s1[50]; </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Enter your string: &quot;); </span><br><span class="line">    gets(s1);  </span><br><span class="line">    printf(&quot;\nYour reverse string is: %s&quot;,strrev(s1)); </span><br><span class="line">    return(0); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// output</span></span><br><span class="line">Enter your <span class="built_in">string</span>: studytonight </span><br><span class="line">Your reverse <span class="built_in">string</span> is: thginotyduts</span><br></pre></td></tr></table></figure>

<h1 id="C语言-scanf输出输出一行包括空格的字符串"><a href="#C语言-scanf输出输出一行包括空格的字符串" class="headerlink" title="C语言: scanf输出输出一行包括空格的字符串"></a>C语言: scanf输出输出一行包括空格的字符串</h1><h3 id="String-Input-and-Output"><a href="#String-Input-and-Output" class="headerlink" title="String Input and Output"></a>String Input and Output</h3><p>Input function <code>scanf()</code> can be used with <strong>%s</strong> format specifier to read a string input from the terminal. But there is one problem with <code>scanf()</code> function, it terminates its input on the first white space it encounters. Therefore if you try to read an input string “Hello World” using <code>scanf()</code> function, it will only read <strong>Hello</strong> and terminate after encountering white spaces.</p>
<p>However, C supports a format specification known as the <strong>edit set conversion code %[..]</strong> that can be used to read a line containing a variety of characters, including white spaces.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, &amp;str);  <span class="comment">//scanning the whole string, including the white spaces</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C语言-动态分配数组-一维"><a href="#C语言-动态分配数组-一维" class="headerlink" title="C语言: 动态分配数组(一维)"></a>C语言: 动态分配数组(一维)</h1><h2 id="数组元素个数为变量"><a href="#数组元素个数为变量" class="headerlink" title="数组元素个数为变量"></a>数组元素个数为变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="literal">NULL</span>;								<span class="comment">// 声明数组头指针	</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>;									<span class="comment">// 声明变量并初始化</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);							<span class="comment">// 变量赋值</span></span><br><span class="line">a = (<span class="type">int</span> *) <span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));			<span class="comment">// 动态分配内存</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 之后a的用法与a[N]无异</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">free</span>(a);									<span class="comment">//!!!i使用结束后必须释放内存空间</span></span><br></pre></td></tr></table></figure>

<h1 id="C语言-动态分配数组-二维"><a href="#C语言-动态分配数组-二维" class="headerlink" title="C语言: 动态分配数组(二维)"></a>C语言: 动态分配数组(二维)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nrows, ncolumns;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, nrows, ncolumns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为数组分配行数 注意分配的是整形指针的数量 每行元素是个整形指针</span></span><br><span class="line">    <span class="type">int</span> **<span class="built_in">array</span> = <span class="built_in">malloc</span>(nrows * <span class="keyword">sizeof</span>(*<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每行分配数组的个数(二维数组列数)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nrows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 为每行申请内存空间</span></span><br><span class="line">        <span class="built_in">array</span>[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(ncolumns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*接下来等于对 a[nrows][ncolumns] 进行操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(<span class="built_in">array</span>);     <span class="comment">// 一定要在最后讲内存空间释放!!</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="C语言-Problem-with-scanf-when-there-is-fgets-gets-scanf-after-it"><a href="#C语言-Problem-with-scanf-when-there-is-fgets-gets-scanf-after-it" class="headerlink" title="C语言: Problem with scanf() when there is fgets()/gets()/scanf() after it"></a>C语言: Problem with scanf() when there is fgets()/gets()/scanf() after it</h1><p><a href="https://www.geeksforgeeks.org/problem-with-scanf-when-there-is-fgetsgetsscanf-after-it/">article_links</a></p>
<h1 id="C语言-fgets函数的一些注意事项"><a href="#C语言-fgets函数的一些注意事项" class="headerlink" title="C语言: fgets函数的一些注意事项"></a>C语言: fgets函数的一些注意事项</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><code>fets</code>函数中的第二个参数为字符串的允许输入个数, 实际上这个个数是要算上字符串的结尾‘\0’, 除去‘\0’, 有效输入字符为 <code>n-1</code>个.</p>
</li>
<li><p>当fgets函数以换行符号作为最后的终止符, 如果当前输入的字符个数小于<code>n-1</code>, 那么换行符<code>\n</code>也会作为输入字符记载到字符串中.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>日常记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_10_record</title>
    <url>/posts/2020_10_record_url.html</url>
    <content><![CDATA[<h2 id="显示隐藏文件夹"><a href="#显示隐藏文件夹" class="headerlink" title="显示隐藏文件夹"></a>显示隐藏文件夹</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<p>如.git</p>
<h2 id="Vim-粘贴会因为编辑器内置的‘智障’缩进从而形成乱码"><a href="#Vim-粘贴会因为编辑器内置的‘智障’缩进从而形成乱码" class="headerlink" title="Vim 粘贴会因为编辑器内置的‘智障’缩进从而形成乱码"></a>Vim 粘贴会因为编辑器内置的‘智障’缩进从而形成乱码</h2><h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><h2 id="vs设置语言"><a href="#vs设置语言" class="headerlink" title="vs设置语言"></a>vs设置语言</h2><p>在Visual Studio中，点击**”工具”–&gt;”选项”–&gt;”环境”–&gt;”区域设置”–&gt;”语言”**[<a href="https://zhuanlan.zhihu.com/p/120183174#ref_1">1]</a></p>
<h2 id="visual-studio-调试"><a href="#visual-studio-调试" class="headerlink" title="visual studio 调试"></a>visual studio 调试</h2><p>按F9设置断点, F5从断点处开始执行语句, F10从断点处一步一步执行代码.</p>
<span id="more"></span>

<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><ol>
<li><p>C语言中清屏操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     			<span class="comment">// 必须头文件</span></span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>)					   <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure></li>
<li><p>程序执行暂停操作</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10</span>)							<span class="comment">// sleep函数中填暂停时间, 单位: ms</span></span><br></pre></td></tr></table></figure></li>
<li><p>不需要回车就可以得到输入字符(scanf需要输入回车)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span>					<span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line">input = getch()						<span class="comment">// 用input变量来接受输入的字符</span></span><br></pre></td></tr></table></figure>
<p>注: visual studio需要输入 _kbhit</p>
</li>
<li><p>kbhit函数, 在用户右键盘输入时返回1, 否则返回0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span>					<span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(kbhit())							<span class="comment">// 判断是否右键盘输入</span></span><br></pre></td></tr></table></figure>
<p>注: visual studio需要输入 _kbhit</p>
</li>
</ol>
<p>C语言实现四舍五入到int类型语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = (int)(a + 0.5);</span><br></pre></td></tr></table></figure>



<p>C语言中用乘法的话, 优先使用库函数, 因为自己磨的轮子没有C语言库的好</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>日常记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2020插班生考试个人总结及经验分享</title>
    <url>/posts/2020%E6%8F%92%E7%8F%AD%E7%94%9F%E8%80%83%E8%AF%95%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E5%8F%8A%E7%BB%8F%E9%AA%8C%E5%88%86_url.html</url>
    <content><![CDATA[<h1 id="2020插班生考试个人总结及经验分享"><a href="#2020插班生考试个人总结及经验分享" class="headerlink" title="2020插班生考试个人总结及经验分享"></a>2020插班生考试个人总结及经验分享</h1><ul>
<li>背景：本人来自于上海大学社区学院理工大类，有幸通过了2020年上海插班生考试，现就读于华东师范大学大数据科学与技术专业。很高兴在此与大家分享我的备考经历，希望能给立志立志考插的学弟学妹一些微薄的帮助，同时欢迎大佬们指出我的不足，给予一些宝贵的意见。欢迎各位在评论区畅所欲言，同时也可以通过邮箱联系我。<br>让我们一起加油(๑•̀ㅂ•́)و✧<span id="more"></span>
<img data-src="/images/email.jpg"></li>
</ul>
<h2 id="不了上海插班生考试的小伙伴可以点开下面的链接初步了解下这制度"><a href="#不了上海插班生考试的小伙伴可以点开下面的链接初步了解下这制度" class="headerlink" title="不了上海插班生考试的小伙伴可以点开下面的链接初步了解下这制度"></a><strong>不了上海插班生考试的小伙伴可以点开下面的链接初步了解下这制度</strong></h2><p><a href="https://baike.baidu.com/item/%E6%8F%92%E7%8F%AD%E7%94%9F%E8%80%83%E8%AF%95/8992579">上海插班生考试简要介绍</a><br><img data-src="/images/chabansheng.JPG"></p>
<h2 id="我倾向于将我的备考历程分为四个阶段，这四个阶段既是按照时间的前后顺序，又是按照重要性递减的顺序。这些阶段分别是"><a href="#我倾向于将我的备考历程分为四个阶段，这四个阶段既是按照时间的前后顺序，又是按照重要性递减的顺序。这些阶段分别是" class="headerlink" title="我倾向于将我的备考历程分为四个阶段，这四个阶段既是按照时间的前后顺序，又是按照重要性递减的顺序。这些阶段分别是"></a>我倾向于将我的备考历程分为四个阶段，这四个阶段既是按照时间的前后顺序，又是按照重要性递减的顺序。这些阶段分别是</h2><ul>
<li><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a><strong>选择</strong></h3><ul>
<li><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><ul>
<li><h3 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a><strong>坚持</strong></h3><ul>
<li><h3 id="时间管理（罗志祥警告doge）"><a href="#时间管理（罗志祥警告doge）" class="headerlink" title="时间管理（罗志祥警告doge）"></a><strong>时间管理</strong>（罗志祥警告doge）</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>请点击相应的链接进行阅读。</strong></p>
<h2 id="为方便阅读，请注意每个文章开头包含文章结构和主旨的思维导图"><a href="#为方便阅读，请注意每个文章开头包含文章结构和主旨的思维导图" class="headerlink" title="为方便阅读，请注意每个文章开头包含文章结构和主旨的思维导图"></a><em>为方便阅读，请注意每个文章开头包含文章结构和主旨的思维导图</em></h2><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>这里贴一下和我报考同校同专业，排名还比我高的大佬的经验帖链接</p>
<h2 id="2020年华师大数据专业插班生第一名经验帖"><a href="#2020年华师大数据专业插班生第一名经验帖" class="headerlink" title="2020年华师大数据专业插班生第一名经验帖"></a><a href="https://www.zhihu.com/question/405691649/answer/1355898741">2020年华师大数据专业插班生第一名经验帖</a></h2><h2 id="2020年华师大数据专业插班生第三名经验帖"><a href="#2020年华师大数据专业插班生第三名经验帖" class="headerlink" title="2020年华师大数据专业插班生第三名经验帖"></a><a href="https://www.zhihu.com/question/405691649/answer/1354262898">2020年华师大数据专业插班生第三名经验帖</a></h2><ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>插班生考试</category>
      </categories>
      <tags>
        <tag>插班生考试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 2.1 信息的存储</title>
    <url>/posts/CSAPP_2_1_%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8_url.html</url>
    <content><![CDATA[<p>前言：这篇博文是我学习<em>Computer Systems: A Programmer’s Perspective</em>这本书整理的笔记，同时参考了B站@刘迪望和@九曲阑干等up主的翻译和原创视频，力求尽我所能将这本神书的笔记写到最好。</p>
<h2 id="2-1-信息的存储"><a href="#2-1-信息的存储" class="headerlink" title="2-1 信息的存储"></a>2-1 信息的存储</h2><span id="more"></span>

<h2 id="1-信息存储"><a href="#1-信息存储" class="headerlink" title="1. 信息存储"></a>1. 信息存储</h2><p>通常情况下，程序将内存视为一个非常大的数组，数组的元素由一个个字节(<code>Byte</code>)表示，每个字节都有一个唯一的数字来表示，我们称之为地址（address）。这些所有地址的集合就称为虚拟地址空间（Virtual Address Space）。</p>
<h3 id="字节（Byte）"><a href="#字节（Byte）" class="headerlink" title="字节（Byte）"></a>字节（Byte）</h3><p>一个字节是由8个位（bit）组成，在二进制表示法中，每一个值可能由两种状态，0或者1。当这8个位全为零时，表示一个字节的最小值。当这8个位全为1时，表示最大值(大多数情况下)。如果用十进制来表示，那么一个字节的取值范围就在0~255（包含0和255）之间。我们把这种按照一位一位表示数据的方式称为位模式。</p>
<p>我们引入16进制来表示位模式，对于十六进制，是由0-9和A-F来表示16个可能的值。在C语言中，十六进制是以0x开头的，这个X可大写可小写，字母部分同样部分大小写。</p>
<h3 id="字长（word-size）"><a href="#字长（word-size）" class="headerlink" title="字长（word size）"></a>字长（word size）</h3><p>任何一个机器都有一个“字长”，字长是地址的名义长度。</p>
<p>地址指向计算机中指定字节的位置，相邻字的地址相差4（32位机器）或 8（64位机器）。</p>
<p><img data-src="/../../images/image-20201005195903725.png" alt="image-20201005195903725"></p>
<p>字长决定了虚拟地址空间的上限。对于一个字长位w位的机器，虚拟地址的范围时0~2的w次放减1。近些年，高性能服务器，个人电脑以及智能手机已经完成了从32位字长到64位字长的迁移。对于32位（32字长）的机器，虚拟地址空间最大位4GB，而64位的机器，虚拟地址空间最大位2^32^*4GB（16EB）。在迁移过程中，64位的机器做了向后兼容，因此位32位机器编译的程序也可以运行在64位机器上。通过特定命令可以在64位机器上编译生成32位机器上运行的程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 32bit program</span></span></span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -m32 -o hello32 hello.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 64bit program</span></span></span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -m64 -o hello64 hello.c</span></span><br></pre></td></tr></table></figure>

<p>hello32可以在32位和64位机器上均可运行，但hello64只能运行在64位的机器上。</p>
<p>对于32位和64位程序，主要的区别还是在于程序是如何编译的，而不是运行机器的类型。</p>
<p>C语言中，支持整数和浮点数多种数据格式。</p>
<table>
<thead>
<tr>
<th>C declaration</th>
<th></th>
<th>Bytes</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>signed</td>
<td>unsigned</td>
<td>32-bit</td>
<td>64-bit</td>
</tr>
<tr>
<td>[signed]char</td>
<td>unsigned char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>unsigned short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>unsigned int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>unsigned long</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>int32_t</td>
<td>uint32_t</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>int64_t</td>
<td>uint64_t</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>char *</td>
<td></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td></td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p><strong>以上表格内容需牢记</strong></p>
<p>对于我们需要存储的数据，我们需要搞清楚该数据的地址是什么，以及数据在内存中如何排布的。</p>
<p>通过在不同的系统上运行字节打印程序，可以打印输出程序对象的字节表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>, start[i]);</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">// byte_pointer 强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节的序列，而不是这个对象原始的数据类型。</span></span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(x));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Result</strong></p>
<table>
<thead>
<tr>
<th align="center">Machine</th>
<th>Value</th>
<th>Type</th>
<th>Byte(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Linux 32</td>
<td>12,345</td>
<td>int</td>
<td>39 30 00 00</td>
</tr>
<tr>
<td align="center">Windows</td>
<td>12,345</td>
<td>int</td>
<td>39 30 00 00</td>
</tr>
<tr>
<td align="center">Sun</td>
<td>12,345</td>
<td>int</td>
<td>00 00 30 39</td>
</tr>
<tr>
<td align="center">Linux 64</td>
<td>12,345</td>
<td>int</td>
<td>39 30 00 00</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Machine</th>
<th>Value</th>
<th>Type</th>
<th>Byte(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Linux 32</td>
<td>12,345.0</td>
<td>float</td>
<td>00 e4 40 46</td>
</tr>
<tr>
<td align="center">Windows</td>
<td>12,345.0</td>
<td>float</td>
<td>00 e4 40 46</td>
</tr>
<tr>
<td align="center">Sun</td>
<td>12,345.0</td>
<td>float</td>
<td>46 40 e4 00</td>
</tr>
<tr>
<td align="center">Linux 64</td>
<td>12,345.0</td>
<td>float</td>
<td>00 e4 40 46</td>
</tr>
<tr>
<td align="center">虽然整型和浮点数都是对数值12345进行编码，但是他们却有着完全不同的字节模式</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Machine</th>
<th>Value</th>
<th>Type</th>
<th align="center">Byte(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Linux 32</td>
<td>&amp; ival</td>
<td>int*</td>
<td align="center">e4 f9 ff bf</td>
</tr>
<tr>
<td align="center">Windows</td>
<td>&amp; ival</td>
<td>int*</td>
<td align="center">b4 cc 22 00</td>
</tr>
<tr>
<td align="center">Sun</td>
<td>&amp; ival</td>
<td>int*</td>
<td align="center">ef ff fa 0c</td>
</tr>
<tr>
<td align="center">Linux 64</td>
<td>% ival</td>
<td>int*</td>
<td align="center">b8 11 e5 ff ff 7f 00 00</td>
</tr>
</tbody></table>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h2 id="2-1-4-字符串的表示"><a href="#2-1-4-字符串的表示" class="headerlink" title="2.1.4 字符串的表示"></a>2.1.4 字符串的表示</h2><p>C中的字符串是由null结尾的一组字符。每个字符都按照某种标准的编码方式表示，最常见的编码标准是ASCII码。</p>
<p>如对照ASCII表，字符串“123456”由16进制 <strong>31 32 33 34 35 00</strong>表示。（在十六进制中用 <strong>0x00</strong> 表示  <code>NULL</code>）。只要是采用了ASCII码的编码标准的计算机系统，字符串的表示方式都是一样的，在这一点上字符数据比二进制数据更加具有独立性。</p>
<p>在C语言中<code>strlen</code>函数计算字符串的长度时忽略最后结尾的NULL，返回<code>size_t</code> (the unsigned integer type)类型的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>]=<span class="string">&quot;Program&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">20</span>]=&#123;<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using the %zu format specifier to print size_t</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of string a = %zu \n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of string b = %zu \n&quot;</span>,<span class="built_in">strlen</span>(b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Output</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Length of <span class="built_in">string</span> a = <span class="number">7</span></span><br><span class="line">Length of <span class="built_in">string</span> b = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>由于每种数据类型的编码规则都是不同的，所以二进制代码在不同的硬件或者操作系统上一般都是互不兼容的。ASCII码的广泛应用，使不同公司制作的计算机，能相互交换数据。但它有个限制：它是为英语设计的。</p>
<p>幸运的是，一个字节有八位，可以表示256个不同的值。ASCII码仅仅规定了前128个二进制数的字符表示，因此第128位到255位字符就被空缺出来，给各个国家自己规定标准的编码方式。这些保留下来给每个国家自己安排 准，在一个国家的电脑上打开另一个国家的语言的文档，不可避免的会出现乱码问题。</p>
<p>随着计算机在亚洲兴起，这种做法彻底失效了。比如汉语这样的语言有成千上万的字符，根本没有办法用8位来表示所有的字符。</p>
<p>所以Unicode诞生了，统一了所有编码的标准。最常见的Unicode是16位的，有超过一百万个位置，对每个语言的每个字符都够了，甚至还有多余的位置存放数学符号以及Emoji。</p>
<p>就像ASCII用二进制来表示字母一样，其他格式，比如MP3或者GIF，用二进制编码声音/颜色，表示照片，电影和音乐。</p>
<h2 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h2><p>C语言中的逻辑运算符有<code>||</code>, <code>&amp;&amp;</code> 和 <code>!</code>,对应于逻辑操作中的 <code>OR</code>, <code>AND</code>, <code>NOT</code>。<strong>注意不要将逻辑运算符与位运算符<code>|</code>, <code>&amp;</code>, <code> ^</code> 弄混，它们的操作是截然不同的。</strong></p>
<p>C语言的逻辑运算符一个重要的特点是，如果在前一个参数就能判断结果表达的真假，那么后面的参数将不做考虑，无论它们有效与否。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &amp;&amp; <span class="number">5</span>/b</span><br></pre></td></tr></table></figure>

<p>若参数a为假，则整个表达式的真值可以确认为假，那么参数 5/b的真值将不做考虑，即使b的值为零，即5/b本身为无效表达式，都不会导致编译器报错。</p>
<h2 id="2-1-9-C语言中的移位操作"><a href="#2-1-9-C语言中的移位操作" class="headerlink" title="2.1.9 C语言中的移位操作"></a>2.1.9 C语言中的移位操作</h2><p>C语言的逻辑位移分为左移和右移。其中右移操作分为两种，算术右移和逻辑右移。</p>
<p>算数右移以0来填充左边的由右移而来的k个空位。</p>
<p>逻辑右移以最高位(The most significant bit, 即二进制中权重最大的那个位)来填充由右移而来的k个空位。即若最高位为0，则以0来填充由右移而来的k个空位。同理，若最高位为1，则以1来填充右移而来的k个空位。</p>
<p>具体如下表格所示</p>
<table>
<thead>
<tr>
<th align="center">Operation</th>
<th align="center">Value 1</th>
<th align="center">Value 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Argument x</td>
<td align="center">[01100011]</td>
<td align="center">[10010101]</td>
</tr>
<tr>
<td align="center">x &gt;&gt; 4 (logical)</td>
<td align="center">[00000110]</td>
<td align="center">[00001001]</td>
</tr>
<tr>
<td align="center">x &gt;&gt; 4 (arithmetic)</td>
<td align="center">[<strong>0000</strong>0110]</td>
<td align="center">[<strong>1111</strong>1001]</td>
</tr>
</tbody></table>
<p>几乎所有的编译器和机器都<strong>以算术右移作为有符号数右移的方式</strong>。另一方面，对于无符号整数，<strong>执行的右移操作一定为逻辑右移</strong>。</p>
<p>1、什么样的数据类型可以直接移位</p>
<p>char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long都可以进行移位操作，而double、float、bool、long double则不可以进行移位操作。</p>
<p><strong>注意事项</strong></p>
<ol>
<li><p>在C中移位的数量最好不要超过数据本身的位数，如果超过了数据本身的位数，那么将会对移位数量进行取模操作，以数据本身的位数为除数取模。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lval = <span class="number">0xFEDCBA98</span> &lt;&lt; <span class="number">32</span>;	<span class="comment">// int 类型变量有32位。</span></span><br><span class="line"><span class="type">int</span> aval = <span class="number">0xFEDCBA98</span> &gt;&gt; <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">lval <span class="number">0xFEDCBA98</span> <span class="comment">// 逻辑左移0位</span></span><br><span class="line">aval <span class="number">0xFFEDCB49</span> <span class="comment">// 逻辑右移4位</span></span><br></pre></td></tr></table></figure></li>
<li><p>位移运算符的优先级小于算术运算符，如 <code>1&lt;&lt;2 + 3&lt;&lt;4</code>表达式中实际运算顺序为 <code>1 &lt;&lt; (2+3) &lt;&lt; 4</code>。其实不用记住这么多优先级，<strong>当不清楚运算优先级时，加括号就对了！</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3.3 x86寄存器中内存的组织</title>
    <url>/posts/CSAPP_3.3_x86%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87_url.html</url>
    <content><![CDATA[<p><img data-src="/../../images/image-20201014161839928.png"></p>
<p>在正式介绍汇编语言之前，首先介绍一下x86处理器中寄存器的组织形式。在x86系统中，对于所有的程序员都可见的寄存器一共是有16个。这16个我们也把它叫做通用寄存器。<br>包括rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, 以及r8到r15一共16个寄存器。这些以r作为打头的寄存器都是64位寄存器, 也就是说，每个寄存器可以存储8个字节的数据。</p>
<span id="more"></span>

<p><img data-src="/../../images/16jicunqi.png" alt="16个通用寄存器"></p>
<p>汇编语言再去操作这些寄存器的时候，是以这些寄存器的名称作为操作数进行操作的。<br>对这些寄存器的低32位。在汇编语言中可以使用特殊的名称进行直接访问。</p>
<p>所有的低32位的寄存器的名称, 对于a b c d, s i, d i, s p, b p 都是以e 作为前缀进行访问的, 对于r8到r15的低32位则是增加了一个d 的后缀去访问. 那么这些寄存器是可以单独去访问它的低32位用这样的一个别名。</p>
<h1 id="x86-32位处理器寄存器形式"><a href="#x86-32位处理器寄存器形式" class="headerlink" title="x86-32位处理器寄存器形式"></a>x86-32位处理器寄存器形式</h1><p>要想真正的去了解64位系统中的寄存器组织，就不能够不了解在x86-32位处理器中的寄存器的组织。</p>
<p><img data-src="/../../images/image-20201014162545556.png"></p>
<p>在x86312位系统中, 通用寄存器也就是对于所有程序员都可见的寄存器一共是有8个。它们的名称和64位系统中的寄存器相比, 去掉了r8到r15这8个寄存器, 仍然保留了a b c d, s i, d i, s p, b p 。每个寄存器的位长是32位。在32位系统中，这8个寄存器的低16位也包含着它的别名, 它的别名就是去掉了前缀e。那么就可以作为, 这32位寄存器中的低16位，而使用汇编语言单独进行访问, 尤其特殊的是对于a b c d 4个寄存器来讲, 它们的低8位和高8位也是有别名的。通过这些别名, 也可以实现对特定寄存器中的位进行访问。</p>
<p>x86-64位指令集是可以对x86-32位指令集进行兼容的。<br>因此, 对于x86-64位系统的处理器中的寄存器进行访问也可以通过上述32位系统中，这些寄存器的别名去访问到寄存器的第16位。对于a b c d 4个寄存器, 它的低八位,和从第八位到第15位，也是可以采用这样的别名来去访问。</p>
<p><strong>在x86-64位系统和x86-32位系统中, 所有的s p 寄存器, 都有一个特殊的用途, 用来存放帧顶指针。</strong></p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3.4 数据访问</title>
    <url>/posts/CSAPP_3_4%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4_url.html</url>
    <content><![CDATA[<h1 id="3-4-1-数据访问指令"><a href="#3-4-1-数据访问指令" class="headerlink" title="3.4.1 数据访问指令"></a>3.4.1 数据访问指令</h1><p><img data-src="/../../images/image-20201015082522584-1602737646018.png"></p>
<p>数据访问指令, 它的助记符是move。通过这个名称，可以看出来，它实际上进行的是在源操作数以及目标操作数之间移动数据。虽然它的助记符是move, 但是更确切的去描述的话，可以理解为, 它是将源操作数中的数据复制到目标的位置，也就是源操作数中的数据是不会发生改变的。</p>
<span id="more"></span>

<h2 id="操作数的形式"><a href="#操作数的形式" class="headerlink" title="操作数的形式"></a>操作数的形式</h2><p><img data-src="/../../images/image-20201015082751288-1602737692203.png"></p>
<p>对于操作数, 有三种形式。</p>
<p>第一种形式叫做立即数。立即数通常是一个常数的整数类型, 比如0x400, 是一个十六进制数, 或者是-533。对于-533, 进行一个数据移动实际存到目标位置的数据是-533所对应的补码值, 对应的补码值的位长是由操作数中所携带的数据格式信息所确定的。在这个例子中, 操作码是moveq , q 所表示的信息是八字节，也就是64位。所以如果用moveq 去对这个立即数输出操作, 目标操作数所在的位置应该是-533的一个64bit的补码形式, 最后存储到目标操作数的位置.</p>
<p>立即数与c 语言的常数是类似的，但是在立即数中, 它需要增加一个前缀$(dollar) 符号去描述，这是一个常数。对于立即数操作，可以有1字节、2字节、4字节, 8字节四种操作方式, 这主要取决于操作码的最后一位。也就是, 操作码的最后一个字母, 用来去描述这一次操作的数据位长。</p>
<p><img data-src="/../../images/image-20201015083236038.png"></p>
<p>第二种类型叫做寄存器类型。寄存器也可以作为move指令的操作数存在。16个通用寄存器中的任意一个都可以作为操作数。除了64位的16个通用寄存器之外，在这些寄存器中的低32位或者低16位、低八位或者是第八位到第15位，也可以通过move指令去操作, move指令操作的数据位长是由它所决定。</p>
<p><img data-src="/../../images/image-20201015083802875-1602737794950.png"></p>
<p>在64位的指令中, r a x, r13前面都有百分号, 这些都是一个合法的操作书. 所有的通用寄存器都可以采用这种方式去做操作。但要注意的是r s p 寄存器, 一般在编写汇编语言程序的时候, 不能把它当做一个普通的寄存器去使用。因为r s p 寄存器有特殊的用途，r s p 寄存器在汇编语言中用于存放程序运行时栈的栈顶数据的地址的。其它的寄存器在某些应用场景下也有一些特殊的用途。</p>
<p><img data-src="/../../images/image-20201015084014208-1602737814639.png"></p>
<p>move指令的第三类操作数是内存。move指令可以通过访问内存的某个地址的方式，从内存中加载数据，或者是把数据存放到内存中。</p>
<p>最简单的一个例子。<code>(%rax)</code>, 它用来描述的是rax 中存放的数据，实际上是一个地址。那么加上括号也就是去访问对应rax 所在地址的数据。这点非常像c 语言中的指针类型指针表示一个地址, 通过在指针前面增加星号，意味着是对这个地址中的数据进行访问. 在汇编语言中是使用括号中间加寄存器的方式也可以进行访问。</p>
<h2 id="move指令操作数的组合"><a href="#move指令操作数的组合" class="headerlink" title="move指令操作数的组合"></a>move指令操作数的组合</h2><p>move指令以及三类的操作数，它们之间有一些固定的组合关系。具体如图所示</p>
<p><img data-src="/../../images/image-20201015084519071-1602737851348.png"></p>
<p>注意事项:</p>
<p><strong>1. 立即数只能作为源操作数出现，不能作为目标操作数出现.</strong> 因为我们无法给一个常量进行赋值。</p>
<p>2  <strong>如果源操作数为内存的某个地址的话, 目标操作数必须为寄存器。</strong>move指令是不支持直接将一片内存地址所指向的数据赋值给另一个内存地址. 因为在冯诺依曼体系结构中，处理器是整个计算机的核心, 所有的指令都要通过处理器来去完成, 也就意味着在这个过程中是需要有处理器参与的。如果将一片内存中的数据赋值给到另一片内存中，意味着绕过了处理器。所以在x86的指令中，不提供这样的指令。</p>
<p>如果想在两片内存之间搬运数据，需要以寄存器作为中间媒介进行过渡, 也就是先从内存中, 把数据加载到寄存器里, 然后再通过寄存器把数据放到另外一片内存中。</p>
<h1 id="3-4-2数据访问指令实例"><a href="#3-4-2数据访问指令实例" class="headerlink" title="3.4.2数据访问指令实例"></a>3.4.2数据访问指令实例</h1><p><img data-src="/../../images/image-20201015085120154-1602737875466.png"></p>
<p>左边是c 语言的源码。它实现了一个两个内存区域之间的数据交换, 也就是传入的x p 指针所指向的long形数据和yp指针所指向的long形数据进行了一个交换。在c 语言中定义了两个临时变量，用来暂时存储xp 数据的值和yp 数据的值. 然后分别把这个值交换位置存储回x p 和y p 。这也就实现了两个指针所指向地址数据的交换。</p>
<p><img data-src="/../../images/image-20201015085433948.png"></p>
<p><img data-src="/../../images/image-20201015085433948-1602737904577.png"></p>
<h1 id="3-4-3-寻址模式"><a href="#3-4-3-寻址模式" class="headerlink" title="3.4.3 寻址模式"></a>3.4.3 寻址模式</h1><h2 id="完全寻址模式"><a href="#完全寻址模式" class="headerlink" title="完全寻址模式"></a>完全寻址模式</h2><p><img data-src="/../../images/image-20201015091100840-1602737988337.png"></p>
<p>在x86汇编指令中, 对于内存寻址的方式是非常灵活的. 一个完全内存寻址方式可以采用这样的一个4元组来去表示。<br>                                                       <strong>D(R<sub>b</sub>, R<sub>i</sub>, S)</strong></p>
<p>D是一个偏移量, 它是一个基于内存地址的偏移量，可能是1字节两字节、4字节或者8字节的一个常数。D是一个有符号数. R<del>b</del> 表示内存的基地址, 它是任意的一个整数都可以去描述。R<del>i</del> 叫做索引寄存器, R<del>i</del>寄存器。除了rsp寄存器不能作为R<del>i</del>去表示, 其它的寄存器都可以在R<del>i</del>的位置所表示。</p>
<p>S是表示大小, 它只能是1, 2, 4, 8这几个常数中的一个。因为在高级语言处理数据类型的时候, 基本数据类型的位长, 只有这样的四个值。</p>
<p>该4元组遵循下列规则完成完全寻址模式. </p>
<p>​                                        <strong>Mem[Reg[R<del>b</del>] + S * Reg[R<del>i</del>] + D]</strong></p>
<p> 把R<del>b</del>寄存器中的一个值, 加上R<del>i</del>寄存器中的值乘以S, 再加上D 。利用这样一个运算算出来的值，作为实际内存的访问地址, 从内存的这个地址中去访问数据。这是一个非常灵活的寻址方式. 在这里可控的有两个可变的东西，一个是R<del>b</del>寄存器，一个是R<del>i</del>寄存器。</p>
<h3 id="完全寻址模式特例"><a href="#完全寻址模式特例" class="headerlink" title="完全寻址模式特例"></a>完全寻址模式特例</h3><p>完全寻址模式有一些特例</p>
<p><img data-src="/../../images/image-20201015092446296-1602738014275.png"></p>
<p>进一步的去理解这样的一个完全寻址模式。它和对于数组中的某个下标所在元素进行地址计算的时候的选址非常类似。可以理解为R<del>b</del>是数组的首元素地址, 可以把R<del>i</del>理解为数组的下标。那么想访问R<del>i</del>这个下标的元素，这个元素的地址在哪？就是数组的首地址，加上数组的下标乘以数组中每一个元素的数据位长就可以得到。因为完全寻址模式通过这样的一个灵活的寻址，可以在处理器中很好的去支持数组的访问。通过增加了一个偏移量D, 它可以对于结构体的支持可以实现的更好。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img data-src="/../../images/image-20201015093309854-1602738037965.png"></p>
<p>需要注意的是, 使用move指令去做访问的时候, 采用这样的内存寻址方式, 不是将这样的一个数值赋值给目标操作数, 而是将这个地址所指向的内存中的数据复制给目标操作数。</p>
<h1 id="3-4-4-操作码的后缀"><a href="#3-4-4-操作码的后缀" class="headerlink" title="3.4.4 操作码的后缀"></a>3.4.4 操作码的后缀</h1><p><img data-src="/../../images/image-20201015093512664-1602738060240.png"></p>
<p>数据传输指令，它的助记符是move。在实际应用中，move等指令后面通常包含一个后缀。</p>
<p>对于单字节, 它的后缀表示为d . 双字节, 又叫做字,是word 的首字母, 所以被称为w. double word 叫做双字，实际上是四字节, 对应的操作后缀是l Quadword 表示叫4字，也就是8个字节, 它的后缀是q 。注意一个地址，它的类型也是Quadword, 因为一个地址也是64位的，所以对地址做操作的时候，也是要用q 后缀. 单精度浮点数，它的后缀是ss,  双精度浮点数，它的后缀是sd 。</p>
<p>在<code>AT&amp;T</code> 汇编语言中, 所有的指令助记符后面都会跟有这样的一个后缀用来去描述当前指令所操作的数据的位长.</p>
<p>后缀决定了源操作数和目标操作数的位长. 比如说我们用的是moveb, ，注意后面的两个操作数, 也必须是一字节的两个寄存器。</p>
<p>如果使用move指令, 进行内存访问的时候, 根据后缀决定了我们从内存对应的地址到底访问几个字节的数据, 也就是从那move操作内存的时候，不是只访问那个地址的一个字节的数据。那个地址只是起始地址. 访问几个字节, 是由这个后缀来去决定的。</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3.5 算术运算与逻辑运算</title>
    <url>/posts/CSAPP_3.5_%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97_url.html</url>
    <content><![CDATA[<h1 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h1><p>地址运算指令写法是lea 作为它的助记符，也就是操作码。由于在x86-64位系统中，地址都是64位。所以一般见到的这条地址运算指令，它的这个尾部的数据格式都是以q 作为后缀。</p>
<p><img data-src="/../../images/image-20201015100818384-1602738181388.png"></p>
<span id="more"></span>

<p>lea指令是一个双操作数指令，有源操作数和目标操作数。源操作数通常是一个类似于寻址模式的一个4元组, 该4元组用来进行地址表达式的计算。目标操作数通常是一个寄存器, 用来存放算术运算的地址的结果，存放到寄存器里。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><img data-src="/../../images/image-20201015101734108-1602738207739.png"></p>
<p>地址运算指令，它在设计的初衷的时候，主要是用来去计算像c语言中如<code>p = &amp;x[i]</code>的表达式所对应的一个地址。比如说计算变量x 数组的第 i 的下标所在索引的地址, 赋值给p指针，P存放的是一个地址。计算方法是先算出x 的基地址, 再算出x 中每个元素它的位长, 然后再乘以这个下标i , 得到的就是最后的位置。每个元素的大小, 在高级语言中，通常我们能够见到的就是这四种类型, 就是一字节两字节、四字节或者是八字节。所以在计算的时候, 就是乘以每个数组元素的位长，通常就是这四个数值。</p>
<p><strong>实例</strong> </p>
<p><img data-src="/../../images/image-20201015101748755-1602738236543.png"></p>
<p>在这个具体的这条指令中, D缺省，缺省的时候为D = 0, R<del>b</del>为rdi 寄存器中的值, r<del>i</del>也为rdi 寄存器中的值, S = 2。<br>这样再做一个运算, 是r d i加上r d i 乘以2。和move指令最大的区别是, move指令是把计算后的地址所在的值取出来，放到目标寄存器中。而l e a 指令是把地址算出来, 直接把这个地址赋值给目标的操作数，也就是rax寄存器。换句话说，l e a 指令是不会对内存进行任何访问的。r d i 寄存器是用来存放传入的这个参数x 的。所以这条指令的含义就是x 加上x 乘以2, 然后赋值给r a x 寄存器。所以这个时候r a x 应该是3x。</p>
<p>接下来执行了一个左移指令, 后面会讲到.</p>
<p>那么最后得到的就是x 乘以12作为这个函数的返回值. </p>
<p>在这个实例中, 可以看到本身是一个乘法，一个变量乘以一个常数, 通过编译器转换成汇编语言之后，把它转换成, 1个地址计算指令和1个移位运算指令。因为乘法对于处理器来说，它在计算的时候是一个非常耗时的一个操作, 但是对于基本的运算如加减，基本的移位运算, 它们的运算速度要远远的快于乘法运算的速度. 所以编译器不使用乘法指令去做这样一个x 与常数的相乘, 而是把它转换成很多加法和移位指令的组合。虽然一个乘法指令转换成了两条指令, 但是这两条指令执行的速度, 仍然比一条乘法执行的速度要快的多。所以编译器通常会做这样的一个转换。</p>
<p>l e a 指令虽然最初在设计的时候, 是做地址计算使用, 但是在编译器实际使用的过程中，因为l e a 指令的特性不做任何内存的访问, l e a 指令通常也被用来去进行一些算术运算, 这也是编译器在编译的时候的一个技巧。而l e a 进行的这个算术运算，可以去模拟一些变量与常数之间的运算, 这也是编译器经常使用的一种技巧。</p>
<h1 id="3-5-2-双操作数指令"><a href="#3-5-2-双操作数指令" class="headerlink" title="3.5.2 双操作数指令"></a>3.5.2 双操作数指令</h1><p><img data-src="/../../images/image-20201015103556287-1602738257370.png"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>**源操作数和目标操作数相加的结果放到目标操作数里. **由于第二个操作数是目标操作数，所以所有的这些二元操作数的这种指令，最后运算的结果都是放到第二个操作数. 尤其减法这种两个操作数之间是有顺序的运算, 是目标操作数，也就是目标操作数是被减数, 源操作数是减数。减完的结果存到原先被减数所在的位置中去。</li>
<li><strong>注意区分算数移位和逻辑移位.</strong>  移位指令中间有a, 代表算数移位; 中间有h, 代表逻辑移位.</li>
<li><strong>源操作数可以是立即数, 寄存器和地址, 目标操作数只能是地址和寄存器.</strong></li>
<li>在加减乘运算中, 并没有区分有符号运算和无符号运算. 因为加法运算和减法运算本质上是相同的, 加法减法运算和乘法运算对于有符号数和无符号数来讲，在位级别的运算规则也是相似的。</li>
<li>除法运算分为有符号数除法和无符号除法.</li>
</ol>
<h1 id="3-5-3单操作数指令"><a href="#3-5-3单操作数指令" class="headerlink" title="3.5.3单操作数指令"></a>3.5.3单操作数指令</h1><p><img data-src="/../../images/image-20201015104631290-1602738277336.png"></p>
<p> 看图即可</p>
<h1 id="3-5-4-算数运算示例"><a href="#3-5-4-算数运算示例" class="headerlink" title="3.5.4 算数运算示例"></a>3.5.4 算数运算示例</h1><p><img data-src="/../../images/image-20201015164049061.png"></p>
<p>左面是进行了一些复杂表达式的运算，最后把运算的结果rval变量作为返回值返回。<br>传入的参数有3个参数，x, y, z ,通过编译器可以将这段高级语言的语句翻译成汇编语言的指令. </p>
<p><img data-src="/../../images/image-20201015164449186.png"></p>
<p>用颜色对高级语言中的表达式进行了一个划分, 通过颜色来去确认对应颜色的高级语言的语句。</p>
<p>第一条指令是将x 和y 的值相加，存在变量t1中。x 存放在r d i 寄存器中。<br>也就是函数的第一个参数是存放在rdi寄存器中的, 函数的第二个参数是存放在rsi寄存器中,函数的第三个参数是存放在rdx寄存器中。函数的参数的顺序和寄存器之间是由某种固定关系的。在x86的linux操作系统下啊，第一个参数，第二个参数和第三个参数会固定的映射到这三个寄存器中。</p>
<p>第一个指令是x 和y 相加, 把结果存在t1 变量中，它所对应的汇编指令是使用了一个地址计算指令rdi和r s i 相加, 存放到了rax 里。</p>
<p>为什么在这儿要用地址计算指令, 而不使用标准的算术运算指令add呢? 用add的效果似乎和这个效果是一样的。一个最主要的原因是add指令, 是两操作数的指令, 也就是在运算之后，必然结果会覆盖掉其中一个操作数的值。表达式中后边的运算, 原来的参数x 的值也要参与其他的运算, 原来参数y 的值也要参与其他的运算。所以如果把第一个x +y 这个指令语句转换成add 指令的话，那么必然x 和y 的值有一个值要被破坏。如果不希望它被破坏，那么我们就需要再用一条move指令把某个被破坏的值提前备份出来。这样就变成了move和add两条指令才能完成第一条语句的工作。而地址预算指令可以在多个寄存器之间完成运算, r d i 的值和r s i 的值相加之后，是会存放到r a x 寄存器中, 这样相当于在这个运算的过程中，既做了加法, 同时把加法的结果又放到了一个新的 寄存器中，不破坏原寄存器的值。使用这样一条指令，相当于使用了一条move指令和另一条add指令。这个是编译器的一个设计巧妙的地方。</p>
<p>第二条语句是把z 和t1 相加存放到第t2中，z的值存放在rdx寄存器中, rax 里边存放的是t1 的值, 相加完了之后存放到rax 寄存器中。那么这个时候rax 寄存器中存放的就已经是t2的值了。t1的变量就已经不存在了。就这点是否合理而言, 可以从左边的语句来分析一下。t1变量最后一次使用就是在第二句, 也就是说后面不使用t1 这个变量。因此在第二句将t1变量覆盖掉是合理的。这体现了编译器的另外一个功能, 就是在寄存器的使用之间进行调度, 合理的去使用寄存器。</p>
<p><img data-src="/../../images/image-20201015165930299.png"></p>
<p>紫色的这两条语句对应的是y 乘以48赋值给t4变量。编译器并没有继续执行t 3的这条语句，而是执行了t 4。y 乘以48和我们之前讲到的地址运算的那个例子相似。它是通过两条指令, 从而替换掉了乘法运算指令, 使得计算加速。</p>
<p>首先做的是r s i 加上r s i 乘以2。这个过程就是实现了y乘以3。y 乘以3的结果存放到rdx寄存器中。r d x 计算器之前存放的是z 的值, 但是在t 2这条指令之后，再也不会使用到z 这个变量, 所以r d x 寄存器器可以回收被重新利用。下面一行指令做的是将r d x 寄存器左移4位，相当于乘以二的四次方, 等于乘以16。y乘以3，再乘以16就等于y 乘以48。因此，这条指令通过这样一个两条汇编指令就可以实现。</p>
<p>下一条指令在做的实际上是这第三句t3的语句和第五句t5的指令. x加4, 结果作为t3，然后和t4相加。也就是说，在高级语言中的两条语句, 可能对应到汇编语言中只有一条指令。具体的做法是r d i存放的是, x 的值, r d x 存放的是刚才运算的结果，也就是t 4的值。<br>S缺省就等于1，所以就是x 加上t 4。外面还有D=4，所以是x+t4+4, 等于t 3和t5这两条语句在汇编语言中做了一个合并。因为t3是中间变量可以回收, 所以在这里编译器会把这两条指令, 合并合并成一条地址计算指令就可以得到结果。r c x 计寄存器最终存放的是t 5的结果。</p>
<p>最后t 2要和t 5做一个乘法, 因为t 2是变量，t 5也是一个变量, 所以这样两个变量相乘，是没有办法把它当成是一个变量，当成一个常数，它进行一个分解。所以在这里不得不使用一个惩罚指令来完成。因为惩罚指令是极其耗时的。而在这里没有办法用其他的方法去降低这时间上的开销。</p>
<p>r c x 存放的是t 5的值，r x 存放的是t 2的值, 两个相乘的结果放到r a x 寄存器中。<br>这里在c 语言中, 返回值是r va l . 而在汇编值令中呢，调用的过程返回的时候, 就是使用rax寄存器来去保存返回值。这个是在汇编语言中的一个固定的用法，也就是<strong>r a x 计算器作为返回值的存储。</strong></p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>第一个特征就是<strong>c 语言中的语句顺序和编译后生成的汇编指令的顺序不一定是完全一样的</strong>。也就是指令在执行过程中顺序并不是c 语言中的逻辑顺序, 但最终运行结果是相同的, 编译器在这个过程中可能会打乱顺序。</p>
<p>第二点<strong>c 语言和汇编指令之间并不是一个一对一的关系。</strong><br>某些c 语言的表达式的计算可能映射到汇编语言会被映射成多条指令才能完成, 比如说t 4这个例子会被映射成两条汇编指令。在c 语言中，也有可能多条语句都会映射到某一个指令上, 比如说计算t 3和t5, 虽然在c 语言中是两条语句, 但实际上它对应的是一条汇编指令。</p>
<p>最后一点, <strong>寄存器中进行运算，要比在内存中读取数据进行运算性能要快得多, 编译器会优先把所有的局部变量放在寄存器中。</strong> 如果我们将这样的一个c 语言的语句直接写成return(x+y+z)×((x+4+y×48)), 最终得到的最终的汇编语言指令是相同的。虽然在计算中使用了很多临时变量, 但是这些局部变量不一定需要在内存中存储。在这个例子中，用了6个临时变量。但是这6个临时变量都是存放在寄存器中。换句话说, 这六个变量不消耗内存。这也就是说不要建立一个固定的认识认为声明了变量就会浪费系统内存, 这个概念是错误的。因为我们的编译器已经足够的聪明，足够的智能, 它可以通过合理的去分配寄存器，让这些局部变量优先存储到寄存器中。</p>
<p>另外一点, <strong>不要以为写了这样一个表达式直接去替代这样一个函数的结果，就可以实现对程序的优化。这种认识是完全错误的，虽然语句少了, 但是代码最后执行的效率是一样的。</strong>千万不要以为在编程的时候，少用一个局部变量，或者把表达式写的极其复杂，就变成了对程序做了某种优化。实际上这种认识是完全错误的。从这个例子中可以看到，其实我更推荐于我们例子上的这种写法。为什么？因为在例子中，语句多的写法更便于阅读, 更便于其他的人再去阅读你的代码的时候，更容易的去了解这个表达式的具体含义。<br>如果表达式计算的每个步骤，它都是有相应的物理意义或者是现实意义的话，我们可以用一些特殊的变量命名表示出这种目的意义，这样就会很清晰的看懂这个表达式。但是如果你把表达式压缩到表达式非常少, 这可能对于代码的阅读来讲是会很困难。</p>
<p>换句话说, 语句多的写法和语句少的写法，最后的效果和效率都是一样的。那么哪一种更好呢？当然是对于用户可读性更强的这个代码, 效果会更好。</p>
<h1 id="3-5-5-逻辑运算示例"><a href="#3-5-5-逻辑运算示例" class="headerlink" title="3.5.5 逻辑运算示例"></a>3.5.5 逻辑运算示例</h1><p>看一个以位的逻辑运算为主的一个例子。</p>
<p><img data-src="/../../images/image-20201015181444447.png"></p>
<p>这里面主要使用到了异或(^), 右移(&gt;&gt;), 这个右移主要是算术右移, 因为t1和这个常量17都是有符号数。在C语言语句中还用到了左移和减法, 但是在生成的汇编语言表达式中并没有左移和减法运算。之后还用到了位与运算。rdi 存放的是参数x , rsi 存放的是参数y </p>
<p>第一步是把rdi 复制到rax 中。第二步, rsi和rax 进行一个异或，异或的结果存放在rax。此时rax寄存器中存放的是 <code>x^y</code>, 即t1的值. 第三步把rax 存储的变量进行算数右移17位 , a 表示算数二表示右移, 对应于C语言的第二个语句. 得到的结果为t2, 因为t1在后面的语句中不会再使用, 第二个语句运行的结果可以存放在rax寄存器中.</p>
<p>第三步, c语言语句的第三步计算mask在汇编代码中没有体现, 因为mask 的结果本身是一堆常量来去进行的计算, 在这个表达式中不涉及任何的变量, 这也就意味着不管在什么情况下，mask 应该都是一个固定的值。在这条语句执行之后。因此这样的一个左移和减法的计算过程，实际上是由编译器在编译阶段就已经完成计算。计算完mask的十进制为 8185. 第四步, 对t2和mask进行一个位运算得到rval. </p>
<p><strong>常量与常量之间的运算是在编译器完成的，而不是在运行的时候进行的计算。</strong>这样运行的时候少掉了很多指令, 就增加了运行时的速度。</p>
<p>最后还有一点, 需要注意的是编译器编译出来发现and助记符后缀为l, l表示这是一个32位的指令。运算双方t2和mask都是64位的变量, 但是这里却是用了一个32位的指令.</p>
<blockquote>
<p>背景知识;</p>
<p>在x86-64位处理器上，如果执行一个32位的指令，意味着最后操作的目标寄存器的高32位会被清0。<br>        深层次的说，这是64位处理器，在设计数据通路的时候, 就是用的这种方法去兼容的32位的指令。</p>
</blockquote>
<p>这里的原因如下,  mask 虽然是一个long型(在64位系统中为8字节)的变量, 但是它的高32位的运算结果必然为0。因为整数常量在不做任何说明或增加后缀的时候, 都是以int 型的有符号数常量存在的。所以一个常量运算的结果本身是一个int型 的常量。如果把它赋值给了一个long型的变量。那么在这个过程中会发生一个位扩展。位扩展的时候，由于它是一个正数，所以它高32位在扩展的时候必然为0。高32位为零的mask变量与t2进行位与运算, 结果必定高32位全为0. 也就是说rval的值体现在低32位上.</p>
<p>在and执行32位指令后, 将最终的结果存储到了eax寄存器. 而eax寄存器就是rax寄存器在低32位上的一个别名, 最终返回的还是rax寄存器中的值.</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3.6 控制结构(上)</title>
    <url>/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8A)_url.html</url>
    <content><![CDATA[<h1 id="3-6-1-条件码"><a href="#3-6-1-条件码" class="headerlink" title="3.6.1 条件码"></a>3.6.1 条件码</h1><p>条件码是处理器中的一些特殊标志位.</p>
<p>首先从程序员的角度上去看一下处理器。假设一个程序正在处理器上运行, 那么这个程序当前的状态,可以通过处理器中的一系列信息可以表示出来。那么这些处理器就是所有对于程序员可见的处理器, 以及一些标志位组成的。</p>
<p>之前所谈到的 16个通用寄存器。在寄存器中大量的寄存器被用于表示当前程序中所使用到的一些局部变量, </p>
<p>除此之外，还有两个特殊的寄存器，一个是<code>rsp</code> 寄存器，它表示当前这个程序运行时的栈的顶部地址。还有一个寄存器，就是程序计数器。在x86-64位系统中叫做<code>rip</code> 寄存器。这个寄存器中存放的是当前所执行的这条指令的下一条指令, 也就是接下来要执行的那条指令的地址。</p>
<p><img data-src="/../../images/image-20201011211824400-1602738474650.png"></p>
<span id="more"></span>

<p>除了这些信息之外,还有一些标志位,也用来表示当前处理器的状态,那么这些状态也是非常重要的,如果要让处理器正常的工作，正常的执行程序，这些标志位是必不可少的。这些标志位存放在处理器的一个叫做标志寄存器的专用寄存器中, 标志寄存器是不能通过汇编语言指令直接访问,但是可以间接的修改标志寄存器和间接的访问标志寄存器。</p>
<p>标志寄存器中,包含着一些bit,其中每个bit都有它各自的含义。在这里面我们主要讨论最重要的四个标志位。这四个标志位也把它叫做条件码, 分别是CF, ZF, SF和OF.</p>
<p><img data-src="/../../images/image-20201011212037093-1602738504868.png"></p>
<p><img data-src="/../../images/image-20201011212414609-1602738526768.png"></p>
<p><code>CF</code> 是表示进位标志位。它是对于无符号数而言的, 也就是对于无符号数的两个数进行运算, 如果产生了进位，或者是借位, 这个时候, <code>CF</code>这个标志位会被置1。无符号数出现进位或者借位，就意味着无符号运算出现了溢出。</p>
<p><code>SF</code>是符号标志位, 针对于有符号数, 是表示当前指令运算的结果的符号，它的符号也就是这位和当前指令运算后得到的结果的符号位是一致的。如果运算后的结果为非负数, 那么<code>SF</code>标志位为0, 如果为负数, <code>SF</code>标志位为1。</p>
<p>第三个标志位叫做<code>ZF</code> , 它是零标志位。当运算的结果为零的时候，<code>ZF</code>的标志位会被置1。</p>
<p>最后一个标志位<code>OF</code>。溢出标志位, 溢出标志位是针对于有符号数运算而言的。有符号数运算, 它有可能出现溢出，而不是进位。溢出有一些条件可以判断它。如果对于两个数，如果把它们看作是有符号数，它们在运算的时候产生了溢出。那么溢出标志位则会被置位。标志位被置位有两种方法可以进行，一种叫做隐式置位。另外一种叫做显示置位。隐式置位是通过运行一些算术运算指令之后, 可能会对这些标志位进行置位。</p>
<h2 id="隐式置位-Implicitly-set"><a href="#隐式置位-Implicitly-set" class="headerlink" title="隐式置位(Implicitly set)"></a>隐式置位(<code>Implicitly set</code>)</h2><p><img data-src="/../../images/image-20201011213019033-1602738555592.png"></p>
<p>比如说有一条指令<code>addq</code> 。源操作数和目标操作数进行运算。这实际上就是做了一个两个操作数之间相加，并且把它的和复制给目标操作数这样一个过程。那么每当执行一个算术运算或者逻辑运算指令的时候, 都有可能导致这些标志位的变化, 也就是指令运算后的结果，会影响标志寄存器。</p>
<p>那这里可能会有一个最大的问题, <code>ZF</code>标志位比较容易理解。剩下这些标志位与有符号数和无符号数有关, 但是在处理器去执行汇编指令的时候, 它操作的是寄存器，操作的是内存。寄存器和内存中到底存放的是有符号数还是无符号数呢？实际从汇编语言的角度上是不清楚的。那么这些标志位怎么去置位呢？标志位在置位的时候，实际上是把结果既看做了有符号数，也看做了无符号数。也就是, 假设两个寄存器中的值相加, 如果是无符号数，它会不会有进位？如果有进位<code>CF</code> 就会被置位。如果把这两个寄存器中存放的数字看作是有符号数。那么它会不会溢出？如果会溢出, 它的溢出标志位就会置位。那么还要看最高位，如果是无符号数无所谓。如果要是把这个数看作是一个有符号数，如果它前面有符号位, 那还要根据符号位的值去置<code>SF</code> 。也就是说最后运算出的结果，既把它当做无符号数，也把它当做有符号数。 无符号数如果要是相关的标志位满足条件的话，会置位. 有符号数，满足相关条件的话，对应的标志位也就是条件码会被置位。</p>
<p>溢出标志位，它在什么情况下会被置位?就是当a 和 b 都大于零的时候, 运算的结果小于0。这个时候是必然会被置位的。另外还有一种情况就是a 和b 都小于0, 运算的结果大于0, 这个时候溢出标志位也会置位。也就是溢出的条件就是, 两个加数, 它的符号位。和和的符号位不同, 这个时候就会被置位。</p>
<p><img data-src="/../../images/image-20201011214135849-1602738580755.png"></p>
<p>当然除了加法运算之外, 减法运算、乘法运算以及其它的一些位运算每经历一条指令, 这条指令的效果都会导致这些标志位被置位或者是被复位，也就是被置为1或者置为0。</p>
<p>那么在算术运算和逻辑运算指令中，<strong>有一条指令是不会影响条件码的, 这条指令就是地址计算指令。</strong>(<code> NO set by leaq instruction</code>)也就是地址计算这几个指令执行之后，条件码是不会有任何变化的。不管它是否进位是否溢出，是否为0等等。</p>
<h2 id="显式置位-Explicit-set"><a href="#显式置位-Explicit-set" class="headerlink" title="显式置位(Explicit set)"></a>显式置位(<code>Explicit set</code>)</h2><p><img data-src="/../../images/image-20201015192237287.png"></p>
<p>显式置位就是用汇编语言中一些专门的指令去修改条件码的值. 这些指令本身运算完是不会去修改操作数的。但是这些指令运算之后会影响条件码的值。</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>比如cmp 这条指令, 它是对两个操作数进行比较。其实这个比较的过程和减法的过程非常像，也就是cmpq 这条指令和subq 这条指令非常像。它是把目标操作数减去源操作数得到一个差, 这个差的结果就会影响对应的条件码, 也就是说影响对应的标志位。但是算完的这个差不会去修改参与运算的这两个操作数。所以说它和减法运算的结果最大的不同之处是在于减法运算之后会把差放到目标操作数里。但是在 cmp 这个指令中会做减法，但是不会存放结果, 所以这条指令呢，可以认为它就是做一个比较的指令，怎么做呢？src1减去src 2。那减完了之后，可以根据符号标志位也就是<code>SF</code>和零标志位<code>ZF</code>去判断src1 和src 2 里存放的这两个数之间的关系。如果减完为负数，说明小于。如果减完了符号位为0，这个时候还需要查看0标志位。如果零标志位为1，那说明是等于。如果零标志位不为1为0，那说明是大于。那就通过这样的一个方法就可以实现这两个操作数据之间的比较。当然在这个运算的过程中也会影响进位标志位和溢出标志位。但是在通常使用的时候，使用c m p 指令之后主要观测的就是<code>ZF</code>和<code>SF</code>这两个标准。</p>
<h3 id="testq指令"><a href="#testq指令" class="headerlink" title="testq指令"></a>testq指令</h3><p><img data-src="/../../images/image-20201015194112213.png"></p>
<p>另一个可以用于显示对这些条件码进行置位的指令是testq 。testq这条指令非常像andq ，andq处理指令是按位与运算, 但是andq 会把与的结果放到对应的目标操作数中。testq它不会去存放结果, 但是它运算的结果会影响标志寄存器。</p>
<p>testq可能会影响到的标准寄存器只有<code>ZF</code> 和<code>SF</code> 。因为位与运算是不会影响进位和溢出的。通常用testq 检查某个操作数中的某一位是否为0, 相当于一个操作数里存放的是一个数据, 另一个操作数里存放的是一个掩码。比如说检测src1源数据中最低位是否1, 那这个掩码就可以写成1, 那么它们两个与运算就是看如果最低位为1的话，那么与出来结果就是1就是非零的; 如果最低位为0，他们两个与完必然为零, 这样就可以检测最低位的情况。所以testq主要是用来进行一个掩码的检测, 当然这种方式呢还可以做更多位的同时检测. </p>
<h1 id="条件码的访问"><a href="#条件码的访问" class="headerlink" title="条件码的访问"></a>条件码的访问</h1><p>条件码是不能够直接被修改.  就像使用move指令直接给某个寄存器赋值, 对于条件码是无法实现的。条件码的修改只能通过算术运算或者逻辑运算指令, 间接的显示或者是隐式的完成条件码的修改。同样, 访问条件码也没有像move这样的指令可以直接访问, 它也是需要间接的来去完成访问。这些指令就是一组指令, 就是set 这一组的指令是可以去访问条件码的。</p>
<h2 id="SetX-Instructions"><a href="#SetX-Instructions" class="headerlink" title="SetX Instructions"></a>SetX Instructions</h2><p>set这一组的指令是一个8位的指令。这个指令的格式是set作为操作码后面接着一个寄存器，这个寄存器应该是一个8位的寄存器。set这一组的指令如图所示</p>
<p><img data-src="/../../images/image-20201015194841249.png"></p>
<p>可以在这组指令中看到，不是每条指令都能够读对应的标志寄存器或者叫做条件码的值，而是条件码通过某种运算之后得到的值，可以用set 指令可以得到。</p>
<p>比如说第一条指令sete。它是用来访问零标志位, 如果零标志为1，它通过这个sete 的指令可以实现将对应的这个8位寄存器的最低位置1, 高7位置0这样的一个效果, 后面的这些set 指令也是一样, 都是用来将这8位寄存器的最低位置0或者置1. 置0还是置1，是基于条件也就是一个个位运算的逻辑表达式。<br>        有一个简单的方法用来记忆这些指令, 是根据英文名称的缩写. sete 是什么？sete 是前面用c m p 指令去比较的这两个操作数。如果是相等的话，sete 这条指令就会将对应的这个低八位这个寄存器的最低位置1, 也就是e 表示的是equal, 两个操作数相等就会置1。setne 呢就是当<code>CF</code> 为零的时候置1, 也就是not equal 的时候, sets 是设置符号位也就是说，如果对应这个符号为负, 那么sets 会将这这个寄存器置1。setns 就是不为负的时候置1。</p>
<p>下面的这几个指令setg, setge, setl, setle, 这4个set指令是用来去做有符号数的比较的。首先我们来看setg , setg这个g 就是greater 的首字母, 意味着比较的是两个有符号数是否一个大于另一个, 那么setge是greater or equal, 就是大于等于, 相对于大于来讲，就是把判零的这样一个条件去掉了, 也就是说要么符号位为0且不溢出, 要么就是说符号位为1且溢出了。小于呢？是setl,  less的首字母l 。它在做判断的时候和setge 正好是相反的, 就是把g e 的这个取反去掉了。setle和setg正好是取反, 这样呢就是4条对于有符号数的判断.</p>
<p>最后这两个是基于无符号数运算如果要去判断大于和小于的方法。set a , a就是above 就是大于, 大于是当没有进位, 其实这里边的进位其实上是表示借位的意思, 且不为零的时候, 这个时候是above 。那么set b 呢是below的意思, 这是判断两个无符号数相减, 如果出现了进位, 无符号数减法如果出现了进位实际上是借位。如果出现了借位, 那么就是小于的意思。所以可以用这种方法就可以去理解set这一组指令的设计方法。</p>
<h2 id="低八位寄存器"><a href="#低八位寄存器" class="headerlink" title="低八位寄存器"></a>低八位寄存器</h2><p>在x86-64位寄存器里,每个寄存器的低八位都有一个别名的。之前a b c d 4个寄存器，它的最低位的别名是a l, b l, c l, d l, 除此之外，s i, d i, s p ,b p, 它也有低八位的寄存器。r8到r155也有低八位寄存器的编码。set这一组的指令可以对这低八位的寄存器进行操作。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p><img data-src="/../../images/image-20201015201003733.png"></p>
<p>这有两个long形的有符号数, 如果x大于y , 这时候返回一, 如果x 要是小于等于y , 这个时候返回0。</p>
<p>翻译为汇编语言后, 首先rdi 是放存放的x 的值，那么rsi 是存放y 的值，rax 是作为返回值。</p>
<p>判断x 大于y 还是小于等于y, 使用的指令就是cmpq, 就是做rdi 和rsi 的比较。如果rdi 是大于rsi , 那么这个时候r a x 中的数据应该是1, 否则应该是0。他怎么做的？比较这两个数用setg 这是一个有符号数的大于, 如果大于的话，那么al 寄存器最低位会被置1,  高7位被置0, 否则al 寄存器就为0。这个是大于还是小于等于通过al 寄存器就可以判断。但是注意返回值是int型的, int型是一个四字节的数据。那么现在最低的8位是受影响的, 那么还有高24位, </p>
<p>实际上在这里边是没有对它做任何操作的。这里边要注意一点, 8位指令操作的时候，它的高位是不受任何影响的, 这和32位的指令操作64位寄存器是不一样的。这个8位指令只影响最低8位, 高位是不发生变化的。那为了保证最后返回的值是0或者是1。还需要把高24位填充成0, 这时候就使用了一个指令叫做movzbl 。</p>
<p>movzbl 做的是零扩展. move指令都知道是做数据移动。c 是零扩展的意思。b是拓展源表示的是bite ,一个字节，也就是8位。l是long world, long word 是四字节, 也就是双字。通过这样一条指令，就是告诉计算机要做一个零扩展。扩展源是8比特, 扩展后是32比特, 那么这个是原操作数这是目标操作数，最后执行了这条指令, 会将eax 寄存器的高24位填充成了0, 但实际在这个里面还隐含着做了一个零的填充。因为movezbl 是一个32位的指令, 所以他也会把rax的高32位同样填充成0, 这就是之前我们讲到过的, 一个32位指令去操作64位寄存器的话, 对应目标寄存器的高32位是会被清零的。所以最后rax寄存器它的最高31位都为0, 最低一位就是我们判断出来的结果。</p>
<h1 id="3-6-3-跳转指令"><a href="#3-6-3-跳转指令" class="headerlink" title="3.6.3 跳转指令"></a>3.6.3 跳转指令</h1><p><img data-src="/../../images/image-20201015202411869.png"></p>
<p>在x86-64汇编中，跳转指令也是一个组的指令, 在跳转指令中，可以把它分成两个大类.</p>
<p>第一类是一条指令，就是jmp这条指令。jmp这条指令叫做无条件跳转, 其他的指令。<br>都叫做条件跳转。条件跳转和无条件跳转的指令格式都是相同的, 就是前面是这条指令的。<br>操作码, 后面跟的是一个标签, 这个标签就是说明这个标签儿如果发生跳转，跳转的目标位置, 也就是说这个标签表示的就是跳转的目标地址。条件跳转和无条件跳转最大的区别也在于跳转产生的时机的不同。</p>
<h2 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h2><p>首先来看最简单的无条件跳转。无条件跳转, 也就是说在任何情况下都会发生跳转, 其他的条件跳转呢都是在一定条件满足的情况下才能够完成跳转。如果这个条件不满足, 就顺序执行下面的指令, 如果条件满足是跳转到目标位置去执行指令, 那么这个满足条件的情况和set 这一组的指令也非常像, 通常跳转指令也是和类似于cmp指令或者是test指令联合配合进行。</p>
<h2 id="有条件跳转"><a href="#有条件跳转" class="headerlink" title="有条件跳转"></a>有条件跳转</h2><p>je就是当比较的两个数相等，或者说最后运算的结果为0的时候跳转。<br>       jne是当不相等或者是结果不为零的时候跳转。<br>      js 是根据符号位, 如果为1进行跳转，jns 就是符号位为0的时候进行跳转。<br>      jg 是在做有符号数比较大于的时候跳转, 或者是有符号数大于零时跳转。<br>      jge 是有符号数比较大于等于时跳转, 或者是有符号数大于等于零时跳转。<br>      jl 是有符号数比较小于时跳转, 或者是有符号数小于零时跳转。<br>      jle 是有符号数比较小于等于时, 或者是有符号数小于等于零时跳转。<br>      ja 是无符号数大于时跳转。<br>      jb 是无符号数小于时 跳转。<br>      这就是跳转的基本条件。当条件码满足这样一种情况的时候, 条件码的表达式运算结果为1的时候, 这个跳转才能够发生。</p>
<h1 id="3-6-4-跳转指令的编码"><a href="#3-6-4-跳转指令的编码" class="headerlink" title="3.6.4  跳转指令的编码"></a>3.6.4  跳转指令的编码</h1><p>讨论一下跳转指令的机器指令级别的底层实现,也就是看看在机器指令水平上是如何对跳转指令进行编码的。</p>
<p><img data-src="/../../images/image-20201015203536404.png"></p>
<p>上面给出的是一段C语言程序, 它内部包含着两条和跳转相关的指令, 一条是无条件跳转, 也就是执行这一条指令的时候，是会立刻跳转到L2标签所对应的testq 这条指令, 也就是紧挨着jmp 指令的sarq 指令是不会在jmp指令执行后获得执行的机会的。第二个跳转相关的指令是jg 指令, jg 指令是当满足jg 指令的触发条件的时候，它会跳转到L3所对应的这个标签的sarq 处这条指令所在的位置。转换成汇编代码如下</p>
<p><img data-src="/../../images/image-20201015203756684.png"></p>
<p>最左边表述的是每一条指令的地址。jmp 这条指令被进行编码之后，它的机器指令编码是两个字节, eb 03。eb是用来描述操作码，也就是jmp。真正的跳转目标信息是在后边的这个字节中描述，也就是在03这个位置描述的是跳转信息。那么为什么可以用03去描述跳转目标呢？通常所使用的跳转指令, 它在进行编码的时候, 对于跳转目标都是采用相对位置进行编码, 所以03用来描述的实际上是一个偏移量。跳转的目标是一个偏移是03这样的一个量。那么这个跳转目标他这个03是怎么计算出来的呢？要跳转到的目标位置是test q 这条指令的位置, 4004d8。在当前执行jmp 这条指令的时候, rip 计算器中的值应该是4004d5。因为rip 寄存器存放的是即将要加载的那一条指令的地址。当jmp 在执行的时候, 它下面要加载的地址是4004d5。这是一个顺序的过程, 但是在jmp指令中，它会改变rip 寄存器, 因为它要把rip 寄存器改成新的目标位置的地址, 这样jmp 指令执行完之后, 处理器才能从正确的地址去加载testq这条指令。所以jm p 指令在执行的时候, 在jm p 指令没有执行完之前，它的r i p 寄存器中的值是4004d5。这个偏移量就是根据4004d8，也就是目标位置和当前的指令执行时的rip 计算器的值去计算出来的。换句话说，通过jmp 指令去跳转目标地址。这个目标地址就是根据jmp 指令中的这个偏移量3, 和当前的指令计数器rip寄存器的值进行相加。这样就可以算出真正跳转的绝对地址, 就是4004d8。同理。下面j g 的指令也是类似, 7f 表示的是jg 这个操作码, f8用来编码的是跳转的相对偏移位置信息。f8表示的是什么呢？这里边它采用的是补码表示。所以f8对应的是应该是十进制数-8。执行j g 这条指令的时候，i p 计算器的值应该是4004dd。加上-8, 也就算出来了j g 指令，如果要是满足条件发生跳转时候，它应该跳转到4004d5这个位置。</p>
<p>x86指令集包含一些跳转范围更长的跳转指令。那么编译器呢再去生成机器指令的时候，它会根据实际跳转范围的不同, 选择不同格式的指令去进行跳转，以保证呢这个跳转过程可以满足偏移量的的范围的要求。</p>
<p>总体上我们要了解一点的就是使用的是一个相对偏移量, 用来去存储跳转目标。这样再去实现的时候，可以获得更高的灵活度, 因为不管编译器最后将这些指令分配到哪个地址上去, 它们相对的位置都是不变的。</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3.6 控制结构(下)</title>
    <url>/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8B)_url.html</url>
    <content><![CDATA[<h1 id="3-6-5-使用跳转指令实现条件分支"><a href="#3-6-5-使用跳转指令实现条件分支" class="headerlink" title="3.6.5 使用跳转指令实现条件分支"></a>3.6.5 使用跳转指令实现条件分支</h1><p>这节探讨C语言if else 语句在使用汇编指令表示是采用什么样的方式去表示</p>
<p><img data-src="/../../images/image-20201015205526690.png" alt="image-20201015205526690"></p>
<p>这有一个c 源的代码片段, 它定义了一个函数。这个函数的目标是计算了x 减y 的绝对值, 传入了两个参数x 和y , 如果x 大于y,  就用x 减去y , 否则就用y 减去x 。其实就是去算x 减y 的绝对值, 这样的一个程序，我们通过上面的这样一个指令，把它翻译成汇编指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -0g -S -fno-if-conversion control.c</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>rdi存放的是x的变量，rsi存放的是y 的变量，rax存放的是返回结果.进入这个函数之后，首先把x 和y 做了一个比较。如果x小于等于y 则跳转到.L4. 跳转到L4的时候做了一件事, 把rsi也就是y放到了iax中, 然后用rax 减去x 的值, 然后差放到rax 里, 函数返回。<br>如果不是小于等于，那么就是把x 的值放到rax里, 然后用r ax 去减去y 的值，最后结果存到rax 里，然后过程返回。</p>
<p>如果使用了一个c 语言的goto语句的版本，可以让我们更清晰的去看到条件跳转语句在刚才的汇编语言中的这个跳转分支的过程发挥了一个什么样的作用。</p>
<p><img data-src="/../../images/image-20201015210226351.png" alt="image-20201015210226351"></p>
<p>当然在c 语言中还有一种可以实现简单的条件分支的方法, 就是采用表达式中的三目运算符。</p>
<p><img data-src="/../../images/image-20201015210442197.png" alt="image-20201015210442197"></p>
<h1 id="3-6-6-使用条件数据传输语句实现条件分支"><a href="#3-6-6-使用条件数据传输语句实现条件分支" class="headerlink" title="3.6.6 使用条件数据传输语句实现条件分支"></a>3.6.6 使用条件数据传输语句实现条件分支</h1><p>介绍另一种实现高级语言条件分支语句的形式, 就是使用条件数据传输语句来去实现。</p>
<p><img data-src="/../../images/image-20201015210751884.png" alt="image-20201015210751884"></p>
<p>条件数据传输语句其实也可以认为是一个条件赋值语句。它本质上是实现了这样的一个过程, 就是根据条件码的具体状态来决定是否把源操作数中的值, 赋值到目标操作数中。<br>这个过程和传统的move指令非常相似, 只不过是他在move之前需要判断一下条件码。<br>如果条件码不符合要求，相当于这条指令什么都不做，继续向下执行。如果符合要求就进行复制, 这就是条件数据传输指令的基本功能。</p>
<p>为什么我们还需要引入条件数据传输指令？这是因为条件跳转指令本身具有很大性能上的问题。这个其实涉及到我们处理器体系结构中一个非常重要的技术，叫做流水线技术。现代处理器中都包含着流水线, 流水线技术可以实现对于指令执行的加速, 而且这种加速的效果是非常可观的。但是对于流水线来讲，它需要进行指令的预取, 通常的一个预取策略就是顺序取值。如果遇到跳转指令，那么对于流水线来讲会具有更大的挑战。因为流水线无法判断当前这个语句是否真正进行跳转, 尤其是条件跳转，因为还没有计算出条件的结果，所以流水线没有办法去计算到底是否完成跳转。所以这样就引发了一个问题，就是条件跳转语句其实对于流水线的指令预取是具有破坏性的。因此, 跳转语句本身对于流水线来讲会构成巨大的性能上的挑战, 但是条件数据传输语句将不会出现这种情况, 因为条件数据传输语句不需要实现跳转。</p>
<p><img data-src="/../../images/image-20201015211202045.png" alt="image-20201015211202045"></p>
<p>比如说前面我们谈到的这个三目运算符的例子。如果使用的是条件跳转语句，那么就会分成两个语句块。当不满足条件的时候，会跳入else 这个语句块会执行, 这样就会出现一个跳转。那如果要是采用条件数据传输语句，它怎么去执行的呢？它会首先把then的这个表达式和else 的这个表达式都提前计算出来, 接下来去判断一下是否满足条件。<br>如果满足条件就不进行条件数据传输语句进行复制。如果不满足条件，就把else的结果赋值给最终的结果。注意标红色的这样的一条语句, 在汇编语言指令中使用一条条件，数据传输指令就可以达到这样的一个效果。所以从宏观上看, 这个汇编指令本身都是顺序执行的, 不存在分支和跳转, 这样呢就可以对流水线进行一个优化。使用条件数据传输语句虽然会在前面增加了一些计算量, 但是由于他对流水线进行了优化, 所以流水线性能的优化要高于前期计算所消耗的代价, 所以整体上的优化效果仍然是明显的。</p>
<p>下面来看一个例子</p>
<p><img data-src="/../../images/image-20201015211648837.png" alt="image-20201015211648837"></p>
<p>计算机会把x 减y 的值计算出来，放到rax 寄存器里。把y-x 的值计算出来，放到rdx 计算器里, 然后它再去比较x 和y 之间的大小。cmovle就是一个条件数据传输指令, 它和条件跳转指令的后缀和set 这一组指令的后缀的用法是相同的。它的意思是如果前面的这个比较是小于等于的话，会把rdx 赋值到rax寄存器中。如果要是大于rax 寄存器的值，保持原状也就是说这条指令不做任何的工作。这样我们看在整个的这个过程中，就消除了分支跳转, 对流水线进行了优化。</p>
<h2 id="不适用与条件数据传输指令的场景"><a href="#不适用与条件数据传输指令的场景" class="headerlink" title="不适用与条件数据传输指令的场景"></a>不适用与条件数据传输指令的场景</h2><p><img data-src="/../../images/image-20201015212036490.png" alt="image-20201015212036490"></p>
<ol>
<li>两个表达式计算量都非常大, 这时计算开销要远大于对流水线的优化</li>
<li>表达式具有一些临界的风险情况.</li>
<li>计算中会出现一些副作用. 如两个表达式冲突时.</li>
</ol>
<h1 id="3-6-7-1-do-while循环"><a href="#3-6-7-1-do-while循环" class="headerlink" title="3.6.7 (1) do-while循环"></a>3.6.7 (1) do-while循环</h1><p><img data-src="/../../images/image-20201015212512469.png" alt="image-20201015212512469"></p>
<p>在通过之前条件分支的讨论可以知道。在汇编指令中, 条件跳转, 等价于c 语言中的一个if 的条件判断加goto语句。</p>
<p><img data-src="/../../images/image-20201015212812282.png" alt="image-20201015212812282"></p>
<ol>
<li>位移操作数只有1位的时候, 唯一一个操作数为目标操作数, 移位量为1.</li>
<li>rep指令是一个字符串操作指令, 这里相当于在goto和ret之间插入一个空指令, 作用是优化x86处理器的流水线功能.</li>
</ol>
<p><img data-src="/../../images/image-20201015213209975.png" alt="image-20201015213209975"></p>
<h1 id="3-6-7-2-while循环"><a href="#3-6-7-2-while循环" class="headerlink" title="3.6.7(2) while循环"></a>3.6.7(2) while循环</h1><p>看图就可以了.</p>
<p><img data-src="/../../images/image-20201015213304490.png" alt="image-20201015213304490"></p>
<p><img data-src="/../../images/image-20201015213324421.png" alt="image-20201015213324421"></p>
<p>使用<code>-o1</code>编译选项.</p>
<p><img data-src="/../../images/image-20201015213421900.png" alt="image-20201015213421900"></p>
<p><img data-src="/../../images/image-20201015213530857.png" alt="image-20201015213530857"></p>
<h1 id="3-6-7-for循环"><a href="#3-6-7-for循环" class="headerlink" title="3.6.7 for循环"></a>3.6.7 for循环</h1><p><img data-src="/../../images/image-20201015213618699.png" alt="image-20201015213618699"></p>
<p>将for循环改造成while循环</p>
<p><img data-src="/../../images/image-20201015213815083.png" alt="image-20201015213815083"></p>
<p>将for循环转化成等价的while循环</p>
<p><img data-src="/../../images/image-20201015213934995.png" alt="image-20201015213934995"></p>
<p><img data-src="/../../images/image-20201015214033525.png" alt="image-20201015214033525"></p>
<p>优化后</p>
<p><img data-src="/../../images/image-20201015214146556.png" alt="image-20201015214146556"></p>
<h1 id="3-6-8-1-switch-语句的机器级实现"><a href="#3-6-8-1-switch-语句的机器级实现" class="headerlink" title="3.6.8(1) switch 语句的机器级实现"></a>3.6.8(1) switch 语句的机器级实现</h1><p>switch 语句可以实现的所有功能都可以被条件分支语句，也就是类似于if else , if 的一种形式来表达。既然switch 语句有它的等价表示方式, 为什么在高级语言中还定义switch 这样的一种特殊的语法呢？这是有特殊原因的。</p>
<p><img data-src="/../../images/image-20201016095956782.png" alt="image-20201016095956782"></p>
<h2 id="基于跳转表的switch语句实现"><a href="#基于跳转表的switch语句实现" class="headerlink" title="基于跳转表的switch语句实现"></a>基于跳转表的switch语句实现</h2><p>switch是语句在机器级实现的时候，主要是基于了一个跳转表的数据结构来实现。具体如下</p>
<p>Jump Table是一个数组, 数组中的每一个元素都是一个地址。这个地址指向的是对应的case 语句块的起始地址。switch语句在工作的时候是根据变量的值去跳转表中找到对应位置的元素, 从对应位置的元素中，将某个数组元素的值也就是跳转的目标地址取出来, 然后执行一条跳转语句，跳转到真正目标入口的语句块的起始地址位置上。</p>
<p><img data-src="/../../images/image-20201016100421674.png" alt="image-20201016100421674"></p>
<p>和if else语句相比, switch语句有一个非常大的优势, 就是在整个这个过程不管跳转到哪一个目标语句块, 它所花费的时间都是固定的, 也就是说它的时间复杂度是一个常数类型。</p>
<p>而if else 语句, 如果想执行if else 语句的最后一个语句块, 必须是先做了前n 个语句块的判断之后, 才能够执行。这就说明if else语句查找到目标并进入目标语句块进行执行的时间复杂度是n 。</p>
<p>switch语句利用跳转表这样一个结构，将时间复杂度转换为常数。所以, switch语句的变量必须是整数. 因为只有这个变量是整数，它才能作为查找表的下标, 去进行查表的这样的一个操作。</p>
<h1 id="3-6-8-2-间接跳转"><a href="#3-6-8-2-间接跳转" class="headerlink" title="3.6.8 (2) 间接跳转"></a>3.6.8 (2) 间接跳转</h1><p><img data-src="/../../images/image-20201016101709718.png" alt="image-20201016101709718"></p>
<p>变量的判断主要使用了一个判断的指令cmp去判断rdi和6的大小, 6是一个立即数。接下来用ja指令去进行跳转, ja 是用于无符号数大于的判断。<br>但是x 是一个有符号数。为什么要使用一个无符号数的指令去做判断？因为在case 语句中, 有效范围是从0到6范围内。大于6和小于0的数都会进入到default 这样的一个语句块里,那如果将rdi 的范围换算成无符号数的话，可以认为rdi 就是一个小于等于6的一个无符号数, 因为在有符号数转换成无符号数的时候，负数会被转换成大的一个正数。所以通过ja 这样一条指令，就既可以排除掉小于零的数也可以排除掉大于六的数字。如果是大于6, 指定跳转到某个固定的位置, 否则执行间接跳转。</p>
<h2 id="间接跳转与直接跳转"><a href="#间接跳转与直接跳转" class="headerlink" title="间接跳转与直接跳转"></a>间接跳转与直接跳转</h2><p><img data-src="/../../images/image-20201016104201079.png" alt="image-20201016104201079"></p>
<p>可以根据跳转目标的不同, 将跳转划分成两种类型, 一类叫做<strong>直接跳转</strong>。直接跳转就是在去做跳转的时候,  跳转的目标是一个确定的位置, 那么这种跳转就叫做直接跳转。比如下图中的jmp .L8, 不管在什么情况下，只要执行这条跳转语句，只要它发生了跳转，它就一定会跳转到某个确定的位置。</p>
<p><img data-src="/../../images/image-20201016104524068.png" alt="image-20201016104524068"></p>
<p>另外一种就是<strong>跳转到某个不确定位置的跳转叫做间接跳转</strong>。不确定的位置并不是计算机不知道跳转的确定位置, 而是在执行到这条指令之前是无法提前预知的。地址是基于某个变量去计算出来的。在这里面上图中的<code>jmp *.L4(, %rdi, 8)</code>就是一个间接跳转。这个间接跳转是基于rdi 中的值来去计算出跳转的具体目标。<br>后边这一部分<code>(, %rdi, 8)</code>可以认为就是寻址方式的那个4元组, 就是的D(R<del>b</del>, R<del>i</del>, S)。<br>L4是一个地址, 是跳转表的地址，跳转表是在编译器编译的时候为我们生成的一个固定的只读数据, 就是在内存中分配出一个区域，这个区域不可被修改。但是它内部的变量已经初始化。<br>跳转表的起始地址的标号是L4, 每个数据的数据宽度是八字节, 对应的每个数据的值在后面也定义了就是对应的标签, 标签就是一个地址, 地址本质上也是一种类型的数据。<br>在L4的这个表中,一共包含着7个元素, 7个元素，每个元素都对应着一个标签，也就是都对应着一个地址, 这个地址就是x 等于0的跳转到x 等于6的跳转的目标地址。</p>
<p>rdi和8决定了rdi ，就是这个查找表要访问的下标. 8表示查找表中每个元素的大小, 可以看到这个查找的地址就是L4为起始地址,  加上下标乘以元素大小的偏移量所查到的就是对应这个r d i 的这个下标的地址。最后前面有一个<code>*</code>是把这个地址中的数据取出来作为跳转语句的目标地址。比如说rdi是1, 最后计算后的地址就是L4中的第1个元素的起始地址。<br>从它中间取出来的值就是L3, 跳转语句就是跳转到L3这个标签所指向的位置。</p>
<p>因为这个查找表只有7个元素，所以它只是支持x也就是rdi变量, 从0到6范围内的变化, 小于零和大于6都会跳到某个默认的位置上去, 这个默认的位置就是对应的default . </p>
<h1 id="3-6-8-3-switch语句示例分析"><a href="#3-6-8-3-switch语句示例分析" class="headerlink" title="3.6.8(3) switch语句示例分析"></a>3.6.8(3) switch语句示例分析</h1><p>跳转表和case语句块的映射关系</p>
<p><img data-src="/../../images/image-20201016120257181.png" alt="image-20201016120257181"><br>在整个的这个条件变量里, 0和4是没有所对应的case语句块的, 所以0和4都指向了default 这个语句块, 除此之外，其他的跳转表中的值都是指向了对应的语句块的位置, 可以看到的是x=5和x=6的时候，它指向的语句块都是L7这个语句块, 所以case5和case6它有相同的语句块的处理。</p>
<p><img data-src="/../../images/image-20201016121022303.png" alt="image-20201016121022303"></p>
<h2 id="有break语句的情形"><a href="#有break语句的情形" class="headerlink" title="有break语句的情形"></a>有break语句的情形</h2><p>当x=1的时候，会跳转到L3这个语句块里. 在L3这个语句块里, 它首先把rsi复制给rax, rsi中存放的是参数y的值。第二部做了一个乘法y*z, 结果存到rax 中。由于在函数中，w 是作为最后的返回值出现的, 所以switch语句后也不出现对任何w的处理, L3在计算完成后，由于有break语句，它也不会再执行其他的语句, 调用了过程返回指令导致函数返回。</p>
<p><img data-src="/../../images/image-20201016121558504.png" alt="image-20201016121558504"></p>
<h2 id="落下-Fall-Through-的情形"><a href="#落下-Fall-Through-的情形" class="headerlink" title="落下(Fall-Through)的情形"></a>落下(<code>Fall-Through</code>)的情形</h2><p>case2中, 首先会做一个 <code>y/z</code> 的操作, 完成之后，它会继续执行到case3的语句, 做w+=z的操作.在之前可以看到, 对于把w赋初值为1(<code>long w=1</code>), 在进入switch语句之前。<br>并没有进行, 原因是并不是所有的语句块都需要有把w赋值为1的这样一个操作, 比如说case2这个语句块就不需要对w赋初值, 因为在case 2这个语句块中为w 再一次做赋值。所以w 等于1这个赋值并不是在所有的语句块中都需要。</p>
<p>所以w 等于1是不会在switch 语句之前去做这样一个复制的。因为这样做会浪费指令, 导致程序性能的下降。w=1赋值是按需出现的。比如说在case3的时候, 计算w+=z时，之前是需要w先去赋初值的。所以它在这个位置case 3的时候，才会去先把w赋值成一。<br>但是case2的时候，由于它不需要赋初值，所以给<code>w=y/z</code>之后，紧接着就需要跳转到merge语句块,  因此在case3中需要分成两个语句块。</p>
<p>case2完成后会跳转到merge, case3完成后也会顺序执行到merge语句块,</p>
<p>下图为case3和case2 在一起的汇编代码</p>
<p><img data-src="/../../images/image-20201016122543333.png" alt="image-20201016122543333"></p>
<h2 id="共用标签的情形"><a href="#共用标签的情形" class="headerlink" title="共用标签的情形"></a>共用标签的情形</h2><p><img data-src="/../../images/image-20201016122757174.png" alt="image-20201016122757174"></p>
<h1 id="3-6-8-4-对switch的进一步探讨"><a href="#3-6-8-4-对switch的进一步探讨" class="headerlink" title="3.6.8(4) 对switch的进一步探讨"></a>3.6.8(4) 对switch的进一步探讨</h1><h2 id="查找表的局限"><a href="#查找表的局限" class="headerlink" title="查找表的局限"></a>查找表的局限</h2><p>switch 语句使用查找表去进行实现的时候, 会有非常大的一个性能上的提升。但是查找表本身也具有一定的局限性。</p>
<p>前面例子中所有的case 语句中值都比较小, 是从0到6这样的一个范围内, 那如果case 语句中的值都比较大的时候怎么办呢？如果仍然是从零作为查找表的起始地址到10006。作为一个结束的这样的一个元素。这个查找表的规模就会变得非常大, 而且10000之前的这些查找表中的地址存储的都是相同的，标签都是指向default 。这样就会变得没有意义, 使得查找表大量的数据存储的，实际上都是没有意义的数据, 或者说查找表在所引起的空间复杂度的提高所得到的这个效果要远远大于性能上的提升。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><img data-src="/../../images/image-20201016123010908.png" alt="image-20201016123010908"></p>
<p>第一种解决方法, 是观察一下case 语句它在数轴上的取值是不是相对密集的。如果相对密集比如说上面这个例子是从1万到10006, 它在数轴上仍然相对密集, 只不过是它相对于0, 有了一个整体的偏移。编译器会首先去减去一个固定的偏移量, 使得最后case 语句的这些值处在从零开始的每个某个很小的范围的区间内。这样仍然可以去很有效率做查找。在这个例子中，它是从10000到10006, 可以把它近似成为把x 减去10000，然后继续把减完的这个结果和6去比较，因为它就变成了一个从0到6的这样一个范围, 然后接下来仍然可以使用间接跳转去进行查表来去实现。</p>
<p>那如果在数轴上排列不密集呢?</p>
<p><img data-src="/../../images/image-20201016123655875.png" alt="image-20201016123655875"></p>
<p>更普遍的一种情况处理起来就更加的复杂了, 就是数据的范围是很大。值很大, 而且这些数据在数轴上分布的不密集, 即这些数值在数轴上的分布非常稀疏。</p>
<p>这个时候switch语句通过编译器去实现的时候，就不是以查找表的方式来去实现了。<br>而是以二分搜索的方式来去实现。二分搜索，这是一个数据结构中提供的概念。由于我们的case 语句都是一些孤立的值, 这些值编译器可以给他们进行排序，进行一个二分搜索，或者叫做二分查找。编译后的结果近似等价于这样的一个if else 语句的一个嵌套的过程。<br>注意这个是if 语句中间嵌套if else , else一句话中间再嵌套if else 。使用二分搜索的方式,<br>去查找对应的语句块的时间复杂度是log<del>2</del>n。如果采用if else if ,期望的时间复杂度是n 也就是一个线性时间复杂度。</p>
<p>即使对于case 中的值比较稀疏的这样的一个情况, 编译器仍然可以提供比较高的查找效率。而这个查找要比简单的，if else if 的这样的一种查找要快。<br>所以说这就是switch语句它仍然存在的价值。所以switch 语句是基于值进行查找的。<br>所以可以进行一定程度的优化。编译器足够的聪明，足够的智能, 可以根据不同case 语句的值对整个switch语句进行不同程度的优化. 在C语言c++语言中。在高级语言中，如果有switch 这样的语法,基本实现都是类似的。</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP_3.7_控制(下)</title>
    <url>/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8B)_url.html</url>
    <content><![CDATA[<h1 id="3-7-5-1-栈上的局部存储"><a href="#3-7-5-1-栈上的局部存储" class="headerlink" title="3.7.5(1) 栈上的局部存储"></a>3.7.5(1) 栈上的局部存储</h1><h2 id="语言特性角度的过程存储管理问题"><a href="#语言特性角度的过程存储管理问题" class="headerlink" title="语言特性角度的过程存储管理问题"></a>语言特性角度的过程存储管理问题</h2><p>接下来我们讨论一下过程中的存储管理问题。首先我们先从语言特性的角度上去分析这个问题。</p>
<p><img data-src="/../../images/image-20201013212326391-1602738675000.png"></p>
<span id="more"></span>

<p>现今大多数的编程语言都是支持递归的, 比如说C语言，C++，java c# 等等。这些可以支持递归的语言的一个最基本的要求是需要代码可以重入, 也就是一个过程或者一个函数在调用没有返回之前被再次调用, 能够实现可重入就决定了这个代码内部所使用的局部变量是不能在各个相同的过程调用的实例中共享的, 也就是这个过程在同一时刻可能调用了多次，但是每个过程都有他自己的过程的实例。内部的状态在每个过程之间也是不相同的，也就是它使用的一些变量之类的也是不同的。</p>
<p>这就需要有一个特殊的空间为每个过程实例去存储它的状态。这个状态都包含什么呢？比如说这个过程在调用的时候，它的参数, 可重入的每个过程可能它调用的参数都是不同的, 所以参数就是表示这个过程的状态的情况的一个因素。除此之外，过程内部所定义的一些局部变量也用来描述过程的状态, 还有就是返回地址。虽然过程可重入，但并不意味着每个过程的返回地址都是相同的位置。它也是过程在去运行的时候，这个过程实例的一种状态。</p>
<h2 id="过程调用与栈"><a href="#过程调用与栈" class="headerlink" title="过程调用与栈"></a>过程调用与栈</h2><p>那么基于这样一个特性，我们在结合着栈这样的一个数据结构，可以有一个什么样的结论呢？</p>
<p>过程的状态啊本身是有一个生命周期的概念。就是当过程调用的时候, 这些过程的状态被创建出来，用于存储过程的状态。当过程返回的时候，这些状态就可以释放掉。它存在着这样的一个生命周期，就是调用时创建返回时销毁。</p>
<p>从另一个角度上看过程的调用是什么样子呢？是调用者(<code>caller</code>)。在内部调用被调用者(<code>callee</code>), 就是一个过程去调用另一个过程。那被调用的过程, 是要先于调用者返回。</p>
<p>换句话说，多个过程嵌套调用。最后一个返回的过程应该是最开始的那个过程。最先返回的过程一定是最后被调用的过程。这样的一个特性和栈的特性是非常相似的。因为<strong>栈的特点也是先入后出后入先出</strong>。</p>
<p><img data-src="/../../images/image-20201013212914555-1602738697092.png"></p>
<p>了解了过程调用的特点和栈的特点，把它们结合在一起，就可以发现。将栈与过程调用结合在一起是一个非常完美的结果, 可以把每个过程实例的状态存储在栈上。因为它都是先入后出的特点。所以栈可以和过程非常完美的结合在一起。存储在栈中的这些过程的状态。在这里边叫做帧(“Frames”), 也把这个帧叫做栈帧。</p>
<h2 id="实例-——-栈帧的形成和销毁"><a href="#实例-——-栈帧的形成和销毁" class="headerlink" title="实例 —— 栈帧的形成和销毁"></a>实例 —— 栈帧的形成和销毁</h2><p><img data-src="/../../images/image-20201013213227007-1602738710546.png"></p>
<p>这里面我们给出了一个程序, 这个程序由中包含着3个函数。就是yoo, who和amI函数. 它们之间可以形成这样的一个调用关系, 就是在yoo函数中调用who函数，在who函数中要做两次amI函数的调用。第一次amI函数的调用会进行一个递归。递归一共有3层, 然后返回. 返回后再进入第二个amI的函数, 但是这个函数不会形成递归, 然后返回。</p>
<p><img data-src="/../../images/image-20201013213617686-1602738722325.png"></p>
<h3 id="实例过程分析"><a href="#实例过程分析" class="headerlink" title="实例过程分析"></a>实例过程分析</h3><p><strong>PS: 每段文字所对应的图片都是上方的第一张图片</strong></p>
<p><img data-src="/../../images/image-20201013214016571-1602738736863.png"></p>
<p>首先程序进入到yoo函数。这个时候在栈中会为yoo函数分配一个栈帧。<code>rsp</code>指向的是栈的顶部元素，目前指向的也就是yoo元素的顶部的位置。</p>
<p>rbp 是在某些情况下也是一个具有特殊作用的寄存器, 它用来去指向当前这个栈帧的底部。但是在最新版本的x86-64位gcc编译器中，rbp已经没有了这样的一个特殊作用。它只可以向其它寄存器一样啊，作为通用寄存器正常使用, 没有为它赋予特殊的功能。但是通过某些编译选项的设置，rbp 仍然可以让它指向栈的底部。</p>
<p><img data-src="/../../images/image-20201013214045211-1602738753512.png"></p>
<p>接下来在yoo函数中调who函数。进入who函数会为who函数分配一个栈帧。<code>rsp</code>和<code>rbp</code> 指向了who函数的栈帧顶部和栈帧底部。当然<code>rsp</code>指向的who函数的栈帧顶部也是整个栈的顶部。</p>
<p><img data-src="/../../images/image-20201013214444291-1602738763643.png"></p>
<p>在who函数中调用amI 函数在为amI 函数分配栈帧。rst 和rbp 进行了更新。amI 函数在第一次调用的时候要进行三次递归, 所以amI函数要重入3次，在栈上也是有对应的amI函数的三个栈帧。</p>
<p><img data-src="/../../images/image-20201013214511006-1602738774982.png"></p>
<p>当最内部的amI 函数开始返回的时候，这个时候栈中的相应的栈帧也要会被释放。<br>最后返回who函数.</p>
<p><img data-src="/../../images/image-20201013215024029-1602738792255.png"></p>
<p>这个时候开始调用who函数的第二个amI 函数再次为它分配栈帧。</p>
<p><img data-src="/../../images/image-20201013215118990-1602738804294.png"></p>
<p>这个amI 函数没有进行递归，直接返回回到了who函数。再一次栈帧释放。</p>
<p><img data-src="/../../images/image-20201013215156043-1602738815122.png"></p>
<p>who函数执行完成之后，who函数栈帧释放. 最后yoo函数执行完成之后，yoo函数的栈帧也会从栈帧释放。这就是栈帧与函数调用之间的这样的一个过程。</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3.7 控制(上)</title>
    <url>/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8A)_url.html</url>
    <content><![CDATA[<h1 id="3-7-1-过程调用"><a href="#3-7-1-过程调用" class="headerlink" title="3.7.1 过程调用"></a>3.7.1 过程调用</h1><p>过程对应于c 语言中就是指的函数。函数相当于是对一系列工作流程所进行的一个抽象, 那么函数调用在高级语言中是一个再常见不过的事情。</p>
<p>在这一部分主要讨论一下函数调用，也就是对应到汇编语言中的过程在机器级是如何实现的. 如下有两段代码</p>
<p>一个是P 函数，一个是Q 函数。我们可以看到在P 这个函数中, 调用了Q 这样的一个函数, 实现了一个函数的嵌套调用。在这样的一个嵌套调用中。计算机, 底层主要完成了哪些工作呢？</p>
<p><img data-src="/../../images/image-20201012081916003-1602738888291.png"></p>
<span id="more"></span>

<p> 首先第一点是完成了控制上的一个改变。那么这个过程我们把它叫做控制上的一个传递。也就是程序, 在这个代码片段中执行到某一个位置的时候, 打断了当前的顺序执行, 而切换到另外的一个代码片段进行执行。那在这个代码片段中执行结束之后又会回到刚才结束后的那条语句继续执行, 这个过程中就出现了一个控制上的一个变换, 确切的说就是代码执行地址之间的一个改变和切换。进入到一个新的过程后，从一个过程返回到另一个过程中间都有控制传递的问题。</p>
<p>第二个问题就是关于数据传递的问题。一个函数调用另一个函数可能需要传给这个函数中一些参数。那这样一些参数是通过什么样的方式，什么样的规则进行传入? 一个函数在返回的时候, 可能会将一些函数计算的结果以返回值的形式返回给原函数。那么在这里边还涉及到一个返回值的问题。所以第二个我们要讨论的就是一个数据怎么传入到过程中, 过程中的数据怎么在传回到原过程中。</p>
<p>第三个问题就是关于在过程内部如何去管理内存的问题。在这里主要讨论的一个管理内存的基本单位叫做栈针。这个概念在后面还会深入的展开。栈针主要是用来负责管理当前这个过程中所使用到的一些内存。这里就涉及到如何去管理这片内存。第一是这片内存空间如何去分配。比如说在这声明了一个数组，这个数组存储到哪里, 如何去保存数组中的数据。另外一个概念就是当过程返回的时候，它内部的使用的局部变量将会被销毁。那么这一部分局部变量如果有在内存中进行存储的，它又如何去完成这样的一个释放？<br>        这都涉及到内存管理的问题。</p>
<p>所以以上三方面就是控制的传递，数据的传递以及内存管理. 是我们在过程这一部分所讨论的三个主要的问题。而这些机制, 都是在机器级指令的这样的一个水平上完成的实现。这里讨论也是在汇编语言的水平上去讨论这样的一个高级语言的行为, 在底层是如何实现的。</p>
<p><strong>该章节全部内容针对x86-64</strong></p>
<p><img data-src="/../../images/image-20201012083438576-1602738903141.png"></p>
<h1 id="3-7-2-栈的访问"><a href="#3-7-2-栈的访问" class="headerlink" title="3.7.2 栈的访问"></a>3.7.2 栈的访问</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>下面来讨论一种数据结构, 栈(stack)。栈是计算机中非常重要的一种数据结构。之所以首先去讨论栈这种数据结构, 是因为底层过程的调用是依赖于这样的一种数据结构的。换句话说由于这种结构的重要性, 因此导致了处理器本身是原生支持栈这样一种数据结构的, 它有针对于栈的特殊的操作指令。</p>
<p>栈是一片位于内存中的连续线性空间。栈底通常位于高地址。栈顶, 也就是数据进出的方向, 位于低地址。栈是从高地址向低地址方向生长的。在通用寄存器中有一个<code>rsp</code> 寄存器, 它有一个特殊的功能，就是用来存放栈顶元素的地址的。</p>
<p><img data-src="/../../images/image-20201013192800468-1602738926037.png"></p>
<h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><p>对于栈有两个基本操作, 入栈和出栈。</p>
<h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><p>入栈的指令是<code>pushq src</code>, <code>pushq</code> 是操作码, <code>src</code>是操作数。通常操作数只能是立即数或寄存器。它是一个单操作数的指令。这个指令它的工作可以分为三个步骤。</p>
<p>第一步, 是将操作数中的数据取出. </p>
<p>第二步, 将rsp 的值减8，rsp 内部存放的是栈顶元素的地址, 减8标志着栈进行了一个生长，因为栈是向低地址方向进行生长。之所以减8，是因为push q 是一个64位的指令, 通过这个指令操作, 入栈的数据也是一个64位的数据, 也就是一个八字节的数据, 所以要进行一个减8的操作。</p>
<p>第三步, 将取出的src 中的数据存放到当前更新后的rsp所指向的内存位置中。这样就完成了一个入栈的操作, 入栈是一个原子化的操作，也就是通过这样一条指令就可以完成以下三个部分的内容。</p>
<p><img data-src="/../../images/image-20201013194006836-1602738938709.png"></p>
<p>第二个操作是出栈操作<code>pop</code> 。pop 是他的操作码, 它的操作数通常是寄存器, 不可以是立即数。pop 的工作方式也可以把它分解成三步。</p>
<p>第一步, 根据当前的rsp 寄存器中指向的地址，从这个地址中取出数据。</p>
<p>第二步，将取出的这个数据放入到对应的操作数中。</p>
<p>第三步, 将rsp 寄存器的值加8, 完成了一个栈的收缩过程。这里面可以看到, 没有任何删除数据的工作, <code>pop</code>指令只是将数据取出，放到操作数中。其实在对应的位置应该还保存着原先的数据. 但是我们要知道rsp指向的是当前栈的栈顶元素。通过rsp加8的操作，保证了栈的边界的一个收缩。这个时候就意味着虽然原先的数据在内存中还存在。但是它已经位于栈的外部了。换句话说，也就是这个位于栈的外部的内存已经被回收了, 未来栈再次生长的时候，将会覆盖掉这片空间。这样就完成了一个出栈的操作。</p>
<p><img data-src="/../../images/image-20201013193952013-1602738974660.png"></p>
<h1 id="3-7-3-控制传递"><a href="#3-7-3-控制传递" class="headerlink" title="3.7.3 控制传递"></a>3.7.3 控制传递</h1><p>接下来讨论一下过程调用的过程中是如何发生控制传递的. </p>
<p>在过程调用中的控制传递，需要借助于之前所讨论到的栈这个数据结构, 用来实现过程的调用和传递。它主要所使用的两条指令是<code>call</code>指令和<code>return</code> ，也就是<code>ret</code> 指令。</p>
<p><code>call</code>指令</p>
<p>这条指令是过程调用指令。它的操作码是call，他的操作数是一个标签，也就是对应的过程的入口地址。过程调用指令, 它在执行的时候主要进行了两个工作。首先是把过程调用后过程的返回地址压入栈中, 第二是跳转到标签所指定的位置执行下一条指令。</p>
<p><img data-src="/../../images/image-20201013194841318-1602738990679.png"></p>
<p>可以看到这里最重要的一个信息就是将返回地址首先压入栈中。那么返回地址是什么呢？实际上就是call这条指令，接下来的那条指令的位置, 也就是在call指令后面的那条指令，它所在的地址就是返回地址，也就是对应的这个标签的过程，执行完毕之后再返回，就是要执行这条call指令下边的那条指令所在的位置。</p>
<p>跳转的过程和跳转指令非常类似。它就是将程序的指令计数器也就是<code>rip</code>寄存器设置为了对应目标标签位置地址的值, 这就完成了这样的一个调整。</p>
<p>下面我们来看过程返回指令return ，也就是<code>ret</code> 指令。</p>
<p><img data-src="/../../images/image-20201013195806578-1602739003957.png"></p>
<p>它做的也是两件事。第一件事是从栈顶将返回地址弹出, 并以这个返回地址作为目标地址，再次完成一个跳转。<br>所以call指令和<code>ret</code> 指令都要进行跳转, 只不过是他们在跳转之前, 要对栈进行一些操作. call是要将返回地址入栈。<code>ret</code> 是要将返回地址出栈并进行调整。实际上我们还可以把<code>ret</code> 指令理解为返回地址出栈。出栈到哪个位置? 出栈到<code>rip</code> 寄存器中，这样<code>ret</code> 指令执行完之后，就会从新的位置加载指令。</p>
<h2 id="下面是一个过程调用的实例"><a href="#下面是一个过程调用的实例" class="headerlink" title="下面是一个过程调用的实例"></a>下面是一个过程调用的实例</h2><p><img data-src="/../../images/image-20201013195941992-1602739030125.png"></p>
<p>上面定义了multstore 函数。在multstore 这个函数里边调用了mult2 函数。mult2 函数就是将两个变量相乘，并且将结果返回。右面是这两条指令所对应的反汇编程序。</p>
<p>这里面要说明一些的就是由于反汇编工具，使用的是objectdamp , 所以它反汇编出来的汇编语言的操作码和之前所讲到的汇编程序的操作码有的时候会有一些细微的区别。比如说push 后面没有加q , 其实它是等加于pushq 的。move也是一样。这个callq 和retq 就等价于我们刚才的call指令和<code>ret</code> 指令, 只不过是它在写法上的不同，实际上它的本质是等价的。</p>
<p>首来看在multstore 中去调用mult2 这个函数发生了什么。它首先通过call指令指向了mult2 的标签。那么在机器指令级别mult2 这个标签会被转换成一个地址, 也就是mult2 这个指令的一个目标位置。当前状态下，假设<code>rsp</code> 寄存器也就是栈顶的地址为0x120即将要在执行call之前<code>rip</code> 这个寄存器的存储的地址应该是call这条指令的地址即<code>0x400544</code>, 这是在执行call这条指令即将要执行之前当前的处理器的状态。</p>
<p><img data-src="/../../images/image-20201013201233306-1602739041725.png"></p>
<p>当call指令开始执行的时候, rsp 寄存器就会由于call指令所导致出现了一个入栈的操作。入栈首先是要<code>rsp</code> 寄存器减8，然后把数据放进去。这个时候放入的数据是哪个数据？放入的数据是返回地址，也就是call指令的紧接着的这条指令的地址就是0x400549,<br>放到栈中. 紧接着call指令还要做另外一件事，就是将<code>rip</code> 寄存器设置为mult2 。mult2 这个过程的入口地址是0x400550。因此，call这个指令完成之后，<code>rip</code> 寄存器的值应该变成了0x400550。那么接下来即将要执行的这条指令就是mult2 中的第一条指令，也就是这条move指令. </p>
<p><img data-src="/../../images/image-20201013201726103-1602739052283.png"></p>
<p>过程返回的时候发生了什么?在即将执行过程返回指令，也就是return 这条指令之前。<code>rip</code> 寄存器的值应该是0x400557，表示这条指令即将被执行。<code>rsp</code> 寄存器的值存放的还是栈顶地址。在过程返回时, <code>rsp</code> 寄存器和刚进入过程之前的时候<code>rsp</code> 寄存器的值应该指向的都是压入的返回地址的那个元素所在的位置。接下来<code>ret</code> 指令执行。它要做的一件事就是将栈顶的数据弹出。这个数据弹出的地址就是<code>ret</code> 指令返回的地址, 也就是这个数据弹出被加载到了<code>rip</code> 寄存器里。那么<code>ret</code> 指令执行完毕，接下来即将要执行的指令的地址就是0x400549这个地址。这样就完成了一个过程的返回。</p>
<p><img data-src="/../../images/image-20201013201929109-1602739063821.png"></p>
<h1 id="3-7-4-数据传输"><a href="#3-7-4-数据传输" class="headerlink" title="3.7.4 数据传输"></a>3.7.4 数据传输</h1><p>在过程调用中，如何相互在过程之间传输数据？</p>
<p>这主要就包括两方面的内容，一个是过程调用时如何传入参数。另一个内容就是在过程返回的时候，如何将返回值传出？</p>
<h2 id="过程调用时传入参数"><a href="#过程调用时传入参数" class="headerlink" title="过程调用时传入参数"></a>过程调用时传入参数</h2><h3 id="x86-64系统"><a href="#x86-64系统" class="headerlink" title="x86-64系统"></a>x86-64系统</h3><p>在x86-64系统中。参数的传递是优先使用寄存器来去完成传递的。对于过程的前六个参数都是要放到寄存器中的。剩余的参数将会使用栈来去传递。</p>
<p>在前六个参数中，第一个参数使用rdi 寄存器，第二个参数使用rsi 寄存器。然后是rds，rcx, r8, r9。这是按照这样的一个顺序来去把对应的参数放在规定好的寄存算器内。<br>这种规定方法是在x86-64系统linux 操作系统下使用gcc 编译器的调用规范, 对应的在linux 系统下，其他的编译器也遵循这样的规范。但是不同的操作系统之间，它的规范稍微有一些出入。比如说在windows 系统上, 它也是将其6个参数使用寄存器来传递, 但是这6个寄存器和寄存器的顺序, 是有区别的.</p>
<p>对于超出6个以上的这些参数是在栈中进行传递的。在栈中参数的分布规则是最后一个参数最靠近于栈底, 也就是说最后一个参数应该位于这些参数中地址最高的位置上, 也就是最后一个参数，最先入栈, 然后是第n-1个n-2个，一直到最后是第8个第7个。第7个参数应该是在栈的顶部。这是在x86-64位系统中过程参数的传递规范。这里特别强调一点是在x86-64位处理器上采用这样的一种方式去传递的。</p>
<p><img data-src="/../../images/image-20201013204645921-1602739103193.png"></p>
<h3 id="x86-32位系统-仅作了解"><a href="#x86-32位系统-仅作了解" class="headerlink" title="x86-32位系统(仅作了解)"></a>x86-32位系统(仅作了解)</h3><p>在x86-32位系统中，是完全使用栈来去传递参数，而不使用寄存器。因为在x86-32位处理器中, 是没有r8到215这样8个通用寄存器的, 也就是x86-32位系统的通用寄存器要比64位处理器中的通用寄存器要少一半。它没有足够的通用寄存器来去传递参数, 所以完全都使用栈了去传递。</p>
<h3 id="寄存器传递参数的优点"><a href="#寄存器传递参数的优点" class="headerlink" title="寄存器传递参数的优点:"></a>寄存器传递参数的优点:</h3><p>用栈去传递参数，使用这些参数，将会首先进行内存的访问。而在寄存器中的参数访问起来速度更快，不需要涉及内存。所以如果参数比较少, 那么这些参数是会优先都放在寄存器中，这样可以提高整个程序在执行时的性能。</p>
<h2 id="过程调用时返回参数"><a href="#过程调用时返回参数" class="headerlink" title="过程调用时返回参数"></a>过程调用时返回参数</h2><p><strong>返回值仅仅使用rax 寄存器来去保存</strong>。这也就决定了在c 语言和类似于c++语言中这样的程序中, 函数的返回值只能有一个，而不能有多个。比如说某些脚本语言，它可以返回类似于元组之类的数据类型。在c语言和c++语言中是不行的，它只能返回一个数据。就是因为C和C++的返回值只使用一个寄存器去保存。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img data-src="/../../images/image-20201013205621146-1602739118096.png"></p>
<p>multstore 这个过程本身有3个参数。这三个参数第一个参数是x 。x是存在rdi寄存器里, y是存在rsi寄存器里, dest这个指针是存在rdx这个寄存器里。</p>
<p>在 multstore 去调用mult2这个过程之前, 并没有对rdi 和rsi 这两个寄存器做任何的复制。这样也就意味着在调用mult2的时候, 就是将multstore 的x 的变量和y 变量直接传到mult2中, 并作为mult2 的变量a 和变量b 来去进行运算。运算的过程，它使用了一条乘法指令，实现了a乘以b。</p>
<p>a是保存在rax 寄存器里，b是存在rsi 寄存器里。a乘以b 的结果，最后要存到rax寄存器里。最后return 返回。那么返回值就是存在rax 寄存器.</p>
<p>当mult2 返回的时候会回到call指令的下一条指令继续执行。call指令的下一条指令就是将rax 移动到rbx 所指向的那个地址中去。call指令之前，首先做了一个操作，是将r d x 的值放入到r b x 中。也就是说r b x 中的值就是dest 这个指针所指向的地址, 就是将mult2 的乘法结果存入到dest这个指针所指向的那片内存中。这样就完成了一个将mult 2的返回值赋值给在这个指针指向这个地址的过程。</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP_3.8_数组的分配与访问</title>
    <url>/posts/CSAPP_3_7_%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE_url.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP程序优化技巧总结</title>
    <url>/posts/CSAPP%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93_url.html</url>
    <content><![CDATA[<h1 id="Chapter-6-存储器层次结构"><a href="#Chapter-6-存储器层次结构" class="headerlink" title="Chapter 6 存储器层次结构"></a>Chapter 6 存储器层次结构</h1><h2 id="1-cache存储块的抖动问题"><a href="#1-cache存储块的抖动问题" class="headerlink" title="1. cache存储块的抖动问题"></a>1. cache存储块的抖动问题</h2><p>中文版本 P431 6. 直接映射高速缓存总的冲突不命中</p>
<p>虽然书上的实例针对的是直接映射高速缓存的抖动问题, 但这些也同样适用于组相联映射高速缓存.</p>
<h2 id="2-编写对高速缓存友好的代码"><a href="#2-编写对高速缓存友好的代码" class="headerlink" title="2. 编写对高速缓存友好的代码"></a>2. 编写对高速缓存友好的代码</h2><p>中文书P440 6.5</p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<h1 id="CPU-The-Central-Processing-Unit"><a href="#CPU-The-Central-Processing-Unit" class="headerlink" title="CPU- The Central Processing Unit"></a>CPU- The Central Processing Unit</h1><p>计算机的心脏是“中央处理单元”, 简称“CPU”.</p>
<p>CPU用来运行程序, 程序由一个个操作组成, 这些操作叫做“指令”(<code>instruction</code>). 指令指示计算机所做的行为. 例如算数运算指令,  CPU会让ALU进行算数运算, 又例如内存指令, CPU会和内存通信, 然后读写值.</p>
<h2 id="CPU组件"><a href="#CPU组件" class="headerlink" title="CPU组件"></a>CPU组件</h2><p>从高层次视角, CPU组件之间组合的方式叫做“微体系架构”, 简称“架构”, 如AMD今年10月份发布的zen3架构锐龙5000桌面处理器. 其实不只CPU, 芯片都有架构, 大家9月份听到更多的架构肯定源自于NVIDIA(英伟达)的30系显卡的安培架构等.  架构如此重要, 以至于先进的架构早已经成为了衡量芯片的一项重要指标.</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<h1 id="gitlab-克隆仓库前的操作"><a href="#gitlab-克隆仓库前的操作" class="headerlink" title="gitlab 克隆仓库前的操作"></a>gitlab 克隆仓库前的操作</h1><p><a href="https://blog.csdn.net/Alvin_Lam/article/details/90513353">https://blog.csdn.net/Alvin_Lam/article/details/90513353</a></p>
<p>通过SSH克隆远程仓库（GitLab）到本地</p>
<p>由于不是任何用户都能从远程仓库克隆到本地的，也是需要鉴别的，因此本地需要用git bash 创建一个公钥，而远程仓库也要把这个公钥保存下来，进而本地才可以从远程download。主要步骤如下：</p>
<p>1.首先需要下载一个git for windows，成功安装。</p>
<p>2.在github或者gitlab上有自己的账户。</p>
<p>3.打开git bash.exe 输入ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#x75;&#114;&#95;&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#x79;&#111;&#x75;&#114;&#95;&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a>“ 使用你的邮箱用ssh-keygen命令创建密码对。注意ssh-keygen命令中间没有空格，如果在ssh后面加上空格，会得到Bad escape character ‘ygen’.的错误。</p>
<p>4.在目录C:\Users\your_name.ssh 目录下找到生成的公钥文件id_rsa.pub，记事本打开，将里面的内容复制到剪贴板。</p>
<p>5.打开新建的github或者gitlab账户，找到SSH Keys选项如图：</p>
<p><img data-src="/../../images/20170616000042021"><br>将剪贴板内容粘贴到内容框中，title可以用默认的邮箱名字，最后点击add。这就代表这个用户被远程仓库所承认了，接下来就可以克隆仓库了。</p>
<p>6.可以先选择一个空文件夹用来储存克隆下来的项目，然后鼠标右键选择git bash here，然后输入命令 git clone + 自己Git库的地址，如图</p>
<p><img data-src="/../../images/20170616001413481"></p>
<p>Receiving objects :100% Resolving deltas:100%  代表远程仓库项目已经下载到本地。</p>
<p>创建SSH的目的：</p>
<p>创建SSH KEY(这个作用是来识别你的电脑，相当于人的身份证号)，在你的c盘用户目录下面（我的目录–C:\Users\LX）看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：$ ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#117;&#x72;&#101;&#109;&#x61;&#105;&#108;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#x79;&#111;&#117;&#x72;&#101;&#109;&#x61;&#105;&#108;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a>“，<br>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo+Github pages 个人博客踩雷合集</title>
    <url>/posts/Hexo+Github_pages_%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E9%9B%B7%E5%90%88%E9%9B%86_url.html</url>
    <content><![CDATA[<p>前言：从暑假开始搞个人博客，从零开始一步一步的搭建，部署，其中踩了许多坑，填坑也是化了大把的时间和精力（别问，问就是坑多）。故建立一个踩雷合集记录自己平时在博客中遇到的种种问题。</p>
<p>更重要的是，后期我肯定会对博客进行“魔改”，甚至定制化自己的博客。记录下自己曾经所犯的错误，免得重复掉坑。</p>
<h1 id="Hexo-Github-pages-个人博客踩雷合集"><a href="#Hexo-Github-pages-个人博客踩雷合集" class="headerlink" title="Hexo + Github pages 个人博客踩雷合集"></a>Hexo + Github pages 个人博客踩雷合集</h1><p>编程一时爽, 排雷火葬场</p>
<span id="more"></span>

<h2 id="1-标题请勿加冒号，不会导致自动部署报错，但是网站不会显示新更新文章"><a href="#1-标题请勿加冒号，不会导致自动部署报错，但是网站不会显示新更新文章" class="headerlink" title="1. 标题请勿加冒号，不会导致自动部署报错，但是网站不会显示新更新文章"></a>1. 标题请勿加冒号，不会导致自动部署报错，但是网站不会显示新更新文章</h2><p>踩雷时间：2020年10月5日下午4点到5点。</p>
<h2 id="2-Git初始化一次就可以了-如果在不同层次的文件夹中git都做了初始化-那么就会触发子模块-在Github仓库根目录的根目录下根本打不开这些子模块"><a href="#2-Git初始化一次就可以了-如果在不同层次的文件夹中git都做了初始化-那么就会触发子模块-在Github仓库根目录的根目录下根本打不开这些子模块" class="headerlink" title="2. Git初始化一次就可以了, 如果在不同层次的文件夹中git都做了初始化, 那么就会触发子模块, 在Github仓库根目录的根目录下根本打不开这些子模块"></a>2. Git初始化一次就可以了, 如果在不同层次的文件夹中git都做了初始化, 那么就会触发子模块, 在Github仓库根目录的根目录下根本打不开这些子模块</h2><p>踩雷: 当我搞云主机的时候, 一个下午全砸这里了~~~(&gt;_&lt;)~~~</p>
<h2 id="3-Github仓库的本地位置最好不要随便改-容易出问题"><a href="#3-Github仓库的本地位置最好不要随便改-容易出问题" class="headerlink" title="3. Github仓库的本地位置最好不要随便改, 容易出问题"></a>3. Github仓库的本地位置最好不要随便改, 容易出问题</h2><h2 id="4-养成勤add-commit-push的习惯-如果一次push太多后面就push不上去-要手动一个一个push了"><a href="#4-养成勤add-commit-push的习惯-如果一次push太多后面就push不上去-要手动一个一个push了" class="headerlink" title="4. 养成勤add, commit, push的习惯. 如果一次push太多后面就push不上去, 要手动一个一个push了."></a>4. 养成勤add, commit, push的习惯. 如果一次push太多后面就push不上去, 要手动一个一个push了.</h2><p>花了两个小时解决这个问题~~~~(&gt;_&lt;)~~~~</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 程序的机器级别表示基础</title>
    <url>/posts/CSAPP_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%88%AB%E8%A1%A8%E7%A4%BA%E5%9F%BA%E7%A1%80_url.html</url>
    <content><![CDATA[<h1 id="程序的机器级别表示：基础"><a href="#程序的机器级别表示：基础" class="headerlink" title="程序的机器级别表示：基础"></a>程序的机器级别表示：基础</h1><span id="more"></span>

<p>该章开始就是<strong>整本书，整个课程的真正核心部分</strong>，我们将深入学习机器级别编程，关心计算机为了运行我们的程序，所执行的一串独立的指令。<strong>以汇编语言为媒介，去理解高级语言的种种行为。</strong></p>
<p>实际上有两种形式的机器程序，一个是在计算机上运行的实际目标代码，它们是一串字节，编码处理器执行的指令。由于实际目标代码难以理解，我们利用汇编代码等去理解其含义，这是没有问题的，因为汇编代码与实际目标代码有一对一的映射关系。不同于以前程序员们直接编写汇编代码，现在汇编代码的生成由编译器负责.</p>
<p>但是汇编语言仍然对程序员来说至关重要，作为一个桥梁，它将你的程序和这些代码实际在机器上运行的形式连接起来——汇编代码就是它们的中间形式。该课程不会写很多的汇编代码，取而代之的是阅读由C语言编译器GCC生成的汇编语言，理解编译器产生结果与输入它的内容的联系。</p>
<p><strong>本课程针对是英特尔64位版本的指令集（<code>x86-64</code>）</strong></p>
<h2 id="3-1-历史展望"><a href="#3-1-历史展望" class="headerlink" title="3.1 历史展望"></a>3.1 历史展望</h2><h3 id="Inter-x86-Processors"><a href="#Inter-x86-Processors" class="headerlink" title="Inter x86 Processors"></a>Inter x86 Processors</h3><p>x86对于英特尔处理器来说是一个口头的称谓，因为第一个芯片被称为8086，随后推出了8286，8386等等，共同点是都有86，所有人们只称它为x86。</p>
<p>x86有时汇编称为<code>CISC</code>(<code>Complex Instruction Set Computer</code>), 即复杂指令集.</p>
<h2 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h2><p>假设我们把一个C程序写成两个文件<code>p1.c</code>和<code>p2.c</code>。我们可以用一条<code>Unix</code>命令（<code>Linux</code>系统下）来编译它们。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure>

<p><code>gcc</code>命令代表的是C语言编译器<code>GCC</code>，<code>-Og</code>选项指示编译器应用某种程度的优化，从而产生遵循原始C代码的整体结构且更易于理解的机器代码。调用更高层次的优化，会提高程序的运行效率，但会使得生成的机器代码更加难以理解。</p>
<p><code>gcc</code>命令调用整个程序序列，将源代码转换为可执行代码。首先，C语言预处理器（<code>preprocessor</code>）对源代码进行拓展，包括<code>#include</code>命令指定的任何文件（通常为头文件如<code>stdio.h</code>和<code>#define</code>声明指定的任何宏定义。)<code>.c</code>后缀文件经过预处理器后得到<code>.i</code>后缀文件，如这里会产生<code>p1.i</code>和<code>p2.i</code>文件。<code>.i</code>后缀文件仍然是文本文件。第二步，编译器(<code>complier</code>）将<code>.i</code>后缀文件翻译为<code>.s</code>后缀文件，它们是源文件的汇编码版本。之后，汇编程序（<code>assembler</code>）将汇编码转换为二进制机器码文件<code>p1.o</code>和<code>p2.o</code>。此时<code>p1.o</code>和<code>p2.0</code>虽然是二进制文件，但是还不能执行。最后，链接器（<code>linker</code>）将这两个二进制机器码文件和实现库函数的代码（例如<code>printf</code>）合并，并生成可执行代码文件<code>p</code>（由命令行指令<code>-o p</code>所确定）。</p>
<p>流程图如下</p>
<p><img data-src="/../../images/image-20200929142625325-1601949350254.png"></p>
<h3 id="3-2-1机器级代码"><a href="#3-2-1机器级代码" class="headerlink" title="3.2.1机器级代码"></a>3.2.1机器级代码</h3><p>计算机系统采用了几种不同的抽象形式，通过使用了更简单的抽象模型来隐藏实现的细节。其中两个对机器级别的编程来说十分重要。</p>
<p>第一个是机器级程序的格式和行为是由指令集结构（<code>instruction set architecture </code> or <code>ISA</code>)定义的。大部分的指令集，包括<code>x86-64</code>，描述程序的行为，就好像程序是按顺序执行的，每条指令都是在前一个指令结束时开始。而真实情况是，处理器硬件要复杂的多，它们会同时执行许多指令，同时也采用了保障措施，以确保整体行为符合指令集规定的顺序。</p>
<p>第二，在机器级程序中使用的内存地址被称做”虚拟地址“（<code>visual addresses</code>）。它提供了看上去像一个巨大的字节数组的内存模型。而内存系统的真实运行模式包含了硬件的多重内存结构和操作系统软件。这会在<code>CS:APP</code>第九章中展开具体讨论。</p>
<p>编译器大部分的工作都是完全遵循编译顺序的，它将表达在由C语言提供的相对抽象（对机器而言）的运行模型中的程序转换为处理器能够执行的非常基础的指令。而汇编代码在表达上非常接近机器码。相对于机器码中的二进制形式，汇编码采用是一种更可读的文本形式。<strong>理解汇编代码本身以及它和最初的C语言代码的联系</strong>是深入理解计算机执行程序的关键步骤。</p>
<p><code>x86-64</code>指令集的机器码与最初的C语言代码差别很大。处理器的状态对于C程序员来说通常是隐藏的，仅有部分状态时可见的</p>
<ul>
<li><p>程序计数器（<code>program counter</code> or <code>PC</code>, 在<code>x86-64</code>指令集下被称为<code>%rip</code>寄存器)存储下一条要执行的指令在内存中的地址。</p>
</li>
<li><p>寄存器文件包含16个用来存储64位值的已命名区域。这些寄存器能够存储地址（对应与C语言中的指针）或者整数数据。一些寄存器被用来记载程序状态的关键部分，其他则用来容纳暂存数据。</p>
</li>
<li><p>条件代码寄存器保存最近执行的算术或逻辑指令的状态信息。它们是用来实现数据流中的条件变化，在实现<code>if</code>和<code>while</code>表达式的操作中，它们是必不可少的。</p>
</li>
<li><p>向量寄存器能容纳一个或多个整数或者浮点数。</p>
<p>x86-64架构寄存器一览</p>
<p><img data-src="/../../images/bc4fgr6WeEOPw5i.png"></p>
</li>
</ul>
<p>机器代码将内存简单的看作一个巨大的可寻址字节数组。C语言中的数据类型，无论是单个数据类型还是聚合数据类型（如<code>array</code>和<code>struct</code>），标量还是向量数据类型，无符号还是有符号数据类型，在机器代码看来都是单个字节或者字节的集合。</p>
<p>程序所需要的内存，包括对应的可执行机器代码，一些操作系统所需要的信息，一个用于管理过程调用和返回的运行时间堆和用户自主分配的内存空间（比如用<code>malloc</code>函数申请的内存空间）。正如前面所提到的，程序内存使用虚拟地址来寻址。在任意给定的时间里，只有虚拟内存中限定的子范围才是有效的。例如，<code>x86-64</code>虚拟地址用64位表示。在64位机器目前的实施来看，前面的16位必须设置成0，这样做才有可能在<code>64TB</code>范围内指定一个字节。</p>
<p><img data-src="/../../images/image-20200929200544859.png"></p>
<p>操作系统管理这些虚拟地址空间，将虚拟地址翻译为在真正的处理器内存中值的物理内存。</p>
<p>一个单一的机器指令，只能执行一个非常基础的操作。编译器必须要产生这些指令的序列去实现程序的种种功能。</p>
<h3 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> t = mult(x, y);</span><br><span class="line">    *dest = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在命令行中用<code>-S</code>来查看由C语言编译器产生的汇编代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure>

<p>GCC编译器运行，产生汇编文件<code>mstore.s</code>后不再继续执行下一步操作。</p>
<p>汇编文件会包含各种各样的声明，包括以下几行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multstore:</span><br><span class="line">	pushq %rbx</span><br><span class="line">	movq %rdx, %rbx</span><br><span class="line">	call mult2</span><br><span class="line">	movq %rax, (%rbx)</span><br><span class="line">	popq %rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>在代码中每个缩进行都对应一条机器指令。比如说<code>pushq</code>表明寄存器中的内容<code>%rbx</code>应该被推送到程序栈中。所有关于本地变量名或数据类型的信息都已被删除。</p>
<p>如果我们用<code>-c</code>命令，GCC会编译+处理代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure>

<p>这会产生二进制格式文件<code>mstore.o</code>，因此不能被直接查看。在<code>mstore.o</code>文件1,368字节的文件中有这样的一个14字节的十六进制文字序列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure>

<p>这些代码对应于前面列出的汇编指令。从中我们得出，<strong>机器执行的程序只是一个编码一系列指令的字节序列。</strong>机器对源代码几乎一无所知。</p>
<p>为了看到机器代码文件的内容，我们需要用到一类名为<strong>反编译器</strong>（<code>disassemblers</code>的程序。这些程序从机器代码中生成类似于汇编的格式。<code>Linux</code>系统中的<code>OBJDUMP</code>能实现这一功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">liunx&gt; </span><span class="language-bash">objdump -d mstore.o</span></span><br></pre></td></tr></table></figure>

<p>反编译结果如下图所示</p>
<p><img data-src="/../../images/image-20200929183022928.png" alt="image-20200929183022928">一些机器代码和它的反编译表示的特征值得说明一下</p>
<ul>
<li><p><code>x86-64</code>指令长度为1到15个字节。指令编码的设计使常用的指令和操作数较少的指令比不常用的指令或操作数较多的指令所需的字节数更少。</p>
</li>
<li><p>指令格式的设计使是这样的，从一个给定的起始位置开始，有一个唯一的字节解码成机器指令。例如，只有指令<code>pushq %rbx</code>可以从字节值53开始。</p>
</li>
<li><p>反编译程序纯粹根据机器码文件中的字节序列来确定汇编代码。它不需要访问程序的源代码或汇编码版本。</p>
</li>
<li><p>反编译程序对指令使用了与gcc生成的汇编代码稍有不同的命名方式。</p>
<p>产生实际可运行代码需要在对象代码文件集上运行一个链接器。这些对象代码文件中必须包含主函数<code>main</code>。</p>
<p>假设在文件<code>main.c</code>中有如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>, <span class="type">long</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 --&gt; %ld\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Linux</code>命令行中，我们用如下的命令就可以生成可执行文件<code>prog</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gccc -Og -o prog main.c mstore.c</span></span><br></pre></td></tr></table></figure>

<p><code>prog</code>文件增长到8,655个字节，因为它不仅包含了我们为该过程提供的机器码，还有用来与操作系统互动，开始和终止这段代码的程序。</p>
<p>我们来反编译下<code>prog</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">objdump -d prog</span></span><br></pre></td></tr></table></figure>

<p>反编译器会提取各种代码序列，包含以下内容。</p>
</li>
</ul>
<p><img data-src="/../../images/IMG_1095(20200929-184140).JPG" alt="IMG_1095(20200929-184140)"></p>
<p>这个代码与之前<code>mstore.c</code>文件反编译得到的几乎一致。</p>
<p><code>mstore.c</code>反编译结果（部分）</p>
<p><img data-src="/../../images/image-20200929183022928-1601949386047.png" alt="image-20200929183022928-1601949386047"></p>
<p>一个重要的不同是在左边列出的地址不同。链接器已将该代码的位置转移到不同的地址范围。第二个不同是链接器已经填好了调用函数<code>mult2</code>时<code>callq</code>指令应该使用的地址。链接器的任务之一用为函数调用匹配这些函数可执行代码的位置。最后一个不同是我们会在前一个反编译结果中看到两行额外的代码（代码行8，9）。尽管它们出现在return 指令的后面，但是实际上对程序没有任何影响。它们的作用是占位，使代码到达16个字节的长度，使下一段代码在内存系统性能上有更好的放置位置。</p>
<p>机器指令例子</p>
<p><img data-src="/../../images/image-20201006130849519.png" alt="image-20201006130849519"></p>
<h3 id="3-2-3-汇编语言格式"><a href="#3-2-3-汇编语言格式" class="headerlink" title="3.2.3 汇编语言格式"></a>3.2.3 汇编语言格式</h3><p>本课程采用的是<code>AT&amp;T</code>格式汇编语言。格式为：</p>
<p><img data-src="/../../images/image-20201006133443721.png" alt="image-20201006133443721"></p>
<p>标号是可选的，标号用来显示右边的指令在内存中的位置，不会生成机器指令。</p>
<p>操作码是必选的，操作码用来说明当前指令所进行的行为，例如加减乘除等算术运算。</p>
<p>操作数的个数可以是0个，1个或者两个，两个操作书之间用逗号分隔。操作数的作用是说明当前指令所操作的数据对象。控制指令等不需要操作数。操作数1是源操作数，操作数2是目标操作数。</p>
<p>带解释的汇编语言程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void multstore(long x, long y, long *dest)</span><br><span class="line"> // x in %rdi, y in %rsi, dest in %rdx</span><br><span class="line"> multstore:</span><br><span class="line">	pushq %rbx					# Save %rbx</span><br><span class="line">	moveq %rdx, %rbx			# Copy dest to %rbx</span><br><span class="line">	call mult2					# Call mult(x, y)</span><br><span class="line">	movq %rax, (%rbx)			# Store result at *dest</span><br><span class="line">	popq %rbx					# Restore %rbx</span><br><span class="line">	ret 						# return</span><br></pre></td></tr></table></figure>

<h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><p>由于历史上曾经从16位结构转换到32位架构，Intel用“word”指16字节的数据类型。因此32位数据类型被乘坐“double words”，以此类推。</p>
<p><img data-src="/../../images/IMG_1098(20201006-135031).JPG" alt="IMG_1098(20201006-135031)"></p>
<center>x86-64指令集中C语言数据类型的大小</center>

<p>操作码后必须跟上前缀(<code>Assembly-code suffix</code>), 使用什么数据类型，后面的操作数就必须跟该数据类型一样的位数的寄存器。</p>
<h2 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h2><p>一个x86-64指令集下的CPU包含一组16个存储64位值的通用寄存器(<code>general-purpose register</code>)。这些寄存器用来存储整数和指针数据。它们的名字以<code>%r</code>开头，但是由于历史原因，之后的名称命令规则就不同了。<img data-src="/../../images/IMG_1099(20201006-140309).JPG" alt="IMG_1099(20201006-140309)"></p>
<center> 处理器中的16个寄存器</center>


<p>最初的8086处理器有8个16位寄存器，即从<code>%ax</code>到<code>%bq</code>。</p>
<p>随着32位的拓展，寄存器扩充到了32位，即图中从<code>%eax</code>到<code>%ebq</code>。</p>
<p>之后有拓展到了64位，于是寄存器扩充到了64位，即图中从<code>%rax</code>到<code>%rbq</code>。此外，8个新的寄存器也被添加进来，它们有了新的命名规则，即从<code>%r8</code>到<code>%r15</code>。</p>
<p>汇编语言操作这些寄存器的时候，是以这些寄存器的名称作为操作数进行操作的。 </p>
<p>对于这些寄存器的低32位，在汇编语言中可以使用特殊的名称进行直接访问。对于<code>%rax</code>到<code>%rbq</code>，是以<code>%eax</code>到<code>%ebq</code>进行访问，对于<code>%r8</code>到<code>%r15</code>，是以<code>%r8d</code>到<code>%15d</code>进行访问的。</p>
<p>不同的寄存器在程序中担任不同的角色。</p>
<p>其中最特殊的是栈指针，即<code>%rsp</code>， 用来存放栈顶指针。</p>
<h3 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h3><h3 id="数据访问指令"><a href="#数据访问指令" class="headerlink" title="数据访问指令"></a>数据访问指令</h3><h4 id="Moving-data"><a href="#Moving-data" class="headerlink" title="Moving data"></a>Moving data</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq Source, Dest		# 移动64位数据</span><br></pre></td></tr></table></figure>

<h5 id="操作数种类"><a href="#操作数种类" class="headerlink" title="操作数种类"></a>操作数种类</h5><ol>
<li> 立即数(<code>Immediate</code>)</li>
</ol>
<p>   通常是一个为常数的整数类型，例如 <code>$0x400</code>, <code>$-533</code>。</p>
<p>   与C语言常数类似，但额外添加了<code>$</code>前缀。</p>
<p>   有1, 2, 4和8字节三种编码方式，具体取决于操作码的最后一个字母，该字母用来描述该次操作所涉及的数据位长。</p>
<ol start="2">
<li><p>寄存器(Register)</p>
<p>16个通用寄存器都可以作为操作数</p>
<p>例如：<code>%rax</code>, <code>%r13</code></p>
<p><code>%rsp</code>有特殊用途，用于存放栈顶数据地址。</p>
</li>
<li><p>内存(<code>Memory</code>)</p>
<p>move指令可以通过访问内存中某个地址，从内存中加载数据或者存放数据。</p>
<p>例如：(%rax) 用来描述 （）里存放的数据实际上是一个地址,加上括号，就是去访问<code>%rax</code>所在地址的数据。</p>
</li>
</ol>
<h5 id="move指令组合"><a href="#move指令组合" class="headerlink" title="move指令组合"></a>move指令组合</h5><p><img data-src="/../../images/image-20201006153832873.png" alt="image-20201006153832873"></p>
<h5 id="move指令实例"><a href="#move指令实例" class="headerlink" title="move指令实例"></a>move指令实例</h5><p><img data-src="/../../images/image-20201006163553131.png" alt="image-20201006163553131"></p>
<p><code>ret</code>代表是C语言中的过程返回操作，类似<code>return</code>。</p>
<p>函数调用前</p>
<p><img data-src="/../../images/image-20201006164033124.png" alt="image-20201006164033124"></p>
<p>函数调用后</p>
<p><img data-src="/../../images/image-20201006164236498.png" alt="image-20201006164236498"></p>
<h4 id="完全内存寻址模式"><a href="#完全内存寻址模式" class="headerlink" title="完全内存寻址模式"></a>完全内存寻址模式</h4><p>在x86汇编指令中，内存寻址是十分灵活的。</p>
<p><img data-src="/../../images/image-20201006183926488.png" alt="image-20201006183926488"></p>
<p>D(R<del>b</del>, R<del>i</del>, S) 四元组</p>
<p>D: 基于内存地址的偏移量，有符号数.是1，2，4，8字节的一个常数。</p>
<p>R<del>b</del>：表示内存的基地址：可以是所有的16个寄存器。</p>
<p>R<del>i</del>:  索引寄存器：除了<code>%rsp</code>，其他寄存器都能表示R<del>i</del>。</p>
<p>S:  表示大小。1，2，4，8中的一个. 因为高级语言处理数据类型时，基本数据类型的宽度只有1，2，4，8字节。</p>
<p>Mem[Reg[R<del>b</del>]+S×Reg[R<del>i</del>]+D]: R<del>b</del>寄存器中的值 + R<del>i</del>寄存器中的值×S + D，<strong>运算值作为实际内存的访问地址。</strong></p>
<p>特例：</p>
<ol>
<li><p>某些元素可以不出现在表达式中，如</p>
<p>(R<del>b</del>, R<del>i</del>)                Mem[ Reg[R<del>b</del>] + Reg[R<del>i</del>] ] 此时 D = 0， S = 1</p>
<p>D(R<del>b</del>, R<del>i</del>)                Mem[ Reg[R<del>b</del>] + Reg[R<del>i</del>] + D] 此时  S = 1</p>
<p>(R<del>b</del>, R<del>i</del>, S)                Mem[ Reg[R<del>b</del>] + S * Reg[R<del>i</del>] ] 此时 D = 0</p>
</li>
</ol>
<p><strong>实例</strong></p>
<p><img data-src="/../../images/image-20201006185602512.png" alt="image-20201006185602512"></p>
<p>采用完全内存寻址模式，不是将最后代表”Address“的数值赋值给目标操作数。而是将这个地址所指向的内存中的数据赋值给内存操作数。</p>
<h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="地址运算指令"><a href="#地址运算指令" class="headerlink" title="地址运算指令"></a>地址运算指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaq Src, Dst			# lea为操作码，q为后缀</span><br></pre></td></tr></table></figure>

<p>Src, 源操作数，通常是一个类似于寻址模式的四元组，类似于D(R<del>b</del>, R<del>i</del>， S)。四元组用来进行地址表达式的计算。</p>
<p>Dst，目标操作数，通常是一个寄存器，用来存放算术运算的地址的结果。</p>
<p>地址运算指令用来运算无内存引用的地址计算</p>
<p>比如 p = &amp;x[i]。计算数组x的下标为i的元素所在索引的地址并赋值给指针p。是直接赋值地址。<strong>lea指令不会对内存进行任何访问。</strong> </p>
<p>计算方法： 算出x的基地址，在算出x中每个元素的大小并乘以下标i得到最后的位置。</p>
<p><img data-src="/../../images/image-20201006195213558.png" alt="image-20201006195213558"></p>
<p>%rdi寄存器用来存放传入的long x，</p>
<p>此外，lea指令也可以用作算术运算。</p>
<h3 id="3-5-2-双操作数"><a href="#3-5-2-双操作数" class="headerlink" title="3.5.2 双操作数"></a>3.5.2 双操作数</h3><p><strong>一些算术操作指令</strong></p>
<p><img data-src="/../../images/image-20201006210920968.png" alt="image-20201006210920968"></p>
<p>目标操作数只能是内存或者寄存器，不能是立即数。源操作数三者都可以。</p>
<p>为什么不区分无符号和有符号整数运算？</p>
<p>加法运算对二者在位级别上的运算一致，乘法减法也是如此</p>
<p>除法运算分为有符号数除法和无符号数除法。</p>
<h3 id="3-5-3-单运算操作数"><a href="#3-5-3-单运算操作数" class="headerlink" title="3.5.3 单运算操作数"></a>3.5.3 单运算操作数</h3><p><img data-src="/../../images/image-20201006212009656.png" alt="image-20201006212009656"></p>
<p>实例</p>
<p><img data-src="/../../images/image-20201006212208668.png" alt="image-20201006212208668"></p>
<p>在汇编语言中，由<code>rax</code>寄存器存储最终的返回值。并由<code>ret</code>指令返回。</p>
<p>从中我们发现的现象：</p>
<ol>
<li><p>指令和C语言源代码的顺序可能不同。</p>
</li>
<li><p>一些表达式需要多个指令去完成。</p>
</li>
<li><p>一些指令可以包含多个表达式。</p>
</li>
<li><p>局部（临时）变量不一定要在内存中存储。声明了变量也不一定浪费内存。因为将变量放在寄存器中运算速度远远大于将变量放在内存中，编译器会优先把局部变量放在寄存器中。因此，多用局部变量或者表达式不一定会增加程序运行时间。</p>
</li>
</ol>
<h3 id="3-5-5-逻辑运算示例"><a href="#3-5-5-逻辑运算示例" class="headerlink" title="3.5.5 逻辑运算示例"></a>3.5.5 逻辑运算示例</h3><p>在x86-64处理器上，如果运行一个32位指令，意味着最后操作的目标寄存器的高32位会被清0。</p>
<p><img data-src="/../../images/image-20201007094151811.png" alt="image-20201007094151811"></p>
]]></content>
      <categories>
        <category>计算机专业课</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<p><code>F12</code>从定义和调用之间跳转</p>
<p>可以自己制作头文件, 在‘resource files’中, 后缀为.h, 在<code>Source file</code>中调用需要<code>#incude &quot;header_file_name&quot;</code></p>
<p>黄色箭头可以用鼠标左键来改变位置.</p>
<p>只有拥有源代码生成的进程才可以调试.</p>
]]></content>
  </entry>
  <entry>
    <title>记忆神器anki——基础篇</title>
    <url>/posts/%E8%AE%B0%E5%BF%86%E7%A5%9E%E5%99%A8anki_%E5%9F%BA%E7%A1%80%E7%AF%87_url.html</url>
    <content><![CDATA[<h1 id="记忆神器anki——基础篇"><a href="#记忆神器anki——基础篇" class="headerlink" title="记忆神器anki——基础篇"></a>记忆神器anki——基础篇</h1><p><em><strong>为了更好的阅读，请注意本文结构的思维导图</strong></em></p>
<img data-src="/images/50.png" style="zoom: 33%;" />

<h2 id="情境："><a href="#情境：" class="headerlink" title="情境："></a>情境：</h2><p> 你学习中有木有这样的烦恼？背东西背的慢，记不住，感觉知识不进脑子。</p>
<img data-src="/images/知识不进脑子.jpg" style="zoom:50%;" />

<p>好不容易记住知识，可自己好像一眨眼就忘了</p>
<img data-src="/images/马冬梅.png" style="zoom:50%;" />

<p>有没用这样一款软件，背东西背不会就一直复现，背完了又可以科学复习，还能自己定制需要背诵的内容？最好呢，还能白嫖！！反正我知道你心动了，不如就介绍一下本文的主角——anki。</p>
<p><img data-src="/images/%E7%99%BD%E5%AB%96.jpg"></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><span id="more"></span>

<h2 id="anki的基础功能"><a href="#anki的基础功能" class="headerlink" title="anki的基础功能"></a>anki的基础功能</h2><p>anki的基础功能就是提供知识卡片的实时自定义复习——自定义复习知识的频率，数量和时间。这一切都是软件自动去部署，分配的。前期导入知识卡片后，使用者只需关注知识本身——复习计划什么的交给软件。</p>
<p> 举个例子,今天新学50个单词，设定复习时间为一天后，再第二天设定时刻后，这50个单词将在你背诵时再次出现，实现重复记忆。这些是软件自动去完成的。</p>
<img data-src="/images/anki.png"  />

<h2 id="下载链接和地址："><a href="#下载链接和地址：" class="headerlink" title="下载链接和地址："></a>下载链接和地址：</h2><p><strong><a href="https://pan.baidu.com/s/1Sho5nVWuFybaZdKkxHIRbA">安卓系统anki安装包</a>       提取码:yoe3(放弃在自己手机内置应用商店寻找吧，国内应用商店里没有这个app）</strong></p>
<p><a href="https://apps.ankiweb.net/"><strong>Windows和mac系统版本下载地址</strong></a></p>
<h2 id="iPadOS系统（移动端）anki使用基础教程"><a href="#iPadOS系统（移动端）anki使用基础教程" class="headerlink" title="iPadOS系统（移动端）anki使用基础教程"></a>iPadOS系统（移动端）anki使用基础教程</h2><h3 id="获取anki应用：打开App-Store-，输入关键词anki，找到应用AnkiMobile-Flashcards，下载。"><a href="#获取anki应用：打开App-Store-，输入关键词anki，找到应用AnkiMobile-Flashcards，下载。" class="headerlink" title="获取anki应用：打开App Store ，输入关键词anki，找到应用AnkiMobile Flashcards，下载。"></a>获取anki应用：打开App Store ，输入关键词anki，找到应用AnkiMobile Flashcards，下载。</h3><img data-src="/images/ankiinstall.PNG" style="zoom: 33%;" />

<p><strong>1.在App Store中有多个应用包含关键词anki,请认准上图APP。</strong></p>
<p><strong>2.iOS是anki在所有系统中唯一需要付费的版本，付费163元，可用共享账号方式免费获取。</strong></p>
<h3 id="打开anki-主界面介绍如下"><a href="#打开anki-主界面介绍如下" class="headerlink" title="打开anki,主界面介绍如下"></a>打开anki,主界面介绍如下</h3><img data-src="/images/8.png" style="zoom: 33%;" />

<p>1.官网链接：点击进入anki官网</p>
<p>2.学习记录：以图表和数据形式记录anki使用记录</p>
<p>3.卡片浏览器：以关键词搜索所有卡片</p>
<img data-src="/images/9.png" style="zoom: 25%;" />

<p> 4.偏好设置：设置复习的频率，时间，数量等</p>
<p> 5.同步：登录ankiweb账号后在各系统之间进行同步。</p>
<p> 6.卡片与牌组：卡片是anki中的基本复习单位，牌组（卡组）是特定卡片的集合。</p>
<h2 id="anki导入牌组并开始复习"><a href="#anki导入牌组并开始复习" class="headerlink" title="anki导入牌组并开始复习"></a>anki导入牌组并开始复习</h2><p> 1.将牌组上传到iPad，选择用其他应用打开，拷贝到anki。</p>
<ol start="2">
<li>按住牌组名向右移动，选择重命名或删除牌组。</li>
</ol>
<p><img data-src="/images/13.png"><strong>小技巧：在命名中 加入 :: 设置多级菜单牌组</strong></p>
<p>​               <strong>一级牌组::二级牌组</strong></p>
<p> 2.点击相应牌组，进入复习界面。anki的卡片分为背面和正面（可以自主设置）</p>
<p><em>卡片背面</em></p>
<img data-src="/images/10.png" style="zoom:33%;" />

<p><em>卡片正面</em></p>
<img data-src="/images/11.png" style="zoom:33%;" />

<p> 3.点击屏幕即可切换反面到正面，选择复习时间间隔后即可跳转到下一张卡片。现在，可以开始你的anki初体验了！</p>
<h2 id="复习偏好设置"><a href="#复习偏好设置" class="headerlink" title="复习偏好设置"></a>复习偏好设置</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><img data-src="/images/偏好设置.png" style="zoom: 33%;" />

<h3 id="复习卡片内设置"><a href="#复习卡片内设置" class="headerlink" title="复习卡片内设置"></a>复习卡片内设置</h3><img data-src="/images/12.png" style="zoom: 33%;" />

<h2 id="Mac端（桌面端）anki使用教程"><a href="#Mac端（桌面端）anki使用教程" class="headerlink" title="Mac端（桌面端）anki使用教程"></a>Mac端（桌面端）anki使用教程</h2><p><a href="https://www.zhihu.com/question/28335314">知乎 高冷冷：Anki怎么用？</a></p>
<h3 id="必要说明：1-如果你觉得这个软件难用（可能还有界面丑），这就对了。这个软件的特点就是硬核，操作对新手不友好，需要付出一定的学习成本。但是，我郑重声明："><a href="#必要说明：1-如果你觉得这个软件难用（可能还有界面丑），这就对了。这个软件的特点就是硬核，操作对新手不友好，需要付出一定的学习成本。但是，我郑重声明：" class="headerlink" title="必要说明：1.如果你觉得这个软件难用（可能还有界面丑），这就对了。这个软件的特点就是硬核，操作对新手不友好，需要付出一定的学习成本。但是，我郑重声明："></a>必要说明：1.如果你觉得这个软件难用（可能还有界面丑），这就对了。这个软件的特点就是硬核，操作对新手不友好，需要付出一定的学习成本。但是，我郑重声明：</h3><p>  <em><strong>利用这个软件在学习上提高的效益远大于学习它的时间成本。</strong></em></p>
<p><em><strong>利用这个软件在学习上提高的效益远大于学习它的时间成本。</strong></em></p>
<p><em><strong>利用这个软件在学习上提高的效益远大于学习它的时间成本。</strong></em></p>
<h3 id="长时间使用的话，平板体验最佳。"><a href="#长时间使用的话，平板体验最佳。" class="headerlink" title="长时间使用的话，平板体验最佳。"></a>长时间使用的话，平板体验最佳。</h3><h3 id="anki更多进阶用法详见anki官网，本人博客未来也会更新。"><a href="#anki更多进阶用法详见anki官网，本人博客未来也会更新。" class="headerlink" title="anki更多进阶用法详见anki官网，本人博客未来也会更新。"></a>anki更多进阶用法详见anki官网，本人博客未来也会更新。</h3><h2 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h2><p><a href="https://ankiweb.net/shared/decks/">公开anki牌组（网络）</a></p>
<p>个人（就系我辣）定制系列：</p>
<p>[个人定制六级考研重点词汇3000]（有一些卡片重复，建议背诵去除）</p>
<p>[个人定制考研单词6000词正序版]</p>
<p>[个人定制考研单词5000词正序版]（六千改良版，去掉开头1000个单词）</p>
<p>[插班生四选一选择题集错]</p>
<p>[插班生强化系列重点单词和词组]（有一些卡片重复，建议背诵时去除）</p>
<p>[插班生英语阅读句型和句式]</p>
<p>[插班生英语翻译指导]</p>
<p><a href="https://pan.baidu.com/s/19f8q1P6LdMmQKUgxzbfioQ">资源地址</a>        提取码：w2u6</p>
<p><strong>可能问题</strong></p>
<ol>
<li><p>牌组的字体样式不对，如字体样式单一，颜色单一</p>
<p>考研单词5000词正确样式为</p>
<p><img data-src="/images/14.png"></p>
<p><strong>解决方法</strong>：</p>
<p>利用anki的wordquery插件在pc或mac上自制牌组后同步到移动端：</p>
<p>wordquery插件的使用方法见下面链接：</p>
<p>anki高阶用法：利用wordquery插件实现模板化自动化制作卡片（待更新）</p>
<p><a href="https://www.bilibili.com/video/BV1qW411a7fZ">wordquery网络教学视频链接</a></p>
<p><a href="https://finalion.github.io/WordQuery/guide-cn.html">wordquery官方文档</a></p>
</li>
</ol>
<h2 id="个人使用感受"><a href="#个人使用感受" class="headerlink" title="个人使用感受"></a>个人使用感受</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ol>
<li>利用anki科学的复习机制和自动化部署复习卡片，如果肯花时间并坚持下来，短期记忆转化为长期记忆，记忆效果好。</li>
</ol>
<p>2.正确评估自己，塑造危机感。因为anki都有数据记录，能明确知道，自己的学习进度和速度。</p>
<ol start="3">
<li>软件开源，高度自由。相对于墨墨背单词等同样拥有复习机制的应用来说，anki的自由度更高，可以自己定制牌组的样式，内容，复习机制等方方面面。</li>
</ol>
<p>4.全平台同步，系统之间数据互相流通。比如我通常在pc端做好卡片同步到iPad上去背诵。</p>
<p> 5.插件多，用法多样。anki拥有大量的插件，可以满足不同人群的不同功能。没有想要的插件的话，大佬可以自己DIY一个～(￣▽￣～)(～￣▽￣)～</p>
<ol start="6">
<li>除iOS外其他系统均免费下载~，白嫖党的胜利ヾ(≧∇≦*)ゝ</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li><p>软件入门难，选项多，操作较复杂。（教程多 B站&amp;知乎）</p>
</li>
<li><p>前期需要摸索适合自己的复习机制，复习频繁了会加大工作量，复习不够又记不住。（anki默认的复习机制适合大多数人）</p>
</li>
<li><p>无官方牌组文件，所有牌组都要自己获取。（网上有很多资源）</p>
</li>
<li><p>软件没有沉没机制，未复习卡片会一天天累加，需要日日清。比如我大一暑假一个月没有用anki,待复习卡片数量暴涨到6000多。当然，直接删除牌组就什么事都木有了。</p>
</li>
<li><p>因服务器在国外，anki的同步较慢，且同步失败率较高，这个时候重新同步就好了。</p>
</li>
</ol>
<p><em><em>贴一张自己的使用记录φ(≧ω≦</em>)♪</em>*</p>
<img data-src="/images/17.png" style="zoom:50%;" />

<p> <strong>用了几个月，累计复习80000次卡片，效果还不错(p≧w≦q)，等到了十万就换十万上去n(<em>≧▽≦</em>)n</strong></p>
<h1 id="友情链接："><a href="#友情链接：" class="headerlink" title="友情链接："></a>友情链接：</h1><h2 id="记忆神器anki——进阶教程（一）-待更新"><a href="#记忆神器anki——进阶教程（一）-待更新" class="headerlink" title="记忆神器anki——进阶教程（一）(待更新)"></a>记忆神器anki——进阶教程（一）(待更新)</h2><ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>软件应用</category>
        <category>效率</category>
      </categories>
      <tags>
        <tag>软件应用</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础回顾</title>
    <url>/posts/git_foundatoin_url.html</url>
    <content><![CDATA[<p>前言: 最近换了一台新笔记本,  需要花费大量时间个人定制笔记本上的编程环境. 对于一个计算机专业的学生来说, git肯定是必不可少的. 说来惭愧, 本人在初次用命令行学习git后就转向了Github Desktop和vscode的图形化界面来进行日常的代码版本控制, 没有很好的将命令行运用在平时的学习中. 加上九月份Github Cli 稳定版发布, Github上的操作也可以用命令行完成, 故趁部署个人开发环境之机回顾所学Git知识与操作, 培养命令行操作的习惯.</p>
<p>更重要的原因是, 在旁听某个Linux操作系统通识课时, w接触到一位熟练掌握Linux命令行和快捷键的大二软件工程专业学长, 全程脱离鼠标,仅仅在键盘上就完成了平时开发的各项操作. 顿时感到钦佩, 真正领略到了命令行的魅力,并长叹“我要这鼠标有何用”(狗头), 并在学长好基友的怂恿下“入了教”, 悉心向教主学习. </p>
<p><strong>注: 本文仅仅涉及到git的冰山一角, 仅仅满足学生日常小项目开发需求, 更多操作可参考书籍或git官方文档</strong></p>
<h1 id="Git-基础回顾"><a href="#Git-基础回顾" class="headerlink" title="Git 基础回顾"></a>Git 基础回顾</h1><span id="more"></span>

<h2 id="1-git基本工作流程"><a href="#1-git基本工作流程" class="headerlink" title="1. git基本工作流程"></a>1. git基本工作流程</h2><p>Git基本工作区域可以分为以下三部分</p>
<ol>
<li><p>Working Directory(工作区)</p>
<p>添加, 编辑, 修改文件等动作</p>
</li>
<li><p>暂存区</p>
<p>暂存已经修改的文件统一提交到git仓库中. </p>
</li>
<li><p> Git Repository(Git仓库)</p>
</li>
</ol>
<p>   最终确定的文件保存在仓库, 成为一个新的版本. </p>
<h2 id="2-git本地操作"><a href="#2-git本地操作" class="headerlink" title="2.git本地操作"></a>2.git本地操作</h2><h3 id="基本信息设置-全局"><a href="#基本信息设置-全局" class="headerlink" title="基本信息设置(全局)"></a>基本信息设置(全局)</h3><p>在工程项目文件夹中右键选择<code>Git Bash Here</code>, 打开<code>git</code>命令行.</p>
<p>设置用户名(username即为Github用户名)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br></pre></td></tr></table></figure>

<p>设置用户名邮箱(useremail即为Github注册邮箱, <strong>不用加引号</strong>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email useremail</span><br></pre></td></tr></table></figure>

<p>使用下列命令查看是否设置成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>在下面出现的信息中出现<code>user.name:</code>, <code>user.email</code> , 以及后面信息均正确则说明配置成功.</p>
<blockquote>
<p>常用Linux命令<br>        <code>pwd</code>查看当前动作目录, 返回当前工作目录的绝对路径</p>
<p><code>ls</code>查看在此文件夹中的文件(非隐藏文件)<br>        ls -a 查看所有文件包括隐藏文件.  比如git初始化后生成的<code>.git</code>文件夹就是隐藏文件, ls命令是看不到的.</p>
</blockquote>
<h3 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h3><ol>
<li><p>创建文件夹(在Git bash中运用Linux命令)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir foldername</span><br></pre></td></tr></table></figure>

<p>foldername对应与创建文件夹的名字</p>
</li>
<li><p>在文件内初始化Git(创建git仓库)</p>
<p>通过Linux命令进入文件夹.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd foldername</span><br></pre></td></tr></table></figure>

<p>逆操作: 返回上一级文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>初始化Git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>之后在新创建文件夹中会出现隐藏文件<code>.git</code>(如果看不到的话设置电脑显示隐藏文件)</p>
</li>
</ol>
<h3 id="向仓库中添加文件"><a href="#向仓库中添加文件" class="headerlink" title="向仓库中添加文件"></a>向仓库中添加文件</h3><p><strong>一开始的操作均是在本地工作区(Working Directory)</strong></p>
<ol>
<li><p>新建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure>

<p>文件夹中便会出现目标文件</p>
<blockquote>
<p>git常用命令</p>
<p>git status 可以查看当前工作目录的状态.</p>
</blockquote>
<p>在git bash中输入Linux命令 <code>git status</code>, 输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">On branch master					# 当前处于仓库中的master分支</span><br><span class="line"></span><br><span class="line">No commits yet						# 还没有commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)	# 检测到未提交(add)的改变</span><br><span class="line">        filename</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编辑(修改)新文件(可选)</p>
<p>在git bash中输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim filename                           # 在命令行中打开vim编辑器修改文件</span><br></pre></td></tr></table></figure></li>
</ol>
<p> 会出现许多以<code>-</code>开头的空行,并在下方显示<code>filename [unix] (time date) </code>                                                                                                                                                                                                                  在空行区域即可用vim编辑文件, 注意先按 “i”键进入插入模式再开始编辑!</p>
<p>题外话: vim编辑器是知乎, 学长, Google等都在推荐的编辑器, 目前为止我还不是习惯vim这种极简的编辑器(当然以后会折腾vim的配置), 正在努力适应.</p>
<p>当然也可以用编辑器或者IDE来编辑(修改文件), 在git bash中输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">code .						# 使用vscode打开当前文件夹</span><br></pre></td></tr></table></figure>

<p>​    3. 退出文件修改并保存(命令行中, 可选)</p>
<p>按esc键(结束输入), 并在下方输入<code>:wq</code>,退出编辑.</p>
<blockquote>
<p>Linux命令</p>
<p>cat filename                // 查看当前文件中的内容</p>
</blockquote>
<ol start="4">
<li> 将修改文件提交到暂存区</li>
</ol>
<p>   在修改文件所在文件夹中打开git bash 输入以下命令</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &#x27;filename&#x27;				# 将新文件提交到 暂存区</span><br></pre></td></tr></table></figure>
<p>   当改变的文件较多，git add 逐个提交命令繁琐或者不上传新文件，被删除文件时，以用如下的命令</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add -A  # 提交所有变化</span><br><span class="line">git add -u  # 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</span><br><span class="line">git add .  #提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时输入 git status 会显示如下</p>
<p>On branch master</p>
<p>No commits yet</p>
<p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)<br>       new file:   filename                                                                // 显示暂存区内的新文件</p>
</blockquote>
<p><strong>此时文件从本地工作区提交到暂存区.</strong></p>
<ol start="5">
<li><p>将暂存区文件添加到仓库</p>
<p>在git bash 中输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;Your description about this change&quot;			# &#x27;&#x27;中填写你对本次修改的说明(必须)</span><br></pre></td></tr></table></figure></li>
<li><p> 删除文件并提交到仓库</p>
</li>
</ol>
<p>   Linux命令从工作区中删除文件</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf filename											 # 删除文件</span><br></pre></td></tr></table></figure>

<p>   从git中删除文件</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm filename											# filename指的是需要操作的文件名</span><br></pre></td></tr></table></figure>

<p>   提交操作</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;Your description about this change&#x27;		# &#x27;&#x27;中填写你对本次修改的说明(必须)</span><br></pre></td></tr></table></figure>

<h2 id="3-Git管理远程仓库"><a href="#3-Git管理远程仓库" class="headerlink" title="3. Git管理远程仓库"></a>3. Git管理远程仓库</h2><p>   作用: 备份, 实现代码共享集中化管理.</p>
<ol>
<li><p>将Github远程仓库clone到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone repository_location				# repository location指的是需要复制的远程仓库地址</span><br></pre></td></tr></table></figure></li>
<li><p>对克隆到本地的Github仓库进行操作(详见2.git本地操作)</p>
</li>
<li><p>将本地仓库同步到git远程仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li><p>（可选）在本地已经有工作区，需要从GitHub远程仓库更新到本地工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin branchname	// branchname指的是需要更新的分支的名称</span><br></pre></td></tr></table></figure>

<p>使用git pull 更新，相当于是从远程获取最新版本并merge到本地</p>
</li>
</ol>
<h2 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4. 拓展"></a>4. 拓展</h2><blockquote>
<p>Git website: <a href="http://git-scm.com/">http://git-scm.com</a></p>
<p>Free on-line book: <a href="http://git-scm.com/book">http://git-scm.com/book</a></p>
<p>Reference page for Git:<a href="http://gitref.org/index.html">http://gitref.org/index.html</a></p>
<p>Git tutorial :<a href="http://schacon.github.com/git/gittutorial.html">http://schacon.github.com/git/gittutorial.html</a></p>
<p>Git for Computer Scientists: <a href="http://eagain.net/articles/git-for-computer-scientists/">http://eagain.net/articles/git-for-computer-scientists/</a> </p>
</blockquote>
<p>在命令行中, 输入以下指令获取更多git指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git help verb     # verb = config, add, commit, etc</span><br></pre></td></tr></table></figure>

<p>推荐书籍:</p>
<h1 id="Pro-Git"><a href="#Pro-Git" class="headerlink" title="Pro Git"></a>Pro Git</h1><p><a href="https://img9.doubanio.com/view/subject/l/public/s4245786.jpg"><img data-src="https://img9.doubanio.com/view/subject/s/public/s4245786.jpg" alt="Pro Git"></a></p>
<p>作者: <a href="https://book.douban.com/author/4560652/">Scott Chacon</a><br>        出版社: Apress<br>        出版年: 2009-8-27<br>        页数: 288<br>        定价: USD 34.99<br>        装帧: Paperback<br>        ISBN: 9781430218333</p>
<p>结语: 仅仅掌握这些是远远不够的, 真实的项目开发要复杂的多, git也不是一篇两篇文章可以掌握的. 后续会参考一些书籍与视频, 完善git从入门到精通的种种操作,  争取将git熟练运用于真实的项目开发中.</p>
]]></content>
      <categories>
        <category>软件应用</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>软件应用</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/posts/hello_world_url.html</url>
    <content><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><p>你好世界</p>
<span id="more"></span>

<p>原文内容</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Github Pages博客配置总结</title>
    <url>/posts/lab09.html</url>
    <content><![CDATA[<h1 id="Hexo-Github-Pages博客配置总结"><a href="#Hexo-Github-Pages博客配置总结" class="headerlink" title="Hexo + Github Pages博客配置总结"></a>Hexo + Github Pages博客配置总结</h1><h1 id="博客主题及其选择原因"><a href="#博客主题及其选择原因" class="headerlink" title="博客主题及其选择原因"></a>博客主题及其选择原因</h1><p>我是在三年前， 也就是大一入学不久就建立了我的这个博客（<a href="https://zhangchunxian.github.io/%EF%BC%89%EF%BC%8C%E5%BD%93%E6%97%B6%E6%88%91%E7%9C%8B%E4%BA%86%E4%B8%80%E4%BA%9B%E6%9C%AC%E6%A0%A1%E5%AD%A6%E9%95%BF%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%BB%BA%E7%AB%8BHexo%E5%8D%9A%E5%AE%A2%E4%B9%9F%E6%98%AF%E5%8F%97%E5%88%B0%E4%BA%86Godweiyang%E5%AD%A6%E9%95%BF%E7%9A%84%E8%BF%99%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82%EF%BC%88">https://zhangchunxian.github.io/），当时我看了一些本校学长的博客，建立Hexo博客也是受到了Godweiyang学长的这篇博客的影响。（</a> <a href="https://godweiyang.com/2018/04/13/hexo-blog/%EF%BC%89%E3%80%82">https://godweiyang.com/2018/04/13/hexo-blog/）。</a> 在这篇文章中Godweiyang就是使用Hexo框架配置的个人博客。 </p>
<p>至于Hexo与github pages的好处, 比起自己搭建博客，这两个结合在一起可以省去购买域名和服务器的成本，不需要考虑定期维护，对于不使用全栈的人（比如我），非常省力</p>
<p>为什么选择Hexo框架的next主题呢? 主要是因为在翻阅Hexo主题时, 最中意的就是这篇博客(<a href="https://blog.ahao.moe/)%E7%9A%84%E6%A0%B7%E5%BC%8F%E4%BA%86">https://blog.ahao.moe/)的样式了</a>, 里面使用的样式就是next, 所以我就选择了next主题.</p>
<h1 id="博客页面及其设计思路"><a href="#博客页面及其设计思路" class="headerlink" title="博客页面及其设计思路"></a>博客页面及其设计思路</h1><p>博客页面布局如下:</p>
<ul>
<li>页面菜单栏: 包含主页, 标签, 分类, 归档, 关于, 搜索等选项</li>
<li>页面菜单栏: 包含个人联系方式, 博客信息, 友情链接等信息.</li>
<li>内容栏: 包含最近发布的缩略的博客文章.</li>
</ul>
<p><img data-src="/./images/image-20230510192257469.png" alt="image-20230510192257469"></p>
<h1 id="博客功能实现及其技术选择"><a href="#博客功能实现及其技术选择" class="headerlink" title="博客功能实现及其技术选择"></a>博客功能实现及其技术选择</h1><p>Hexo + github的搭建网上已经有很多文档了, 简单来说可以分为三步</p>
<ul>
<li><p>在github上建立公开仓库, 名字必须为  自己的Github用户名.github.io, readme初始化的选项也要选择.</p>
</li>
<li><p>在本地安装npm包hexo-deployer-git, 使用<code>hexo new post &quot;article title&quot;</code> 新建一篇文章, 在source/_posts/文件夹下会看到新建的.md文件, 在md文件里面编辑即可.</p>
</li>
<li><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦.</p>
</li>
</ul>
<h2 id="选择markdown作为编辑语言"><a href="#选择markdown作为编辑语言" class="headerlink" title="选择markdown作为编辑语言"></a>选择markdown作为编辑语言</h2><p>博客渲染本质上是将markdown转化为html渲染在静态页面上.</p>
<p>Markdown是一种轻量级的标记语言, 非常简单易学. Markdown其实就是用一些简单符号来起到排版作用，因为纯键盘操作，写作时少调用鼠标，效率能提升很多，不必多花时间在排版上。对于博客来说, 写作本身就是最重要的.</p>
<h1 id="博客样式及其美学考量"><a href="#博客样式及其美学考量" class="headerlink" title="博客样式及其美学考量"></a>博客样式及其美学考量</h1><h2 id="文章的分类与整理"><a href="#文章的分类与整理" class="headerlink" title="文章的分类与整理"></a>文章的分类与整理</h2><p>每个博客文章都有对应的时间, 标签, 分类. </p>
<ul>
<li><h2 id="在菜单栏点击标签页面可以根据标签查看博客"><a href="#在菜单栏点击标签页面可以根据标签查看博客" class="headerlink" title="在菜单栏点击标签页面可以根据标签查看博客"></a>在菜单栏点击标签页面可以根据标签查看博客</h2></li>
<li>在菜单栏点击归档, 可以按照时间顺序查看博客.<ul>
<li><img data-src="/./images/image-20230511163338541.png" alt="image-20230511163338541"></li>
</ul>
</li>
<li>在菜单来点击分类, 可以按照分类查看博客.<ul>
<li><img data-src="/./images/image-20230511163418490.png" alt="image-20230511163418490"></li>
</ul>
</li>
</ul>
<p>最后, 可以根据文字内容搜索博客相关内容.</p>
<p><img data-src="/./images/image-20230511163448915.png" alt="image-20230511163448915"></p>
<h1 id="博客制作过程中遇到的问题及其解决方法"><a href="#博客制作过程中遇到的问题及其解决方法" class="headerlink" title="博客制作过程中遇到的问题及其解决方法"></a>博客制作过程中遇到的问题及其解决方法</h1><h2 id="问题1-Failed-to-connect-to-github-com-port-443-connection-timed-out"><a href="#问题1-Failed-to-connect-to-github-com-port-443-connection-timed-out" class="headerlink" title="问题1 Failed to connect to github.com port 443:connection timed out"></a>问题1 Failed to connect to github.com port 443:connection timed out</h2><p>这个问题可能是因为在本地使用了代理, 我们使用git取消代理一般就可以解决问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">取消全局代理：</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line"> </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="问题2-推送新文章到博客后还需要手动重新生成Github-pages"><a href="#问题2-推送新文章到博客后还需要手动重新生成Github-pages" class="headerlink" title="问题2 推送新文章到博客后还需要手动重新生成Github pages"></a>问题2 推送新文章到博客后还需要手动重新生成Github pages</h2><p>这个问题说小不小, 每当我们辛苦写完一篇博客文章后, 推送到github上, 万一忘记了重新部署Hexo静态页面. 我们写完的文章是不会出现在博客网页上的</p>
<p>这里的解决方案是使用Travis CI（持续集成）</p>
<p>Travis CI（持续集成）是一个在软件开发过程中提供自动化构建、测试和部署的在线平台。它与GitHub等代码托管服务紧密集成，可以轻松地为您的项目设置持续集成流程。</p>
<p>我们只需要以下步骤:</p>
<ul>
<li>配置文件：需要在项目的根目录下创建一个名为<code>.travis.yml</code>的配置文件，该文件用于定义构建和测试的步骤。</li>
<li>触发构建：每当您向代码库提交新的更改或推送到GitHub仓库时，Travis CI将自动检测到这些更改，并触发构建过程。</li>
</ul>
<p>因为Travis CI灵活的配置和能够自动化部署的特性, 我们只需要配置好Travis CI后直接push文章就可以了.</p>
<p>travis.yml内容如下:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># node版本</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 设置只监听哪个分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"><span class="comment"># 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">apt:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">yarn:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">theme</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="comment">#  配置git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;ZhangChunXian&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;1836891291@qq.com&quot;</span></span><br><span class="line">  <span class="comment"># 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">curl</span> <span class="string">-o-</span> <span class="string">-L</span> <span class="string">https://yarnpkg.com/install.sh</span> <span class="string">|</span> <span class="string">bash</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">PATH=$HOME/.yarn/bin:$PATH</span></span><br><span class="line">  <span class="comment"># npm模块安装</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">global</span> <span class="string">add</span> <span class="string">hexo-cli</span></span><br><span class="line">  <span class="comment"># - yarn remove hexo-renderer-marked</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-renderer-kramed</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-asset-image</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-searchdb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="comment">#- yarn add hexo-related-popular-posts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-symbols-count-time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-sitemap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-baidu-sitemap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-deployer-git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-helper-live2d</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">theme-next/next-util</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将 GitHub Token 替换到 next.yml 中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/REPO_TOKEN/$&#123;REPO_TOKEN&#125;/&quot;</span> <span class="string">source/_data/next.yml</span></span><br><span class="line">  <span class="comment"># next主题下载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/hexo-theme-next</span> <span class="string">themes/next</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">themes/next</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">v7.7.2</span> <span class="string">&amp;&amp;</span> <span class="string">cd</span> <span class="bullet">-</span></span><br><span class="line">  <span class="comment"># next主题依赖下载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/theme-next-pdf</span> <span class="string">themes/next/source/lib/pdf</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/theme-next-pace</span> <span class="string">themes/next/source/lib/pace</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="comment"># 不用yarn的话这里改成 npm i 即可</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="string">--config</span> <span class="string">source/_data/next.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">--config</span> <span class="string">source/_data/next.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">d</span> <span class="string">--config</span> <span class="string">source/_data/next.yml</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>校内课程</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
      </tags>
  </entry>
  <entry>
    <title>你好世界</title>
    <url>/posts/hello_world.html</url>
    <content><![CDATA[<p>more标签是分割线, 用来显示查看更多</p>
<span id="more"></span>

<hr>
<p><strong>Advertisement :)</strong></p>
<ul>
<li><strong><a href="https://nodeca.github.io/pica/demo/">pica</a></strong> - high quality and fast image<br>resize in browser.</li>
<li><strong><a href="https://github.com/nodeca/babelfish/">babelfish</a></strong> - developer friendly<br>i18n with plurals support and easy syntax.</li>
</ul>
<p>You will like those projects!</p>
<hr>
<h1 id="h1-Heading-8"><a href="#h1-Heading-8" class="headerlink" title="h1 Heading 8-)"></a>h1 Heading 8-)</h1><h2 id="h2-Heading"><a href="#h2-Heading" class="headerlink" title="h2 Heading"></a>h2 Heading</h2><h3 id="h3-Heading"><a href="#h3-Heading" class="headerlink" title="h3 Heading"></a>h3 Heading</h3><h4 id="h4-Heading"><a href="#h4-Heading" class="headerlink" title="h4 Heading"></a>h4 Heading</h4><h5 id="h5-Heading"><a href="#h5-Heading" class="headerlink" title="h5 Heading"></a>h5 Heading</h5><h6 id="h6-Heading"><a href="#h6-Heading" class="headerlink" title="h6 Heading"></a>h6 Heading</h6><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><hr>
<hr>
<hr>
<h2 id="Typographic-replacements"><a href="#Typographic-replacements" class="headerlink" title="Typographic replacements"></a>Typographic replacements</h2><p>Enable typographer option to see result.</p>
<p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p>
<p>test.. test… test….. test?….. test!….</p>
<p>!!!!!! ???? ,,  – —</p>
<p>“Smartypants, double quotes” and ‘single quotes’</p>
<h2 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h2><p><strong>This is bold text</strong></p>
<p><strong>This is bold text</strong></p>
<p><em>This is italic text</em></p>
<p><em>This is italic text</em></p>
<p><del>Strikethrough</del></p>
<h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><blockquote>
<p>Blockquotes can also be nested…</p>
<blockquote>
<p>…by using additional greater-than signs right next to each other…</p>
<blockquote>
<p>…or with spaces between arrows.</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>Unordered</p>
<ul>
<li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li>
<li>Sub-lists are made by indenting 2 spaces:<ul>
<li>Marker character change forces new list start:<ul>
<li>Ac tristique libero volutpat at</li>
</ul>
<ul>
<li>Facilisis in pretium nisl aliquet</li>
</ul>
<ul>
<li>Nulla volutpat aliquam velit</li>
</ul>
</li>
</ul>
</li>
<li>Very easy!</li>
</ul>
<p>Ordered</p>
<ol>
<li>Lorem ipsum dolor sit amet</li>
<li>Consectetur adipiscing elit</li>
<li>Integer molestie lorem at massa</li>
</ol>
<ol>
<li>You can use sequential numbers…</li>
<li>…or keep all the numbers as <code>1.</code></li>
</ol>
<p>Start numbering with offset:</p>
<ol start="57">
<li>foo</li>
<li>bar</li>
</ol>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Inline <code>code</code></p>
<p>Indented code</p>
<pre><code>// Some comments
line 1 of code
line 2 of code
line 3 of code
</code></pre>
<p>Block code “fences”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sample text here...</span><br></pre></td></tr></table></figure>

<p>Syntax highlighting</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params">bar</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> bar++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>path to data files to supply the data that will be passed into templates.</td>
</tr>
<tr>
<td>engine</td>
<td>engine to be used for processing templates. Handlebars is the default.</td>
</tr>
<tr>
<td>ext</td>
<td>extension to be used for dest files.</td>
</tr>
</tbody></table>
<p>Right aligned columns</p>
<table>
<thead>
<tr>
<th align="right">Option</th>
<th align="right">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="right">data</td>
<td align="right">path to data files to supply the data that will be passed into templates.</td>
</tr>
<tr>
<td align="right">engine</td>
<td align="right">engine to be used for processing templates. Handlebars is the default.</td>
</tr>
<tr>
<td align="right">ext</td>
<td align="right">extension to be used for dest files.</td>
</tr>
</tbody></table>
<h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p><a href="http://dev.nodeca.com/">link text</a></p>
<p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p>
<p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enable linkify to see)</p>
<h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><p><img data-src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img data-src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p>
<p>Like links, Images also have a footnote style syntax</p>
<p><img data-src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p>
<p>With a reference later in the document defining the URL location:</p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>.</p>
<h3 id="Emojies"><a href="#Emojies" class="headerlink" title="Emojies"></a><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><blockquote>
<p>Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:</p>
<p>Shortcuts (emoticons): :-) :-( 8-) ;)</p>
</blockquote>
<p>see <a href="https://github.com/markdown-it/markdown-it-emoji#change-output">how to change output</a> with twemoji.</p>
<h3 id="Subscript-Superscript"><a href="#Subscript-Superscript" class="headerlink" title="Subscript / Superscript"></a><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><ul>
<li>19^th^</li>
<li>H<del>2</del>O</li>
</ul>
<h3 id="lt-ins-gt"><a href="#lt-ins-gt" class="headerlink" title="&lt;ins&gt;"></a><a href="https://github.com/markdown-it/markdown-it-ins">&lt;ins&gt;</a></h3><p>++Inserted text++</p>
<h3 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="&lt;mark&gt;"></a><a href="https://github.com/markdown-it/markdown-it-mark">&lt;mark&gt;</a></h3><p>==Marked text==</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><p>Footnote 1 link[^first].</p>
<p>Footnote 2 link[^second].</p>
<p>Inline footnote^[Text of inline footnote] definition.</p>
<p>Duplicated footnote reference[^second].</p>
<p>[^first]: Footnote <strong>can have markup</strong></p>
<pre><code>and multiple paragraphs.
</code></pre>
<p>[^second]: Footnote text.</p>
<h3 id="Definition-lists"><a href="#Definition-lists" class="headerlink" title="Definition lists"></a><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><p>Term 1</p>
<p>:   Definition 1<br>with lazy continuation.</p>
<p>Term 2 with <em>inline markup</em></p>
<p>:   Definition 2</p>
<pre><code>    &#123; some code, part of Definition 2 &#125;

Third paragraph of definition 2.
</code></pre>
<p><em>Compact style:</em></p>
<p>Term 1<br>~ Definition 1</p>
<p>Term 2<br>~ Definition 2a<br>~ Definition 2b</p>
<h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><p>This is HTML abbreviation example.</p>
<p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p>
<p>*[HTML]: Hyper Text Markup Language</p>
<h3 id="Custom-containers"><a href="#Custom-containers" class="headerlink" title="Custom containers"></a><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p>
]]></content>
      <categories>
        <category>分类1</category>
      </categories>
      <tags>
        <tag>标签1</tag>
      </tags>
  </entry>
  <entry>
    <title>方法</title>
    <url>/posts/%E6%8F%92%E7%8F%AD%E7%94%9F%E8%80%83%E8%AF%95_%E6%96%B9%E6%B3%95_url.html</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><em><strong>为了更好的阅读，请注意本文结构的思维导图</strong></em><br><img data-src="/images/%E6%96%B9%E6%B3%95.png"><br>    <strong>前言：以下内容是针对华东师范大学理科专业插班生初试及其相近难度，请根据报考学校和专业的难度选择性阅读。</strong><br>    <strong>前言：以下内容是针对华东师范大学理科专业插班生初试及其相近难度，请根据报考学校和专业的难度选择性阅读。</strong><br>    <strong>前言：以下内容是针对华东师范大学理科专业插班生初试及其相近难度，请根据报考学校和专业的难度选择性阅读。</strong></p>
<span id="more"></span>

<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>因为插班生阶段英语的学习方法在以后的学习中还能用到，所以归到”学习方法“这个标签里了。</p>
<p><strong>笔者倾向于专门背诵词汇，在快速掌握了大量词汇后开始切入其他方面（华师插班生不考口语和听力，这两个方面我没有练习）。笔者也听说了一种在阅读中积累词汇的方法，但没有采用这个方法，也不做评论</strong></p>
<p>下方为链接。</p>
<h3 id="1-我的英语词汇背诵方法——利用anki实现快速记忆和有效复习"><a href="#1-我的英语词汇背诵方法——利用anki实现快速记忆和有效复习" class="headerlink" title="1.我的英语词汇背诵方法——利用anki实现快速记忆和有效复习"></a>1.我的英语词汇背诵方法——利用anki实现快速记忆和有效复习</h3><h3 id="2-英语词汇的深度学习——词汇除了释义还要掌握啥？"><a href="#2-英语词汇的深度学习——词汇除了释义还要掌握啥？" class="headerlink" title="2.英语词汇的深度学习——词汇除了释义还要掌握啥？"></a>2.英语词汇的深度学习——词汇除了释义还要掌握啥？</h3><h3 id="3-从零武装一本电子词典"><a href="#3-从零武装一本电子词典" class="headerlink" title="3.从零武装一本电子词典"></a>3.从零武装一本电子词典</h3><h2 id="下面这部分是针对插班生考试采用的方法"><a href="#下面这部分是针对插班生考试采用的方法" class="headerlink" title="下面这部分是针对插班生考试采用的方法"></a>下面这部分是针对插班生考试采用的方法</h2><h3 id="1-插班生英语什么时候该刷题？刷什么题？怎么刷？"><a href="#1-插班生英语什么时候该刷题？刷什么题？怎么刷？" class="headerlink" title="1.插班生英语什么时候该刷题？刷什么题？怎么刷？"></a>1.插班生英语什么时候该刷题？刷什么题？怎么刷？</h3><p>其实针对插班生英语的刷题，我没有自己独到的方法，那就把我自己的刷题安排作为参考。</p>
<p>我是在完全背熟考研单词后，大约在4月份，开始逐渐的刷题的。在此之前，为了训练自己的词汇，我做了两个月的四选一选择题练习，每天50道。</p>
<p>4月到5月，最开始我觉得时间来不及，所以从六级开始刷。每天4篇，30天左右做完了一半的六级真题。</p>
<p>5月到6月之后调转方向，开始做考研真题，也是每天4篇，一个卷子阅读的量，中间断断续续，一直有在做。其实一直到7月份初，我做完了近20年的考研真题。但也只做了一遍，做两遍我觉得不值得，已经知道答案了做起来就没有训练价值了。考研真题如果有说明不理解的地方，我选择去看唐迟老师的阅读课解决自己的疑惑。</p>
<p>6月就开始训练除阅读以外的其他题型，初作文外。从6月15号开始，一天的四篇阅读和其他题型组在一起，作为插班生英语的模拟卷。此外，我也花了一些时间熟悉了专四专八雅思的阅读，做了一些训练。最后的那几天，我一直在背作文（结果作文木有考）。</p>
<p>7月8日上正式考试，初始英语只有70分（我还是太菜了┭┮﹏┭┮）。初试压线飘过。</p>
<p>总的来说，我并没有刷很多题。我所有做的题目，都是真题。而且只做了一遍。在做完后，错误的地方我会尽力去找到原因并纠正，但是没有选择整篇翻译文章——我觉得耗时耗力效率低。</p>
<p><strong>如果刷题的话，请将真题放在优先位上。如果要刷考研真题，考研精品书籍课程众多，请善于利用资源</strong></p>
<p><strong>唐迟老师的话：没有一种阅读是脱离词汇基础的空中楼阁，要想阅读好，词汇必须一直背，一直积累，做到烂熟于心。词汇是阅读的基础，方法只是锦上添花</strong></p>
<ol>
<li>以上为个人学习方法，不是所有人都适合，请选择性吸收。</li>
<li>本人非专业英语学习者，方法有欠妥当的地方还请在评论区指出。</li>
</ol>
<h3 id="华师大2020插班生考试英语题型（初试）"><a href="#华师大2020插班生考试英语题型（初试）" class="headerlink" title="华师大2020插班生考试英语题型（初试）"></a>华师大2020插班生考试英语题型（初试）</h3><table>
<thead>
<tr>
<th>题型</th>
<th>分值（单体分数*题量）</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>单选题</td>
<td>1*20</td>
<td>部分涉及到语法，部分有托福词汇</td>
</tr>
<tr>
<td>语句选择题</td>
<td>2*5</td>
<td>设计到复杂句子语法，建议针对性训练</td>
</tr>
<tr>
<td>完形填空</td>
<td>2*15</td>
<td>考研难度</td>
</tr>
<tr>
<td>单段落阅读理解七篇</td>
<td>2*20</td>
<td>专四难度（专四有这个题型）</td>
</tr>
</tbody></table>
<p>2019年考察的选词填空，七选五，多段阅读等题型均未考察</p>
<p><strong>题型年年变化，仅供参考</strong></p>
<p><strong>题型年年变化，仅供参考</strong></p>
<p><strong>题型年年变化，仅供参考</strong></p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>因为插班生阶段数学的学习方法在以后的学习中还能用到，所以也归到”学习方法“这个标签里了。</p>
<h3 id="1-针对高数等板书多，节奏快，信息量大的课程，如何有效率的记笔记？"><a href="#1-针对高数等板书多，节奏快，信息量大的课程，如何有效率的记笔记？" class="headerlink" title="1. 针对高数等板书多，节奏快，信息量大的课程，如何有效率的记笔记？"></a>1. 针对高数等板书多，节奏快，信息量大的课程，如何有效率的记笔记？</h3><h3 id="2-利用Marginnote3做思维导图笔记"><a href="#2-利用Marginnote3做思维导图笔记" class="headerlink" title="2.利用Marginnote3做思维导图笔记"></a>2.利用Marginnote3做思维导图笔记</h3><h2 id="下面这部分是针对插班生考试采用的方法-1"><a href="#下面这部分是针对插班生考试采用的方法-1" class="headerlink" title="下面这部分是针对插班生考试采用的方法"></a>下面这部分是针对插班生考试采用的方法</h2><h3 id="1-考研难度数学部分的刷题"><a href="#1-考研难度数学部分的刷题" class="headerlink" title="1. 考研难度数学部分的刷题"></a>1. 考研难度数学部分的刷题</h3><p> 考研数学我全程看汤家凤老师的网课，网课从零基础，基础班译一直到强化班，辅导书只做了汤家凤高等数学辅导讲义一本，题典只做了汤家凤1800题高数部分。关于考研数学部分，我没有什么好的指导意见，大家可以选择一个合适并喜欢的老师，建议跟着老师从头学到尾，坚持到最后。</p>
<p>具体的时间分配是：</p>
<p>四月份开始听汤家凤的基础班网课（高数上册），做了1800题题典极限，导数，中值定理，积分和微分方程的基础部分。</p>
<p> 五月份一整个月在攻极限，导数，中值定理的强化课，同时做了1800题题典极限，导数，中值定理的强化部分。自己还有很多精力用在学校的课程上，应该是要线上考试了，又马不停蹄的赶校内的课。</p>
<p>六月在学校上网课的背景下，我看完了高数下册的基础班网课，完成了高数上册强化班的所有内容，题典下册部分每章执着了基础部分的一小半，加班加点肝完了题典高数上册的强化部分。最主要插班生考试官方通知已经出来了，所以六月临考前效率是最高的，不敢懈怠，也没心思摸鱼。</p>
<p> 结果最后华师高数考的大部分是高数下册的内容，如果我没有看下册网课必死无疑ε(┬┬﹏┬┬)3。下册因为题目练得少，手感不是很好，最后都是手抖着写完的。</p>
<img data-src="/images/18.png" style="zoom:33%;" />

<p><strong>汤家凤高等数学辅导讲义</strong></p>
<img data-src="/images/20.png" style="zoom: 33%;" />

<p><strong>汤家凤题典1800</strong></p>
<img data-src="/images/21.png" style="zoom:33%;" /> 

<h3 id="华师大2020插班生考试数学题型（初试）"><a href="#华师大2020插班生考试数学题型（初试）" class="headerlink" title="华师大2020插班生考试数学题型（初试）"></a>华师大2020插班生考试数学题型（初试）</h3><table>
<thead>
<tr>
<th>题型</th>
<th>分值（单题分数*题量）</th>
</tr>
</thead>
<tbody><tr>
<td>填空题</td>
<td>4*5（计算十分简单，但每道题都有陷阱）</td>
</tr>
<tr>
<td>计算题</td>
<td>大概50分，8题（高数课后习题难度）</td>
</tr>
<tr>
<td>证明题</td>
<td>大概30分，4题（高数课后习题难度）</td>
</tr>
<tr>
<td>今年华师一改往年以上册为主的基调，下册占据了大部分，难度大幅度下降。建议高数上下基础都要打牢。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>题型年年变化，仅供参考</strong></p>
<p> <strong>题型年年变化，仅供参考</strong></p>
<p> <strong>题型年年变化，仅供参考</strong></p>
<ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>插班生考试</category>
      </categories>
      <tags>
        <tag>插班生考试</tag>
      </tags>
  </entry>
  <entry>
    <title>算术逻辑单元-ALU</title>
    <url>/posts/%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83-ALU_url.html</url>
    <content><![CDATA[<h1 id="算术逻辑单元-ALU"><a href="#算术逻辑单元-ALU" class="headerlink" title="算术逻辑单元 - ALU"></a>算术逻辑单元 - ALU</h1><p>对数据的操作由计算机中的“算术逻辑单元”（arithmetic and logic unit）处理。ALU是计算机的数学大脑，是计算机中负责运算的组件，基本其他所有部件都用到了它。</p>
<p>ALU由两个单元，1个算术单元和1个逻辑单元。</p>
<p>算术单元（arithmetic unit）负责计算机中的所有数字操作，比如加减乘除，增量运算等 。</p>
<p>在算术单元可能会发生溢出现象。溢出（overflow）的意思是，两个数字的和太大了，超出了用来表示的位数，这会导致错误和不可预期的结果。 </p>
<p>逻辑单元（logic unit）执行逻辑操作，如AND，OR和NOT操作。它也能做简单的数值测试，比如检查一个数字是不是负数。</p>
<span id="more"></span>

<p><a href="https://www.bilibili.com/video/BV1EW411u7th?p=5">视频课程地址</a>，本文只是做简单记录，方便以后阅览（恶补计算机基础知识中）</p>
<p>视频中包含了大量的计算机硬件知识，因本人专业属于计算机软件范畴，故略过不做记录。感兴趣可以观看原视频。</p>
]]></content>
      <categories>
        <category>crash course</category>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>crash course</tag>
        <tag>计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始武装电子词典</title>
    <url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%AD%A6%E8%A3%85%E7%94%B5%E5%AD%90%E8%AF%8D%E5%85%B8_url.html</url>
    <content><![CDATA[<h1 id="公欲善其事-必先利其器——从零开始武装电子词典"><a href="#公欲善其事-必先利其器——从零开始武装电子词典" class="headerlink" title="公欲善其事,必先利其器——从零开始武装电子词典"></a>公欲善其事,必先利其器——从零开始武装电子词典</h1><p><em><strong>为了更好的阅读，请先收藏本文结构的思维导图</strong></em></p>
<p><img data-src="/images/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%AD%A6%E8%A3%85%E7%94%B5%E5%AD%90%E8%AF%8D%E5%85%B8.png"></p>
<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>好的英语学习者必备的一样利器,就是词典。遇到生词要查,遇到需要替换的表达要查,遇到熟词生义要查,在这样反复的查询中,词汇量就会显著增加,对英语的语感也会逐渐培养起来。</p>
<span id="more"></span>

<h1 id="话不多说，先展示一下我自己配置的电子词典"><a href="#话不多说，先展示一下我自己配置的电子词典" class="headerlink" title="话不多说，先展示一下我自己配置的电子词典"></a>话不多说，先展示一下我自己配置的电子词典</h1><img data-src="/images/词典.jpg" style="zoom: 25%;" />

<p> 自我感觉还阔以(‾◡◝)，也希望各位大佬评论给出一些意见，最近在纠结要不要加上英英字典=￣ω￣=</p>
<p> 所以这样一款颜值高，功能全的字典在哪里配置得到呢？</p>
<img data-src="/images/哪里能配置到.png" style="zoom:50%;" />

<p>下面就告诉你o(*≧▽≦)ツ</p>
<h1 id="所需软件：欧陆词典"><a href="#所需软件：欧陆词典" class="headerlink" title="所需软件：欧陆词典"></a>所需软件：欧陆词典</h1><img data-src="/images/欧陆词典.png" style="zoom: 33%;" />

<h2 id="关于欧陆词典的介绍请阅读下一个链接，这里不在赘述"><a href="#关于欧陆词典的介绍请阅读下一个链接，这里不在赘述" class="headerlink" title="关于欧陆词典的介绍请阅读下一个链接，这里不在赘述"></a>关于欧陆词典的介绍请阅读下一个链接，这里不在赘述</h2><p><a href="https://zhuanlan.zhihu.com/p/61088145">欧路词典－不仅仅是一个查词软件丨使用指南</a></p>
<h1 id="选择合适的mdd-mdx等字典资源"><a href="#选择合适的mdd-mdx等字典资源" class="headerlink" title="选择合适的mdd,mdx等字典资源"></a>选择合适的mdd,mdx等字典资源</h1><h2 id="如果你有足够兴趣，可以选择词典文件论坛来搜集到到需要的词典资源"><a href="#如果你有足够兴趣，可以选择词典文件论坛来搜集到到需要的词典资源" class="headerlink" title="如果你有足够兴趣，可以选择词典文件论坛来搜集到到需要的词典资源."></a>如果你有足够兴趣，可以选择<a href="https://www.pdawiki.com/forum/">词典文件论坛</a>来搜集到到需要的词典资源.</h2><h2 id="你也可以打包用我的词典文件，链接在下方自取。"><a href="#你也可以打包用我的词典文件，链接在下方自取。" class="headerlink" title="你也可以打包用我的词典文件，链接在下方自取。"></a>你也可以打包用我的词典文件，链接在下方自取。</h2><p><a href="https://pan.baidu.com/s/1yrH06yvpR9yD6mB62fWM7g">个人词典链接</a>    提取码：9hnt<br>        <a href="https://pan.baidu.com/s/1cEPdyDUBCqEcEWtCfJzKSg">备用词典链接</a>    提取码：92um</p>
<h2 id="词典介绍"><a href="#词典介绍" class="headerlink" title="词典介绍"></a>词典介绍</h2><h3 id="sound"><a href="#sound" class="headerlink" title="sound++"></a><strong>sound++</strong></h3><p>该字典可以查单词的各个形式（如过去式，过去分词等），和使用频率（如单词在COCA，经济学人中使用频率的排名）,以及单词所属的应试水平（4，6，研，八，托，雅，GRE等）。一般用来判断单词是否超纲及其重要程度。</p>
<p><img data-src="/images/sound++.png"></p>
<h3 id="优词词根"><a href="#优词词根" class="headerlink" title="优词词根"></a>优词词根</h3><p>该字典可以查询部分单词的词根，构词原理和变形。一般适合于用来快速记忆同根词。</p>
<p><strong>在未来英语学习中你可能会听说词根构词法，这个方法可以用来记忆一些复杂的单词</strong></p>
<p><img data-src="/images/%E4%BC%98%E8%AF%8D%E8%AF%8D%E6%A0%B9.png"></p>
<h3 id="释义比例词典（带词性）"><a href="#释义比例词典（带词性）" class="headerlink" title="释义比例词典（带词性）"></a>释义比例词典（带词性）</h3><p>当查到一些多义词时，该词典可以以百分比的形式归纳除词汇的主要释义及词性，帮助我们快速掌握词汇的主要释义。</p>
<p><img data-src="/images/%E9%87%8A%E4%B9%89%E6%AF%94%E4%BE%8B.png"></p>
<h3 id="朗文双解"><a href="#朗文双解" class="headerlink" title="朗文双解"></a>朗文双解</h3><p>《朗文双解》是为中等程度的英语学习者所打造，目的是帮助他们进一步巩固已有的英语基础，使他们对英语的各个方面有更深入的认识，从而提高他们理解及运用英语的能力。 该词典收词量丰富，例句大量选自英语语库资料，不但文字深入浅出，而且内容与我们的生活息息相关。</p>
<img data-src="/images/朗文.jpg" style="zoom:50%;" />

<h3 id="English词根词缀词频"><a href="#English词根词缀词频" class="headerlink" title="English词根词缀词频"></a>English词根词缀词频</h3><p>该词典以同根词的形式，列举出单词，以及他们的释义，词频率，构词法解释，可以用来更好的归纳与记忆同根词和词根。</p>
<img data-src="/images/English词根.png" style="zoom:50%;" />

<h3 id="有道词语辨析（同义词词典）"><a href="#有道词语辨析（同义词词典）" class="headerlink" title="有道词语辨析（同义词词典）"></a>有道词语辨析（同义词词典）</h3><p>该词典将意思相近的词归纳起来，并说明词汇之间的差别，适合于单词的深度学习。</p>
<img data-src="/images/有道辨析.png" style="zoom:50%;" />

<p> 以上就是我最常用的六个字典。还有其他好的词典等着各位探索呢ヾ(≧O≦)〃嗷~</p>
<h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><p><strong>PC段欧陆词典：1.按ctrl+F组合键搜索释义内的文字~</strong></p>
<p>​                            <em><em>2.将pdf导入到欧陆词典阅读，英语单词点击就可以查了奈ヾ(≧▽≦</em>)o</em>*</p>
<p><strong>移动版欧陆字典：1.在菜单里选择Search in the text搜索释义内的文字~</strong></p>
<p>​                               <em><em>2.将pdf导入到欧陆词典阅读，英语单词点击就可以查了奈ヾ(≧▽≦</em>)o</em>*</p>
<p> 最后不要忘了，将不熟悉的单词放进生词本哦！ヽ(✿ﾟ▽ﾟ)ノ</p>
<h1 id="欧陆词典其他软件配合"><a href="#欧陆词典其他软件配合" class="headerlink" title="欧陆词典其他软件配合"></a>欧陆词典其他软件配合</h1><h2 id="欧陆词典与anki"><a href="#欧陆词典与anki" class="headerlink" title="欧陆词典与anki"></a>欧陆词典与anki</h2><pre><code>不知道anki的小伙伴请移步下面的链接
</code></pre>
<p><a href="">2.我的英语词汇背诵方法——利用anki实现快速记忆和有效复习</a></p>
<p><strong>系统：Windows10 （OS X类似)</strong></p>
<h3 id="1-如何将欧陆词典中的生词导入到anki？"><a href="#1-如何将欧陆词典中的生词导入到anki？" class="headerlink" title="1.如何将欧陆词典中的生词导入到anki？"></a>1.如何将欧陆词典中的生词导入到anki？</h3><p>1.打开欧陆词典，选择工具-学习记录管理器</p>
<p><img data-src="/images/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E7%AE%A1%E7%90%86.jpg"></p>
<p>2.选中所需要生词所在的生词本，点击导出</p>
<img data-src="/images/导出.jpg" style="zoom: 67%;" />

<p>3.将导出格式设置为xml格式，导出项目更改为导出简明解释</p>
<img data-src="/images/导出2.png" style="zoom:67%;" />

<p>4.用excel打开导出的xml文件,在打开选项中选择打开方式为 As an Xml table</p>
<img data-src="/images/打开.jpg" style="zoom: 67%;" />

<img data-src="/images/openxml.png" style="zoom:67%;" />



<p>5.之后文件会以excel的形式打开，删除除单词外的所有列</p>
<img data-src="/images/1.png" style="zoom: 33%;" />

<img data-src="/images/2.png" style="zoom: 33%;" />

<p>6.将xml文件另存为txt（Tab delimited）格式</p>
<p><img data-src="/images/3.png"></p>
<p>7.打开anki桌面端，导入txt文件</p>
<p><img data-src="/images/4.png"></p>
<img data-src="/images/5.png" style="zoom:50%;" />

<p>8 <strong>请点击下方的链接，学习使用anki插件wordquery，实现模板化自动化制作记忆卡片</strong></p>
<p><strong><a href="https://www.bilibili.com/video/BV1qW411a7fZ">wordquery使用介绍</a></strong></p>
<p>下面是本人的牌组及其词典 文件</p>
<p><a href="https://pan.baidu.com/s/1G-dqCSTDKKF6-y4tHc5NhQ">牌组和词典文件</a>  提取码：d657</p>
<p>制作卡片可能需要的词表<br>        <a href="https://pan.baidu.com/s/1DVoMVxkbqiOk-33cz_UBCQ">词表</a>                     提取码：1234        </p>
<p>9 <strong>如果需要在移动端平台背诵，请申请ankiweb账号并保存移动端pc端在线，在任何系统中点击同步即可申请。</strong></p>
<p><strong>更多anki使用方法请点击下方的链接</strong>(待更新)</p>
<p>anki——记忆神器</p>
<ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>软件应用</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>软件应用</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语词汇的深度学习</title>
    <url>/posts/%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_url.html</url>
    <content><![CDATA[<p> <strong>本文结构的思维导图</strong></p>
<img data-src="/images/英语词汇的深度学习.png" style="zoom: 50%;" />

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知道你可有这样的经历</p>
<p> 废老大劲越过了abandon,滚瓜烂熟背完了一本词汇书</p>
<p>![]/images/36.jpeg)</p>
<p>信心慢慢的找阅读对线，结果。。。。</p>
<p>汉语我都知道，怎么这几个词加在一起我就解释不通了？啥？你这动词加个介词，这短语我能知道啥意思吗？哎，这单词跟我学的哪个哪个词好像，我知道哪个词，你加几个字母我怎么就不认得了？</p>
<p><img data-src="/images/38.jpg"></p>
<p> 一翻看答案</p>
<p> 这个词怎么是这个意思？我咋没背过？莫非我背了一本假词汇书？这两个搭配在一起意思咋还变了，说的倒是很有道理。这个词原来就是某某动词过去式啊？我乍得不晓得了？</p>
<p><img data-src="/images/39.jpg"></p>
<p>  你的词汇书大概率不会假。那究竟是什么原因呢？请看正文分解</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><span id="more"></span>

<h2 id="背景：越是高级别的英语考试，对词汇的要求就越高，不仅体会在词汇的数量要求上，还体现在词汇的深度要求上。如果是要准备一些较高级别的英语考试（考研托雅等）"><a href="#背景：越是高级别的英语考试，对词汇的要求就越高，不仅体会在词汇的数量要求上，还体现在词汇的深度要求上。如果是要准备一些较高级别的英语考试（考研托雅等）" class="headerlink" title="背景：越是高级别的英语考试，对词汇的要求就越高，不仅体会在词汇的数量要求上，还体现在词汇的深度要求上。如果是要准备一些较高级别的英语考试（考研托雅等）"></a>背景：越是高级别的英语考试，对词汇的要求就越高，不仅体会在词汇的数量要求上，还体现在词汇的深度要求上。如果是要准备一些较高级别的英语考试（考研托雅等）</h2><p> 一些重点词汇只学习中文释义是远远不够的！</p>
<p> 一些重点词汇只学习中文释义是远远不够的！</p>
<p> 一些重点词汇只学习中文释义是远远不够的！</p>
<h2 id="在词汇的深度学习开始之前，首先要搞清楚"><a href="#在词汇的深度学习开始之前，首先要搞清楚" class="headerlink" title="在词汇的深度学习开始之前，首先要搞清楚"></a>在词汇的深度学习开始之前，首先要搞清楚</h2><h3 id="哪些词汇要深度学习？"><a href="#哪些词汇要深度学习？" class="headerlink" title="哪些词汇要深度学习？"></a>哪些词汇要深度学习？</h3><p>首先，电子词典或者词汇书里往往会标明这个单词所属的层次（四级，六级，考研，专四，专八，托雅等），选择你对应层次的那些单词。</p>
<p>之后，电子词典和词汇书会有词汇的分级，一些词汇书还会将重要词汇集中收录，方便背诵。如我配置的单词词典中对每个单词都有星级的标注，从零颗星到五科星，代表着这个词汇的重要程度，星越多越重要。一般两星及两颗星以上的就是重点词汇。</p>
<img data-src="/images/sound++.png" style="zoom: 50%;" />

<p>最后，在阅读真题中反复出现的单词（一些资料有归纳）必然为重点词汇。</p>
<p><strong>不用担心工作量大，重点词汇占所有词汇中的比例不大，但却是考试常考的内容，是备考过程中性价比较高的选择，建议优先惠顾这些单词~</strong></p>
<p>将重点词汇收集了之后，首先是不论词性，都要搞定的内容</p>
<h3 id="构词法原理"><a href="#构词法原理" class="headerlink" title="构词法原理"></a>构词法原理</h3><p>英语单词构成有其规律，很好的掌握了构词规律，才可以很好、很快的、准确的记忆单词。英语单词<a href="https://baike.baidu.com/item/%E6%9E%84%E8%AF%8D%E6%B3%95/1351872">构词法</a>的核心部分，在于词根，词的意义主要是由组成单词的词根体现出来的。词根可以单独构成词，也可以彼此组合成词。                                                                                                                                 ——百度百科词根</p>
<p>词根类似于中文中的偏旁部首，赋予这个词汇一定的意义。我们可以通过词根推断未知单词的意思，也可以用来记忆单词。如-ful是常见的形容词词根，大部分时候带有ful结尾的单词我们就可以推断它为形容词。</p>
<p>你可能会说，那这有什么用呢？我不学词根就能知道了，这个ful的规律我早发现了。那就再举几个例子。</p>
<pre><code>form常见意思为形式，它可以作为词根，该词意思也是形式。
re- 常见词根 可表示1.再，第二次 2.return 转，回复  如review，再次看，意思为复习，revert, 回转，该词意思为恢复，复原（到原来的样子）
reform 就是再次形成新的形式，意思为改革，改造
formal -al为常见的形容词后缀，有形式的，意思为正式的
formalism -ism表示思想，主义，如Marxism表示马克思主义。该词意思为形式主义
formality -ty为名词后缀，真实的东西，该词意思为礼仪。
deform  de-表示破坏，同根词destroy，摧毁。该词意思为使变形，使残废。
</code></pre>
<p>此外，学词根并不会加重记忆负担,反而能提高英语学习的效率。常用的词根几十个，其构成的单词成千上万，都可以用词根进行记忆与背诵。</p>
<p><strong>并不是所有单词都可以用词汇都可以用词根理解</strong></p>
<p><strong>可以用词根理解的单词都可以在词根字典里找到很好的解释。如果没有词根解释那就是不能用构词法解释。</strong></p>
<img data-src="/images/English词根.png" style="zoom:50%;" />

<h3 id="多词性"><a href="#多词性" class="headerlink" title="多词性"></a>多词性</h3><p><strong>重要的单词，往往不止一种词性</strong></p>
<p>通常情况下，其中一种词性使用特别广泛，另一种词性无人问津。<strong>对于热门单词的冷门词性，还是需要好好记录的，因为很可能就是考试涉及到的考点。</strong></p>
<p>大部分情况下，每个词性之间意思相近，如名词动词化之后就是动词词性的意思。</p>
<p><strong>一些不同词性意思相差较大的就容易成为熟词新义等的考点</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">let 大部分时候作为动词，let sb do sth 使某人做某事</span><br><span class="line">但是作为名词时let意思为出租，租借</span><br><span class="line">a long-term let 长期出租</span><br></pre></td></tr></table></figure>

<img data-src="/images/40.png" style="zoom:50%;" />
在背单词的时候，可以留意这些冷门词性，一起背上也无妨o(*≧▽≦)ツ

<h3 id="熟词新义（熟词僻义）"><a href="#熟词新义（熟词僻义）" class="headerlink" title="熟词新义（熟词僻义）"></a>熟词新义（熟词僻义）</h3><p>相信大家高中就接触到这种现象，一些单词就是有着看似八竿子打不着的意思，考试还喜欢考。</p>
<p>在一些阅读材料中也会设置这些词汇，增加阅读的难度。</p>
<p>翻译就更不用说了，这些词汇必定是得分点。</p>
<pre><code> 举例子：
 subject(多次考到，超重点词汇)
 1.名词 主题，题目，话题
 2.名词 学科，科目
 （僻义）3.名词 实验对象，接受实验的生物
 The subjects of this experiment were men。
 (x)这个实验的主题是男性。
 (√)这个实验的对象为男性。
 4 动词动词动词 及物动词 使顺从，征服，使隶属
 5 形容词 受他国统治的
 subject peoples
 (x)主题人
 (√)被他国统治的民族
</code></pre>
<p>那怎么学习熟词新义呢？</p>
<p><strong>无他，平时背的时候要往下翻到底浏览一遍全部释义，留心并记忆</strong></p>
<p><strong>当然，肯定有人归纳过的，比如我，(●’◡’●)，</strong></p>
<p>有老师也归纳过的，某宝熟词辟义关键词就可以搜到了。我当初看的就是从某宝买的。</p>
<p><a href="https://pan.baidu.com/s/13nm92plP40A4ameZifk_5Q"><strong>个人定制英语词汇熟词新义</strong></a>    提取码：1234</p>
<h3 id="派生词"><a href="#派生词" class="headerlink" title="派生词"></a>派生词</h3><p>一个单词是孤立的，但加入各种词根词缀，进行变形，就会形成围绕着一个核心单词的词汇网络。</p>
<p>常见的，就是由一种词性衍生出其他词性，如从动词衍生出名词，形容词，副词。</p>
<p>同时，简单的变形就可以组合出不同词汇，这样做可以快速提升词汇量。</p>
<p>如form的词汇树</p>
<img data-src="/images/form.png" style="zoom:33%;" />



<p> 在这方面，很抱歉我没有找到好的字典资源，目前派生词做的比较好的是有道字典,建议派生词可以在有道字典内查询</p>
<img data-src="/images/41.png" style="zoom: 33%;" />

<h3 id="近义词及其辨析"><a href="#近义词及其辨析" class="headerlink" title="近义词及其辨析"></a>近义词及其辨析</h3><p><strong>近义词绝对是重点内容</strong>，因为有一个阅读几乎每个阶段都必玩的套路——<strong>同义改写</strong>，如果不熟悉常见近义词的化，一旦改写的词汇不理解，这个选项就是知识盲区了。</p>
<p>不过如果词汇量大的话，近义词就不用刻意去背了——因为都背过了。在阅读中同义改写也认得出来。唯一需要注意的就是写作了。<strong>写作考察主动词汇并非被动词汇</strong>，如果不专门积累一些写作的主动词汇的话，考试时很容易陷入一种虽然自己词汇量大，但是无好词可用的尴尬情况。<strong>高阶的考试，用低级词汇，低级表达就等于扣分。</strong></p>
<p>ps：</p>
<p>主动词汇:不仅能被动地用在听力和阅读当中， 而且能主动地用在口语和写作中的一些单词。</p>
<p>被动词汇：仅仅是在阅读和听力中能认出的单词，在口语和写作中不会主动应用。**</p>
<p><strong>词汇的辨析</strong></p>
<p>这个多是在完形填空里，一组选项意思相近，让你选择一个最合适的。这时候就要理解每个单词之间的不同及其语境。</p>
<p>比如下面这题（专四专八考察的四选一选择题）</p>
<p><img data-src="/images/42.png">、请问选择哪个呢？好像每种都是结果，后果的意思，差不多啊？怎么还能有对错呢？</p>
<p>四个单词的辨析图下</p>
<p><img data-src="/images/43.png"></p>
<p>本题选consequence的原因，最主要是因为结果是负面的，而consequence就有暗含负面结局的意思。</p>
<p>学习近义词辨析在这里推荐两本字典</p>
<p><strong>有道词语辨析字典</strong>，对于同意词的辨析，讲解的较为清楚，全部是中文，缺点是较难理解</p>
<p><strong>Collins COBUILD English Usage</strong>: 全英文字典，如果耐心阅读的话比有道字典更容易理解，缺点就是全英文，大部分人习惯中英字典的人会有些排斥。</p>
<p><a href="https://pan.baidu.com/s/1A1Y0lqgs_LJHlXKzJplMUQ"><strong>下载链接</strong></a>      提取码：1234</p>
<p><a href="https://pan.baidu.com/s/13uw2Ibpt_Zb5glbllmuEyA"><strong>本人自己收集的常见词语辨析</strong></a> 提取码：1234</p>
<h3 id="语境"><a href="#语境" class="headerlink" title="语境"></a>语境</h3><p>语境就是上下文环境了。阅读中常说到要根据上下文环境理解单词。在题目中也会有猜词题，考察考生对上下文的理解能力。</p>
<p>这里举几个方面</p>
<p><strong>注意词汇在不同背景下的意思</strong></p>
<pre><code>举例：
string 一般翻译为线，细绳，带子
但是如果在计算机背景的文章中，通常翻译为 ”字符串“
</code></pre>
<p><strong>注意词汇在英式和美式英语中的差别</strong></p>
<p>没错，英语是分国籍的，英式英语和美式英语大同小异，是有一些微小差异的，但是再微小的差异如果不知道的话，就容易闹笑话。</p>
<pre><code>讲个笑话：
高三一次英语考试，完形填空讲的是关于美国的”football“，我以为是足球，一开始还好，什么”backup&quot;,猜一猜就是后卫嘛，ballcarrier明显就是带球的队员，我还看到push，sb hit sb，huddle together（挤在一起）什么的，心想：美国人踢球这么暴力吗？还带推和撞，挤在一块是怎么回事？我还没看到corner（角球）怎么开局就挤在一起了？哎哎哎，这个地方咋回事？什么叫The ball is in my hand？手球了！！还说自己全力奔跑？小伙子你这么抗罚是要向全场球迷谢罪的。扔球是怎么回事？Throw是脚做的动作吗？还用手接？最后看到比分相差48的时候，我懵掉了，什么足球比赛比分这么大？大到离谱，莫不是国足打巴西？全程我是带着懵逼做完的。
经过跟同学的充分交流，我终于明白了，原来讲的是橄榄球！此时，我的心里
</code></pre>
<img data-src="/images/44.jpeg" style="zoom:50%;" />

<p>football在美式英语中指的是橄榄球！不是足球!soccer才是美式英语中的足球！</p>
<p><strong>这种知识吧，还是要靠积累，我觉得需要专门去看。</strong>字典什么的我也木有。贴一个知乎链接供参考。</p>
<p><a href="https://www.zhihu.com/question/19635660"><strong>英式英语和美式英语的不同</strong></a></p>
<h3 id="英英释义"><a href="#英英释义" class="headerlink" title="英英释义"></a>英英释义</h3><p>英文翻译成中文的过程总是会有意思上的偏差。正常情况下中文释义差强人意（这个成语什么意思全国卷考生别怪自己语文老师没说过）</p>
<p><strong>但总会有鸡贼的词中文释义与实际意义相差很大甚至截然相反。</strong></p>
<p><strong>这种词属于少数，见到一个就要记住一个！</strong></p>
<p>比如 <strong>instead</strong></p>
<pre><code>instead在单独使用时，朗文双解字典的中文释义为
“相反；而；却”
看中文意思的话instead是一个反义关联词。
NO!NO!NO!
仔细看instead的英英释义
used to say what is done,
when you huave just said that a particular thing is not done.
翻译过来是：instead这个词表示一个特定的事情没有做，另一个事情做了。
看到这时候还没明白？
例句1：
Geoff didn&#39;t study law. Instead, he decided to become an actor.
杰夫没学法律，相反，他决定当演员。
注意这句说中“没有学法律”与“当演员”是不冲突的，二者可以说是一种顺承关系。
例句2：
If Jo can&#39;t attend the meeting, I could go instead.
如果乔不能去开会，我可以代他去。
同理，这里的“乔不能去开会”和“我代他去”并不冲突，也是一种顺承关系。
总结：instead的用法
某人没有做某事。instead，某人可以去做某事（两件是不冲突）。instead可以理解是一种顺承关系

真正的相反关系：
It wasn&#39;t a good thing;On the contrary it was a huge mistake.
&quot;a good thing&quot;和&quot;a huge mistake&quot;意思产生冲突“
</code></pre>
<h2 id="动词篇——重点的动词这些方面要注意"><a href="#动词篇——重点的动词这些方面要注意" class="headerlink" title="动词篇——重点的动词这些方面要注意"></a>动词篇——重点的动词这些方面要注意</h2><h3 id="过去式与过去分词"><a href="#过去式与过去分词" class="headerlink" title="过去式与过去分词"></a>过去式与过去分词</h3><p>老老老重点了，不规则动词表背过木有？</p>
<p>不得不说，有些动词过去式变得亲妈都不认识，不背还真不会,写作要用到但是不会写过去式过去分词那不只能跳过吗？…..</p>
<p>记得高中有一次看到单词lit不认识，咋看咋迷糊，选项还出到这个了。后面一查是light的过去式。。。</p>
<p><a href="https://pan.baidu.com/s/1CkyLEXXHD6iAAi_sVFMmzA"><strong>不规则动词表</strong></a>   提取码：1234</p>
<p><img data-src="/images/45.png"></p>
<h3 id="及物与不及物"><a href="#及物与不及物" class="headerlink" title="及物与不及物"></a>及物与不及物</h3><p>及物动词：后面可以直接跟宾语</p>
<p>不及物动词：后面不能跟宾语。</p>
<p>有些单词及物与不及物的用法都有。</p>
<p><strong>重点关注不及物动词或者动词的不及物用法</strong>，及物用法不是重点。</p>
<p>因为从考试角度来说，出不及物动词往往既可以考察不及物动词的意思，还可以考察<strong>介词搭配</strong>。比如完形填空，选词填空中就会考察</p>
<p>通常为<strong>不及物动词+介词+宾语</strong></p>
<p>常见的就比如abandon之后的abide，adhere等（好多好多，要归纳的）</p>
<p><img data-src="/images/abide.png"></p>
<p><img data-src="/images/adhere.png"></p>
<p><a href="https://pan.baidu.com/s/1Tx6rNw3NspNEAmwSlzN-8Q"><strong>本人搜集的常见不及物动词，介词用法归纳</strong></a>  提取码：1234</p>
<h2 id="形容词篇——重点的动词这些方面要注意"><a href="#形容词篇——重点的动词这些方面要注意" class="headerlink" title="形容词篇——重点的动词这些方面要注意"></a>形容词篇——重点的动词这些方面要注意</h2><h3 id="1-修饰的对象不同，形容词的意思也不同"><a href="#1-修饰的对象不同，形容词的意思也不同" class="headerlink" title="1. 修饰的对象不同，形容词的意思也不同"></a>1. 修饰的对象不同，形容词的意思也不同</h3><p>形容词涉及到一词多义的，其具体意思由所修饰的事物决定。而不是统一的我们最熟悉的意思</p>
<p>在这里，我想举一个例子，仅仅<em><strong>从语言角度解释，不在其他方面做任何评论</strong></em></p>
<p><strong>sweet air意思真的是香甜的空气吗？</strong></p>
<p>几年欠，一位美国留学生在毕业典礼上发表的话，引起了轩然大波。其实一句是：</p>
<img data-src="/images/47.jpg" style="zoom:50%;" />

<p>当sweet修饰空气时，真的是甜美吗？</p>
<p>luxurious只有奢侈的意思吗？</p>
<p><strong>当然不是！</strong></p>
<p><strong>当sweet修饰空气时，意为新鲜的，纯净的</strong></p>
<p><img data-src="/images/sweet.png"></p>
<p><strong>luxurious中有舒适的意思</strong></p>
<img data-src="/images/luxurious.png" style="zoom: 25%;" />

<p><strong>香甜奢侈的空气，这个中文翻译是错误的！</strong>正确的翻译为：<strong>新鲜的，令人舒适的空气</strong></p>
<p><strong>不要说什么表达意思差不多，大差不差的，没必要纠结</strong></p>
<p><strong>考试要的是精准，翻译从来就没有“意思差不多就对了”，不精准就没分</strong></p>
<p>对象不同，形容词表达的意思也就有所不同。一般来说，在字典一个形容词释义就会说明他修饰的对象</p>
<p>如<strong>rich</strong>这个单词不仅表达富裕，其所包含的意思也很“富裕”</p>
<img data-src="/images/rich.png" style="zoom:25%;" />

<h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><h3 id="注意副词表达的程度"><a href="#注意副词表达的程度" class="headerlink" title="注意副词表达的程度"></a>注意副词表达的程度</h3><p>在阅读理解中，会有一些副词，<strong>特别是程度副词</strong>，出题人会在程度副词上下功夫，如添加完全程度的副词使一个选项变得太过绝对等。</p>
<pre><code>▲副词充当形容词/副词短语内的程度修饰语（degree modifier）：
1.带 -ly 后缀的程度副词
absolutely, amazingly, awfully, barely, completely, considerably, dreadfully, easily, enormously, entirely, exceedingly, excessively, extensively, extremely, fairly, fantastically, fully, greatly, hardly, highly, hugely, immensely, incredibly, infinitely, intensely, largely, moderately, nearly, noticeably, partly, perfectly, positively, practically, profoundly, purely, really, reasonably, relatively, remarkably, simply, slightly, strikingly, strongly, sufficiently, supremely, suspiciously, terribly, totally, tremendously, truly, unbelievably, utterly, virtually, wonderfully
2.不带 -ly 后缀的程度副词
about, almost, altogether, as, bloddy, damn, dead, downright, even, extra, far, how, however, indeed, jolly, just, least, less, mighty, more, most, not, outright, plain, pretty, quite, rather, real, so, somewhat, still, too, very, way, well, yet
</code></pre>
<p><strong>里面的单词不用专门记忆，平时背诵就可以了，在考试中特别是阅读理解中要特别注意</strong></p>
<h2 id="短语——常被忽视的重点"><a href="#短语——常被忽视的重点" class="headerlink" title="短语——常被忽视的重点"></a>短语——常被忽视的重点</h2><p><strong>正在总结和制作资源，未完待续</strong></p>
<p><strong>动词的主体性和客体性</strong>    待更新</p>
<p><strong>动词的主动与被动</strong>            待更新</p>
<ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>记笔记的高效姿势自学篇——思维导图笔记</title>
    <url>/posts/%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E9%AB%98%E6%95%88%E5%A7%BF%E5%8A%BF%E8%87%AA%E5%AD%A6%E7%AF%87_%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0_url.html</url>
    <content><![CDATA[<p><em><strong>为了更好的阅读，请先收藏本文结构的思维导图</strong></em></p>
<p><img data-src="/images/%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E9%AB%98%E6%95%88%E5%A7%BF%E5%8A%BF%E8%87%AA%E5%AD%A6%E7%AF%87%E2%80%94%E2%80%94%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0.png"></p>
<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p> 过度摸鱼以后，头脑迷糊,考试不振，感觉绩点被掏空。</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets/2.png" alt="2" style="zoom:25%;" />

<p> 怕再也不能给自己稳稳过线的幸福。</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets/3.png" alt="3" style="zoom:33%;" />

<p> 是不是应该自学了？鲁迅有云:”大学，大学，就是大不了自己学“。嗯，绩点好你也好</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets/1.jpg" alt="1" style="zoom:50%;" />

<p> 相比于传统的课堂教学，自学主要有两种方式</p>
<ol>
<li>网课</li>
</ol>
<p>常见的平台如中国哔哩哔哩大学</p>
<p><img data-src="/%5Cimages%5C%E5%88%A9%E7%94%A8marginnote3%E5%81%9A%E8%84%91%E5%9B%BE%E7%AC%94%E8%AE%B0.assets%5C5.png" alt="Bilibili大学开学啦！！！_封面"></p>
<p>学不通，智障树等网络教学平台</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets\unnamed.jpg" alt="unnamed" style="zoom: 50%;" />

<ol start="2">
<li>书本</li>
</ol>
<p><img data-src="/%5Cimages%5C%E5%88%A9%E7%94%A8marginnote3%E5%81%9A%E8%84%91%E5%9B%BE%E7%AC%94%E8%AE%B0.assets%5C6.png" alt="641"></p>
<p> 那没有了老师工整的板书和大佬们的笔记copy，如何将书本和网课中的知识整合起来呢?</p>
<h2 id="可以利用思维导图呀！o-≧▽≦-ツ"><a href="#可以利用思维导图呀！o-≧▽≦-ツ" class="headerlink" title="可以利用思维导图呀！o(*≧▽≦)ツ"></a>可以利用思维导图呀！o(*≧▽≦)ツ</h2><span id="more"></span>

<h1 id="首先介绍一下思维导图"><a href="#首先介绍一下思维导图" class="headerlink" title="首先介绍一下思维导图"></a>首先介绍一下思维导图</h1><p>思维导图，英文是The Mind Map，又叫心智导图，是表达发散性思维的有效图形思维工具 ，它简单却又很有效，是一种实用性的思维工具。</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets\7.png" alt="siweidaotuyongtu" style="zoom: 50%;" />

<p>它将知识的层层结构，以图像化的方式表达直观的表达出来。相对于文字来说，思维导图更符合发散思维——一个主题发散出无数的知识网络。</p>
<h1 id="2-思维导图要手画吗？NO-用软件"><a href="#2-思维导图要手画吗？NO-用软件" class="headerlink" title="2. 思维导图要手画吗？NO! 用软件"></a>2. 思维导图要手画吗？NO! 用软件</h1><p>0202年了，还在想着尝试做那些手杖博主们细心打磨的手绘思维导图吗？除非作为爱好，不然快节奏的学习环境不允许我们手绘思维导图。<br><img data-src="\images\利用marginnote3做脑图笔记.assets\siweidaotuyingyon.png" alt="siweidaotuyingyon" style="zoom: 50%;" /></p>
<p><strong>绘制思维导图的软件比比皆是。</strong>复杂的排版，颜色，布局，皆可由电子设备操作。</p>
<p><img data-src="/%5Cimages%5C%E5%88%A9%E7%94%A8marginnote3%E5%81%9A%E8%84%91%E5%9B%BE%E7%AC%94%E8%AE%B0.assets%5C8.jpg" alt="v2-46c581fb2a7f6a904ebcc917eca28dd9_720w"></p>
<p>这么多思维导图软件，刚上手的话可能不知道如何选择。</p>
<p>这里给出两个建议   </p>
<h2 id="做读书笔记选择MarginNote3"><a href="#做读书笔记选择MarginNote3" class="headerlink" title="做读书笔记选择MarginNote3"></a>做读书笔记选择MarginNote3</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li><p>功能繁多，思维导图是功能之一，有笔记，阅读，记忆等模块和功能</p>
</li>
<li><p>可以直接以图片或文字摘录电子书到思维导图，方便快捷。</p>
</li>
<li><p>可以导入pdf，edub等电子书文件，操作丰富，尤其是OCR搜索，解决了搜索书本关键词的一大痛点！！！</p>
</li>
<li><p>导出格式丰富，可以导出docx，pdf，mindmanager，ithoughts，evernote，anki等格式或平台。</p>
<p>5.支持插件,插件功能实用且多样。如Deepl翻译插件，自动搜索插件。</p>
</li>
<li><p>内置浏览器，可直接搜索文字内容。</p>
</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li><p>只支持iOS和mac平台。</p>
</li>
<li><p>思维导图有时会出现延迟显示的问题。</p>
</li>
<li><p>功能繁多，熟练掌握需要较多的学习成本。</p>
</li>
</ol>
<p> 如本人的高等数学笔记全都是在MarginNote3中完成。</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets\IMG_1053.PNG" alt="IMG_1053" style="zoom:33%;" />
高等数学这一类课程，知识点较多较杂。比如曲线和曲面积分这一章，涉及到多种不同的积分，初学时就极容易搞混。

<p>采用摘录+整理的方式，将知识按照书本的脉络整理成思维导图。从视觉上看，高数书上大段的文字被切割成了一个一个小单位, 排列没有文字那样密密麻麻，更容易让人接受。从复习效果看，在脑图的标题中添加关键词就可以快速搜索到对应的卡片，搜索知识点变得高效。思维导图的井井有条使得繁杂的知识不容易混乱，思维都有条例。</p>
<p>奉上自制的MarginNote脑图文件（请用MarginNote3打开）</p>
<p> <strong><a href="">高等数学上下册完整思维导图</a></strong>  提取码：1234</p>
<h2 id="做知识梳理选择-XMind"><a href="#做知识梳理选择-XMind" class="headerlink" title="做知识梳理选择 XMind"></a>做知识梳理选择 XMind</h2><p> 如本人的博客构思在XMind中完成</p>
<img data-src="\images\利用marginnote3做脑图笔记.assets\英语词汇的深度学习.png" alt="英语词汇的深度学习" style="zoom: 33%;" />

<p>写博客前，我习惯于用思维导图构建出文章的基本结构。不需要大段的文字，只需要主旨就可以了。这些可以保证文章的条理性。</p>
<p>偶尔在灵感爆发的时候，在导图中添加几笔，也是很方便的事情。                                                                                                                                                        </p>
<h1 id="友情链接："><a href="#友情链接：" class="headerlink" title="友情链接："></a>友情链接：</h1><p> <a href="%5Bhttps://zcxblog.cn/posts/%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E9%AB%98%E6%95%88%E5%A7%BF%E5%8A%BF%E8%AF%BE%E5%A0%82%E7%AF%87_url.html%5D(https://zcxblog.cn/posts/%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E9%AB%98%E6%95%88%E5%A7%BF%E5%8A%BF%E8%AF%BE%E5%A0%82%E7%AF%87_url.html)">记笔记的高效姿势课堂篇</a></p>
<p> <a href="https://search.bilibili.com/all?keyword=marginnote3">学习神器——MarginNote3基础教程</a></p>
<p> <a href="https://space.bilibili.com/183940526">MarginNote官方哔哩哔哩</a></p>
<p> <a href="https://zhuanlan.zhihu.com/p/31757959"> Xmind官方教程</a></p>
<ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>软件应用</category>
        <category>效率</category>
      </categories>
      <tags>
        <tag>软件应用</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>记笔记的高效姿势课堂篇</title>
    <url>/posts/%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E9%AB%98%E6%95%88%E5%A7%BF%E5%8A%BF%E8%AF%BE%E5%A0%82%E7%AF%87_url.html</url>
    <content><![CDATA[<p><em><strong>为了更好的阅读，请先收藏本文结构的思维导图</strong></em></p>
<p><img data-src="/images/%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E9%AB%98%E6%95%88%E5%A7%BF%E5%8A%BF%E8%AF%BE%E5%A0%82%E7%AF%87.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知道各位上课可有这样的烦恼</p>
<p> 老师写板书写的飞快</p>
<p><img data-src="/images/%E8%80%81%E5%B8%88%E6%9D%BF%E4%B9%A6.gif"></p>
<p> 自己抄也抄不过来，听也听不过来</p>
<img data-src="/images/记笔记.gif" style="zoom: 80%;" />

<p>拍照呢？不行不行，手机那么小屏幕，你让我眼睛看瞎啊</p>
<p><img data-src="/images/22.jpg"></p>
<p>下面我将介绍一下我自己关于记笔记的观点和方法。保证<strong>高效轻松</strong>哈哈哈</p>
<span id="more"></span>

<h1 id="在上课打开笔记本之前，请思考两个问题"><a href="#在上课打开笔记本之前，请思考两个问题" class="headerlink" title="在上课打开笔记本之前，请思考两个问题"></a>在上课打开笔记本之前，请思考两个问题</h1><h2 id="1-你这门课需要记笔记吗？"><a href="#1-你这门课需要记笔记吗？" class="headerlink" title="1.你这门课需要记笔记吗？"></a>1.你这门课需要记笔记吗？</h2><p> 有些课确实不需要笔记，这样就不要再费力气折腾了。</p>
<p> 有些课虽然需要记笔记，但是老师会讲义，ppt等发给你，那也别记了，课后直接看板书吧，把老师没有讲到的记一记就好。</p>
<p> 实在需要自己笔记的课程，干嘛非要自己动手（/手动滑稽）。课后找笔记记得好的同学py交易之后拿来不行吗？鲁迅都曰：“我们要运用脑髓，放出眼光，自己来拿！”</p>
<img data-src="/images/鲁迅.png" style="zoom:25%;" />

<p> 不记笔记，自然就没有关于笔记的问题了<img data-src="/images/23.png" style="zoom:25%;" /></p>
<h2 id="2-请问记完笔记，或者是借别人的笔记，会看吗？"><a href="#2-请问记完笔记，或者是借别人的笔记，会看吗？" class="headerlink" title="2. 请问记完笔记，或者是借别人的笔记，会看吗？"></a>2. 请问记完笔记，或者是借别人的笔记，会看吗？</h2><p> 就比如我吧，大部分时候肯定是不看的，所以大部分时候我就不做了。不图那点心里安慰。</p>
<p> 确认自己不看笔记就不要瞎折腾了。</p>
<p>  以上两点解决清楚，能避免很多的无用功。记得我大学高数老师多次痛心疾首地对我们说道：“你们能不能不要埋头记笔记了？这些内容很多书上就有。数学重要的是思想，是你们听我讲述原理，打通知识体系，听课是关键，笔记找同学借不就行了？”（大致原话）</p>
<h1 id="如果你必须要自己记笔记了"><a href="#如果你必须要自己记笔记了" class="headerlink" title="如果你必须要自己记笔记了"></a>如果你必须要自己记笔记了</h1><h2 id="1-记笔记还要全部都记吗？-NO"><a href="#1-记笔记还要全部都记吗？-NO" class="headerlink" title="1. 记笔记还要全部都记吗？ NO!"></a>1. 记笔记还要全部都记吗？ NO!</h2><p>一些书上，讲义上，PPT上你明知道都有的内容，就不要记了。不要假用功感动自己了，记点有用的，ok？</p>
<p><img data-src="/images/24.jpeg"></p>
<h1 id="信息化时代，不妨尝试下这个——电子笔记"><a href="#信息化时代，不妨尝试下这个——电子笔记" class="headerlink" title="信息化时代，不妨尝试下这个——电子笔记"></a>信息化时代，不妨尝试下这个——电子笔记</h1><p><strong>以下为本人偏好，可自行决定是否采纳</strong><br>       <strong>以下为本人偏好，可自行决定是否采纳</strong><br>       <strong>以下为本人偏好，可自行决定是否采纳</strong></p>
<img data-src="/images/25.jpg" style="zoom: 67%;" />

<h2 id="以下为iPad-iOS系统和iPad-OS系统-为例"><a href="#以下为iPad-iOS系统和iPad-OS系统-为例" class="headerlink" title="以下为iPad(iOS系统和iPad OS系统)为例"></a><strong>以下为iPad(iOS系统和iPad OS系统)为例</strong></h2><p> 1.当老师在黑板上开启狂飙模式时</p>
<p>不如把黑板拍下来！</p>
<p> 拍照时</p>
<img data-src="/images/26.jpg" style="zoom:50%;" />



<p> 处理后</p>
<img data-src="/images/27.jpg" style="zoom:33%;" />

<p> 拍的很“正”有木有<img data-src="/images/23.png" style="zoom:25%;" /></p>
<h2 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h2><ol>
<li>App store中下载OneNote，任君白嫖</li>
</ol>
<img data-src="/images/29.jpeg" style="zoom:25%;" />

<img data-src="/images/31.PNG" style="zoom:25%;" />

<ol start="2">
<li>打开app，创建笔记本，笔记</li>
</ol>
<p> OneNote独有的笔记分区如图所示</p>
<img data-src="/images/32.PNG" style="zoom:25%;" />

<ol start="3">
<li>选择 insert菜单 ，点击空白处，之后点击camera，</li>
</ol>
<img data-src="/images/33.png" style="zoom:33%;" />

<ol start="4">
<li>在camera中选择document模式，注意矩形框，矩形框范围合适后点击拍照</li>
</ol>
<img data-src="/images/34.png" style="zoom: 33%;" />

<p> 最终效果</p>
<img data-src="/images/28.gif" style="zoom:67%;" />

<p> 上课摸鱼成果</p>
<img data-src="/images/35.png" style="zoom: 33%;" />

<p> 你上课要做的，就是老师写完一个黑板后拍下板书和记下一些重点。</p>
<p>除此之外，请放心上课摸鱼吧～(￣▽￣～)(～￣▽￣)～</p>
<h2 id="友情提醒："><a href="#友情提醒：" class="headerlink" title="友情提醒："></a>友情提醒：</h2><p>安卓系统中的OneNote同样具备上述功能。</p>
<h1 id="友情链接："><a href="#友情链接：" class="headerlink" title="友情链接："></a>友情链接：</h1><p> 记笔记的正确姿势自学篇——思维导图笔记</p>
<ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>软件应用</category>
        <category>效率</category>
      </categories>
      <tags>
        <tag>软件应用</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>贪吃蛇 —— Python 小项目实战</title>
    <url>/posts/python%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98_%E8%B4%AA%E5%90%83%E8%9B%87.url.html</url>
    <content><![CDATA[<h1 id="贪吃蛇-——-Python-小项目实战"><a href="#贪吃蛇-——-Python-小项目实战" class="headerlink" title="贪吃蛇 —— Python 小项目实战"></a>贪吃蛇 —— Python 小项目实战</h1><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>在知乎上听大牛说编程直接上项目就是干，以项目为导向，以开发为目标，效果非常好。正巧最近想学python，故尝试以零基础做小项目，疑难部分通过谷歌和书本解决，并通过发表博文检验和锤炼学习成果。</p>
<p>本文结构的思维导图：</p>
<p><img data-src="/images/Snake/1.png"></p>
<span id="more"></span>

<h1 id="导入贪吃蛇小游戏所需要的库和模块"><a href="#导入贪吃蛇小游戏所需要的库和模块" class="headerlink" title="导入贪吃蛇小游戏所需要的库和模块"></a>导入贪吃蛇小游戏所需要的库和模块</h1><h2 id="python导入库和模块"><a href="#python导入库和模块" class="headerlink" title="python导入库和模块"></a>python导入库和模块</h2><p>使用python进行编程时，有些功能无法用原生python实现。这时需要导入一些python库或者模块，这类似于在Windows操作系统为了实现操作系统没有的功能而去install相应的软件。</p>
<p>导出的基本语法为</p>
<p><code>import Modulename</code></p>
<p>Module 模块</p>
<p>或</p>
<p><code>import Modulename as Modulename_Aliases</code></p>
<p>Alias 别名</p>
<p>如常用的</p>
<p><code>import pandas</code></p>
<p><code>import pandas as np</code></p>
<p>当有多个库或模块时，也可以写到一句中，用逗号隔开</p>
<p><code>import Module1, Module2, Module3</code></p>
<h2 id="导入需要的库"><a href="#导入需要的库" class="headerlink" title="导入需要的库"></a>导入需要的库</h2><ul>
<li><p>pygame</p>
<p><code>pygame</code>库是一个免费开源的<code>python</code>库，一个利用SDL库的写就的游戏库。</p>
</li>
<li><p>sys</p>
<p><code>sys</code>是一个<code>python</code>标准模块，提供了一些变量和函数。（在该程序中可加可不加）</p>
</li>
</ul>
<ul>
<li> random</li>
</ul>
<p>  <code>random</code>属于<code>python</code>标准库中的数学和数字模块，作用是生成随机数。在贪吃蛇中，食物出现的位置时随机的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure>
<p>或者是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame, sys, random</span><br></pre></td></tr></table></figure>

<h1 id="设定贪吃蛇游戏界面的大小"><a href="#设定贪吃蛇游戏界面的大小" class="headerlink" title="设定贪吃蛇游戏界面的大小"></a>设定贪吃蛇游戏界面的大小</h1><h2 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h2><p>程序中如果有常量，如恒定的数等。可以在开头全局定义。</p>
<p>语法格式为</p>
<p><code>name = value</code></p>
<p>value 值</p>
<p><strong>贪吃蛇游戏中，游戏界面的长和宽是不会变化的，是恒定的值</strong></p>
<h2 id="设定贪吃蛇游戏界面的大小-1"><a href="#设定贪吃蛇游戏界面的大小-1" class="headerlink" title="设定贪吃蛇游戏界面的大小"></a>设定贪吃蛇游戏界面的大小</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局定义游戏界面的长和宽（单位为分辨率）</span></span><br><span class="line">SCREEN_X = <span class="number">600</span>                                     <span class="comment"># 全局定义游戏界面的长</span></span><br><span class="line">SCREEN_Y = <span class="number">600</span>                                     <span class="comment"># 全局定义游戏界面的宽</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个函数main()作为主函数 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>()：                                       <span class="comment"># 创建一个名为main的主函数</span></span><br><span class="line">    pygame.init()                                  <span class="comment">#1 初始化pygame模块，确保pygame模块完整可用</span></span><br><span class="line">    screen_size = (SCREEN_X,SCREEN_Y)</span><br><span class="line">    screen = pygame.display.set_mode(screen_size)  <span class="comment">#2 设定游戏窗口的大小（单位：分辨率）</span></span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;Snake&#x27;</span>)            <span class="comment">#3 设定游戏窗口的标题为“Snake”</span></span><br><span class="line">    screen.fill((<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>))                        <span class="comment"># 设定屏幕颜色（RGB）</span></span><br><span class="line">main()                                             <span class="comment"># 运行主函数</span></span><br></pre></td></tr></table></figure>

<p><strong>批注</strong>：在Python中，我们用缩进来表示不同代码之间的关系。若要说明一段代码从属于另一端代码，则需要通过缩进四个空格或一个<code>Tab</code>键来表示。不缩进的代码段之间为同级关系。Python中正确的运用缩进不仅能使程序顺利运行，还可以增强代码的可读性。</p>
<p>#1 我们已经知道python有一个特殊的“库（模块）”叫pygame了。在我们要动手用它完成我们的想法之前，电脑这个强迫症需要我们检查一遍，这个工具包是否完整，能否正常给我们提供帮助。而这个检查的动作，就是<code>pygame.init()</code>。</p>
<p>#2 <strong>pygame.display.set_mode(resolution=(SCREEN_X,SCREEN_Y))</strong></p>
<p>初始化一个准备显示的窗口或屏幕。</p>
<p>#3 <strong>pygame.display.set_caption(‘title’)</strong></p>
<p>设置当前游戏窗口的标题</p>
<p>当设置完成后，运行代码就可以看到一个“一闪而过”的游戏窗口了</p>
<img data-src="/images\Snake\snake_screen.gif" style="zoom:25%;" />

<h1 id="用类创建一个“贪吃蛇”模板"><a href="#用类创建一个“贪吃蛇”模板" class="headerlink" title="用类创建一个“贪吃蛇”模板"></a>用类创建一个“贪吃蛇”模板</h1><p>Python从问世之初就是一个可以面向对象的语言。在面向对象编程中，可以用类(class)表示现实世界的事物和情形。类(class)类似于现实世界中的模板。当创建了类后，你定义了整个对象类别可以有的一般行为和特征。</p>
<p>如在贪吃蛇游戏中，我需要定义一个贪吃蛇的类，在其中定义一般贪吃蛇所具有的行为和特征。当用贪吃蛇的类创建一个独立的对象——一条贪吃蛇，就等于把这个类<strong>实例化(instantiation)<strong>。该条贪吃蛇就可以一个</strong>实例(instance)。</strong></p>
<p>在python中创建一个类的基本语法为(在Python中以下三者等价):</p>
<p><code>class ClassName:</code></p>
<p><code>class ClassName():</code></p>
<p><code>class ClassName(object):</code></p>
<h2 id="创建一个贪吃蛇的类，并初始化个各种需要的属性"><a href="#创建一个贪吃蛇的类，并初始化个各种需要的属性" class="headerlink" title="创建一个贪吃蛇的类，并初始化个各种需要的属性"></a>创建一个贪吃蛇的类，并初始化个各种需要的属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Python中类的名称一般首字母大写，与类的实例（全部小写）进行区分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span>:</span><br><span class="line">    <span class="comment"># 初始化各种需要的属性 [开始时默认向右/身体块x5]</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):                    <span class="comment">#4</span></span><br><span class="line">        self.dirction = pygame.K_RIGHT     <span class="comment">#5 设置贪吃蛇默认从右边开始运动，即按→方向键</span></span><br><span class="line">        self.body = []                     <span class="comment">#6 为实例创建一个名为body的空列表</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):                 <span class="comment">#7 将addnote()函数从0到4循环五次</span></span><br><span class="line">            self.addnode()                 <span class="comment">#8 初始设定贪吃蛇有5个蛇块</span></span><br></pre></td></tr></table></figure>


<p><strong>类中的函数在Python中叫做方法（method）。</strong>在类中的方法具有函数的一切特征，也有一些区别。</p>
<p>创建函数的一般语法为</p>
<p><code>def funcitonname(parameter1, parameter2, ...):</code></p>
<p>parameter 参数</p>
<p>#4处的<code>__init__</code>是一类特殊的函数。当我们根据类创建了一个实例时，Python会<strong>自动调用<code>__init__</code>函数。</strong> <strong>在Python中的每个类中都必须要有<code>__init__</code>函数。</strong></p>
<p>#4处定义的<code>__init__</code>函数一个参数<code>self</code>。**<code>self</code>参数在每一个类的每一个方法里都是必须的，而且顺序必须是第一个。**因为当我们根据类创建实例后，每一个与实例相关联的方法的调用会自动传递<code>self</code>参数，<code>self</code>是对实例本身的引用，它可以让各个实例可以访问类中的属性。在我们创建的<code>__init__</code>函数中，不需要其他参数，所以只需要<code>self</code>一个必须参数就可以了。</p>
<p>#5处的变量<code>self.dirction</code>带有<code>self</code>的前缀。在类中任何以self为前缀的变量都可以被类中的每个方法调用(因为每个方法中都有参数self)，我们也可以通过从类中创建的任何实例来访问这些变量。</p>
<p>#5处的<code>pygame.K_RIGHT</code>是Pygame库中的属性，作用是使创建的对象（在这里是贪吃蛇）向右运动，相当于键入→方向键。</p>
<p>同理 <code>pygame.K_UP</code>使创建的对象向上运动。</p>
<p>同理 <code>pygame.K_DOWN</code>使创建的对象向下运动。<br><strong>Pygame库中可以用字符常量表示输入键盘中的特定键位。</strong></p>
<table>
<thead>
<tr>
<th>Pygame Constant</th>
<th>The key in keyboard</th>
</tr>
</thead>
<tbody><tr>
<td>K_UP</td>
<td>up arrow</td>
</tr>
<tr>
<td>K_DOWN</td>
<td>down arrow</td>
</tr>
<tr>
<td>K_LEFT</td>
<td>left arrow</td>
</tr>
<tr>
<td>K_RIGHT</td>
<td>right arrow</td>
</tr>
<tr>
<td>K_SPACE</td>
<td>space</td>
</tr>
</tbody></table>
<p>#6处为self参数创建一个body的属性，body初始化为空列表，利用列表的可变性（列表中元素的值和数量都可以变化）存放蛇块。</p>
<p>#7&amp;#8处，为self参数创建一个addnote()的属性，用以增加蛇块的数量，初始化蛇块数量设定为5(可以根据个人喜好修改，但不宜过多)</p>
<h2 id="设定贪吃蛇移动时的蛇块变化"><a href="#设定贪吃蛇移动时的蛇块变化" class="headerlink" title="设定贪吃蛇移动时的蛇块变化"></a>设定贪吃蛇移动时的蛇块变化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无论何时 都在前端增加蛇块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnode</span>(<span class="params">self</span>):                                      <span class="comment">#9</span></span><br><span class="line"><span class="comment"># 设定贪吃蛇从屏幕的右上角开始出现</span></span><br><span class="line">    left,top = (<span class="number">0</span>,<span class="number">0</span>)                                    <span class="comment">#10                     </span></span><br><span class="line">    <span class="keyword">if</span> self.body:</span><br><span class="line">        left,top = (self.body[<span class="number">0</span>].left,self.body[<span class="number">0</span>].top) <span class="comment">#11</span></span><br><span class="line"><span class="comment"># 定义蛇在游戏开始时出现的位置，以及蛇的每一节身体的长宽（单位为分辨率）</span></span><br><span class="line">    node = pygame.Rect(left, top, <span class="number">25</span>, <span class="number">25</span>)               <span class="comment">#12                   </span></span><br><span class="line">    <span class="keyword">if</span> self.dirction == pygame.K_LEFT:                  <span class="comment">#13                    </span></span><br><span class="line">        node.left -= <span class="number">25</span></span><br><span class="line">    <span class="keyword">elif</span> self.dirction == pygame.K_RIGHT:               <span class="comment">#14</span></span><br><span class="line">        node.left += <span class="number">25</span></span><br><span class="line">    <span class="keyword">elif</span> self.dirction == pygame.K_UP:                  <span class="comment">#15</span></span><br><span class="line">        node.top -= <span class="number">25</span></span><br><span class="line">    <span class="keyword">elif</span> self.dirction == pygame.K_DOWN:                <span class="comment">#16</span></span><br><span class="line">        node.top += <span class="number">25</span></span><br><span class="line">    self.body.insert(<span class="number">0</span>,node)                            <span class="comment">#17</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 删除最后一个块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnode</span>(<span class="params">self</span>):                                      <span class="comment">#18</span></span><br><span class="line">    self.body.pop()                                     <span class="comment">#19</span></span><br></pre></td></tr></table></figure>

<p>#9 在这段代码中我们创建了addnode方法，该方法有且self这一个必须参数</p>
<p>#10 设定贪吃蛇的出现位置在最右上角。left, top在后文代表的意思可以用下面这张图片解释。</p>
<p><img data-src="/images/Snake/Pygame%E4%B8%ADrect%E5%87%BD%E6%95%B0.png"></p>
<p>#11处出现的rect函数中的left, top指的是矩形区域（白色部分）距离x轴和y轴的水平距离和垂直距离。</p>
<p><strong>Pygame 通过 Rect 对象存储和操作矩形区域，由pygame.Rect(left, top, width, height)命令创建。</strong></p>
<p>该一整段代码的运行流程：</p>
<img data-src="/images/Snake/def addnote().png" style="zoom: 200%;" />

<p>在<code>__init__</code>函数中有一个for循环，使addnote()方法按照该流程循环了5次。</p>
<p>第一次循环并没有执行<code>if self.body：</code>后的语句，因为我们最初定义的<code>self.body</code>是一个空列表。所以第一次循环首先执行<code>node = pygame.Rect(left, top, 25, 25)</code>。这时我们创建了一个在游戏界面最右上角，大小为25*25像素的矩形对象node。因为在<code>__init__</code>函数中我们<code>self.dirction = pygame.K_RIGHT</code>语句使对象向右移动，所以判定向右运动为真，node变量的left参数加25——即向右运动了25像素。这样实现了一个像素块向右的移动。最后的<code>self.body.insert(0,node)</code>命令在self.body列表的插入node变量，并将其放在第一位。</p>
<p>之后四次循环中，因为<code>self.body</code>列表不再是空列表，所以总是执行第一个if语句后的命令，将参数left，top赋值为<code>self.body</code>列表中的第一位，这样做，使得每次循环之初的node对象总是上一次循环得到的移动过后的像素块，并在此基础上根据运动方向再次移动——这样做实现 贪吃蛇身体的连续，使得贪吃蛇刚出来就是完整的五个25*25像素块</p>
<p>这样做是不够的，因为随着贪吃蛇的移动，是不断右像素块（图中绿色，颜色可自定义）产生和像素块的消失。在最后的像素块总是最先消失的。也就是<code>self.body[-1]</code>会随着每次移动而删去。</p>
<p>所以我们需要另外创建一个delnode函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delnode</span>(<span class="params">self</span>):</span><br><span class="line">self.body.pop()</span><br></pre></td></tr></table></figure>
<p>delnode方法同样仅有self这一必须参数，pop函数可以删去列表中的最后一个元素。</p>
<p>我们需要同时同刷新率运行addnode和delnode方法。这时，又需要创建一个方法<code>move</code>.在运行addnode增加蛇块的同时运行delnode减少蛇块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动！</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">    self.addnode()</span><br><span class="line">    self.delnode()</span><br></pre></td></tr></table></figure>



<p>那么，除非吃到食物（后面会设置），我们以类创建出来的贪吃蛇的蛇块增加速度等于删除速度，最后蛇的长度不变。又因为蛇块总是在动态变化，我们就用程序完成了蛇的移动。</p>
<p><strong>效果图</strong></p>
<img data-src="/images/Snake/2.gif" style="zoom:25%;" />



<h2 id="改变方向-但是左右、上下不能被逆向改变"><a href="#改变方向-但是左右、上下不能被逆向改变" class="headerlink" title="改变方向 但是左右、上下不能被逆向改变"></a>改变方向 但是左右、上下不能被逆向改变</h2><p>但这样是不够的。在经典的贪吃蛇游戏中，蛇是不能逆向运动的。我们需要在蛇左右或上下运动的同时对其运动方向做出限制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改变方向 但是左右、上下不能被逆向改变</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changedirection</span>(<span class="params">self,curkey</span>):                            <span class="comment">#20</span></span><br><span class="line">    LR = [pygame.K_LEFT,pygame.K_RIGHT]                      <span class="comment">#21</span></span><br><span class="line">    UD = [pygame.K_UP,pygame.K_DOWN]                          </span><br><span class="line">    <span class="keyword">if</span> curkey <span class="keyword">in</span> LR+UD:                                      <span class="comment">#22</span></span><br><span class="line">        <span class="keyword">if</span> (curkey <span class="keyword">in</span> LR) <span class="keyword">and</span> (self.dirction <span class="keyword">in</span> LR):         <span class="comment">#23</span></span><br><span class="line">            <span class="keyword">return</span> self.dirction                             <span class="comment">#24</span></span><br><span class="line">        <span class="keyword">if</span> (curkey <span class="keyword">in</span> UD) <span class="keyword">and</span> (self.dirction <span class="keyword">in</span> UD):       </span><br><span class="line">            <span class="keyword">return</span> self.dirction</span><br><span class="line">        self.dirction = curkey                               <span class="comment">#25</span></span><br></pre></td></tr></table></figure>

<p>我的方案是将左右运动和上下运动分开讨论，因为两者的情况是不一样。</p>
<p>在左右运动时，无论是按<strong>←</strong>还是→键，蛇总是按照原来的方向前进。左右运动时情况类似。</p>
<p>#21 我们分别创建LR和UD列表代表左右运动和上下运动。</p>
<p>#20 这时我们需要输入蛇当前的运动方向，所以在定义方法时在self参数后加了curkey参数。</p>
<p>#23&amp;#24 我们需要判定curkey是否与self.dirction都处于向左或向右运动方向上，如果为真，则返回self.dirction。后面的语句就不会执行了。</p>
<p>#25 若curkey与当前的self.dirction不冲突，则将curkey的值赋予self.dirction，这样贪吃蛇的方向就发生了改变。</p>
<h2 id="贪吃蛇的死亡判断"><a href="#贪吃蛇的死亡判断" class="headerlink" title="贪吃蛇的死亡判断"></a>贪吃蛇的死亡判断</h2><p>经典的贪吃蛇中有两种死亡方式，一是碰撞到墙壁（在这里我们用屏幕边界代替），而是头碰到自己的身体。这两者只要满足一个就可以判定为死亡。</p>
<p>这里先做一个简单的死亡判断函数，对死亡前后的各种对象的设置将会在<code>main</code>函数中进行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 死亡判断</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isdead</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 撞墙</span></span><br><span class="line">    <span class="keyword">if</span> self.body[<span class="number">0</span>].x  <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(SCREEN_X): <span class="comment"># 若蛇块不在屏幕范围内，判定死亡为真         </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> self.body[<span class="number">0</span>].y  <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(SCREEN_Y):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 撞自己</span></span><br><span class="line">    <span class="keyword">if</span> self.body[<span class="number">0</span>] <span class="keyword">in</span> self.body[<span class="number">1</span>:]:          <span class="comment"># 如果撞到自己，判定为死亡         </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>一开始，我们需要在主函数中初始化isdead方法为否，即</p>
<p><code>isdead = False</code></p>
<p><code>self.body</code>列表中存储着一些代表蛇块的矩形对象。当任何一个矩形对象超出屏幕范围内时，则返回isdead为真；或者，当代表蛇头的矩形对象(在<code>self.body</code>列表中总是第一个元素)的位置（left和top参数）包含于蛇身（<code>self.body[1:]</code>)时，则返回isdead为真。</p>
<p>当两个条件都不满足时，返回<code>isdead = False</code></p>
<h1 id="用类创建一个“食物”模板"><a href="#用类创建一个“食物”模板" class="headerlink" title="用类创建一个“食物”模板"></a>用类创建一个“食物”模板</h1><p>食物所具有的特征就贪吃蛇简单多了，我们需要创建关于食物的类，满足下列的要求：</p>
<p>1.食物出现的位置随机</p>
<p>2.食物被贪吃蛇碰到后会更换位置出现在界面上</p>
<p>3.食物的大小适中（在这里我们固定食物的大小为25*25像素，等于一个蛇块的大小）</p>
<h2 id="创建一个食物的类"><a href="#创建一个食物的类" class="headerlink" title="创建一个食物的类"></a>创建一个食物的类</h2><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):                                       </span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>,<span class="number">25</span>)                    <span class="comment"># rect对象是用来存储矩形对象的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self</span>):                                         <span class="comment"># 去除食物</span></span><br><span class="line">        self.rect.left=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self</span>):                                            <span class="comment"># 随机设置食物的出现地点</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.left == <span class="number">0</span>:</span><br><span class="line">            allpos = []                                       <span class="comment"># 26</span></span><br><span class="line">            <span class="comment"># 不靠墙太近 25 ~ SCREEN_X-25 之间fenb</span></span><br><span class="line">            <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>,SCREEN_X-<span class="number">25</span>,<span class="number">25</span>): </span><br><span class="line">  <span class="comment"># 将屏幕减小外围25分辨率后的所有位置（以25*25像素块为单位）都添加到allpos列表中</span></span><br><span class="line">                allpos.append(pos)</span><br><span class="line">            self.rect.left = random.choice(allpos)</span><br><span class="line">            self.rect.top  = random.choice(allpos)</span><br><span class="line">            <span class="built_in">print</span>(self.rect)</span><br></pre></td></tr></table></figure>

<p>我们需要一个刷新食物出现地点的判定标准，当类<code>Food</code>的实例被创建时，python会自动调用<code>__init__</code>函数，这时就应该自动刷新食物出现的地点。当食物被贪吃蛇吃掉时，也应该自动刷新食物出现的地点。</p>
<p>在这里我选择<code>self.rect.left == 0</code>为真，作为食物刷新的条件。所以在<code>__init__</code>方法中，我将0赋给了<code>self.rect.left</code>,并设定了食物的大小为25*25分辨率。</p>
<p>在remove方法中，我选择直接赋值，因为食物大小已经设置过了，不需要再次设置。</p>
<p>之后，很容易想到可以用random函数随机分配食物的位置。</p>
<p>这时可以选择先构建一个包含所有位置的库（为了降低游戏难度，删除了外围25分辨率），在用choice函数在位置库中随机选取。也可以直接在random函数中选构建所有位置的表达式后一步解决。这里选择较简单的前一种。</p>
<p><strong>#26</strong> 用for循环将除外围25分辨率的所有位置加入空列表allpos，再用random.choice()方法随机返回。<strong>choice()</strong> 方法返回一个列表，元组或字符串的随机项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice( seq  )</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>choice()是不能直接访问的，需要导入 random 模块，然后通过 random 静态对象调用该方法。</p>
<p> seq – 可以是一个列表，元组或字符串。</p>
<h1 id="实例化类Snack和类Food"><a href="#实例化类Snack和类Food" class="headerlink" title="实例化类Snack和类Food"></a>实例化类Snack和类Food</h1><p><strong>从该分隔线以下代码均在<code>main</code>函数内</strong></p>
<p><strong>从该分隔线以下代码均在<code>main</code>函数内</strong></p>
<p><strong>从该分隔线以下代码均在<code>main</code>函数内</strong></p>
<hr>
<p>实例化类的语法为<code>instancename = ClassName（parameter1, parameter2, ...)</code></p>
<p>在python中一般用全小写字母表示实例，与类做出区分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">snack = Snack()</span><br><span class="line">food = Food()</span><br></pre></td></tr></table></figure>

<p>在pygame中，设定游戏开始有相对固定的一套代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():           <span class="comment"># 设定游戏开始</span></span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:          <span class="comment"># 判定玩家是否退出（点击窗口的X关闭游戏）</span></span><br><span class="line">                pygame.quit()</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.KEYDOWN:       <span class="comment"># 检查玩家是否按下关键键位，为真则执行if后语句</span></span><br><span class="line">                snake.changedirection(event.key)   <span class="comment"># 玩家按下方向键以后执行改变方向</span></span><br><span class="line">            <span class="comment"># 死后按space重新开始</span></span><br><span class="line">             <span class="keyword">if</span> event.key == pygame.K_SPACE <span class="keyword">and</span> isdead:  </span><br><span class="line">            <span class="comment"># 如果贪吃蛇死亡判定为真，且玩家按了space键则重新开始游戏</span></span><br><span class="line">                    <span class="keyword">return</span> main()</span><br></pre></td></tr></table></figure>

<p>pygame提供了现成的方法检测玩家按下输入关键键位</p>
<p><strong>pygame.KEYDOWN 按下键盘时所按下的键</strong></p>
<p><strong>pygame.KEYUP 释放键盘时</strong></p>
<p><strong>event.key 指的是玩家按下的关键键位</strong></p>
<h2 id="构建蛇身体"><a href="#构建蛇身体" class="headerlink" title="构建蛇身体"></a>构建蛇身体</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isdead:                               <span class="comment"># 如果蛇没有死，那么蛇会一直移动</span></span><br><span class="line">    snake.move()</span><br><span class="line"><span class="keyword">for</span> rect <span class="keyword">in</span> snake.body:</span><br><span class="line">    pygame.draw.rect(screen,(<span class="number">20</span>,<span class="number">220</span>,<span class="number">39</span>),rect)  <span class="comment">#27 设置贪吃蛇的颜色（RGB颜色）</span></span><br></pre></td></tr></table></figure>

<p>如果isdead参数为否，则执行snake实例中的move方法。</p>
<p><strong>#27</strong> rect表示矩形对象, 对snake.body中的每一个矩形对象，用<code>pygame.draw.rect(screen, RGB，shape)</code>绘制矩形（贪吃蛇就是由矩形构成）。 screen表示屏幕界面，RGB用三元元组表示，rect为固定参数。</p>
<h2 id="加入食物与蛇的互动"><a href="#加入食物与蛇的互动" class="headerlink" title="加入食物与蛇的互动"></a>加入食物与蛇的互动</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 食物处理 / 吃到+50分</span></span><br><span class="line">        <span class="comment"># 当食物rect与蛇头重合,吃掉 -&gt; Snake增加一个Node</span></span><br><span class="line">        <span class="keyword">if</span> food.rect == snake.body[<span class="number">0</span>]:      </span><br><span class="line">            food.remove()                                       <span class="comment"># 移除</span></span><br><span class="line">            snake.addnode()                                     <span class="comment"># 增加蛇的一节身体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 食物投递</span></span><br><span class="line">        food.<span class="built_in">set</span>()                                              <span class="comment"># 刷新一个食物</span></span><br><span class="line">        pygame.draw.rect(screen,(<span class="number">136</span>,<span class="number">0</span>,<span class="number">21</span>),food.rect)           <span class="comment"># 绘制矩形对象</span></span><br></pre></td></tr></table></figure>

<h1 id="计算分数并在屏幕上打印文字"><a href="#计算分数并在屏幕上打印文字" class="headerlink" title="计算分数并在屏幕上打印文字"></a>计算分数并在屏幕上打印文字</h1><p>添加语句创建<code>scores    </code>变量并赋初值为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()                                    <span class="comment">#初始化pygame模块，确保pygame模块完整可用</span></span><br><span class="line">    screen_size = (SCREEN_X,SCREEN_Y)</span><br><span class="line">    screen = pygame.display.set_mode(screen_size)    <span class="comment">#设定游戏窗口的大小（分辨率吧）</span></span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;Snake&#x27;</span>)              <span class="comment">#设定游戏窗口的标题</span></span><br><span class="line">    clock = pygame.time.Clock()                      <span class="comment">#创建一个名字为clock的对象来记录时间</span></span><br><span class="line">    <span class="comment"># 这是添加的语句</span></span><br><span class="line">    scores = <span class="number">0</span>                                       <span class="comment">#初始化分数为0</span></span><br><span class="line">    isdead = <span class="literal">False</span>                                   <span class="comment">#创建死亡判定参数isdead,初始为False</span></span><br></pre></td></tr></table></figure>

<p><strong>构建在屏幕上打印字体的函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_text</span>(<span class="params">screen, pos, text, color, font_bold = <span class="literal">False</span>, font_size = <span class="number">60</span>, font_italic = <span class="literal">False</span></span>):   </span><br><span class="line">    <span class="comment">#获取系统字体，并设置文字大小                                             </span></span><br><span class="line">    cur_font = pygame.font.SysFont(<span class="string">&quot;宋体&quot;</span>, font_size)  </span><br><span class="line">    <span class="comment">#设置是否加粗属性  </span></span><br><span class="line">    cur_font.set_bold(font_bold)                                           </span><br><span class="line">    <span class="comment">#设置是否斜体属性                                                        </span></span><br><span class="line">    cur_font.set_italic(font_italic)  </span><br><span class="line">    <span class="comment">#设置文字内容  </span></span><br><span class="line">    text_fmt = cur_font.render(text, <span class="number">1</span>, color)                              </span><br><span class="line">    <span class="comment">#绘制文字  </span></span><br><span class="line">    screen.blit(text_fmt, pos)                                              </span><br></pre></td></tr></table></figure>

<p>  代码中方法均为pygame库内置。</p>
<p><strong>用函数在屏幕上显示分数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示分数文字</span></span><br><span class="line">show_text(screen,(<span class="number">50</span>,<span class="number">500</span>),<span class="string">&#x27;Scores: &#x27;</span>+<span class="built_in">str</span>(scores),(<span class="number">223</span>,<span class="number">223</span>,<span class="number">223</span>))</span><br><span class="line"><span class="comment"># The Pygame.display.update() 该方法可重新绘制屏幕 </span></span><br><span class="line">pygame.display.update()           </span><br><span class="line"><span class="comment"># The clock.tick() method 设定一秒内刷新的次数（数值越大，蛇运动的越快）</span></span><br><span class="line">clock.tick(<span class="number">10</span>)           </span><br></pre></td></tr></table></figure>

<p> <strong>显示死亡文字</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示死亡文字</span></span><br><span class="line">isdead = snake.isdead()</span><br><span class="line"><span class="keyword">if</span> isdead:                                    <span class="comment"># 判断贪吃蛇是否死亡</span></span><br><span class="line">    show_text(screen,(<span class="number">100</span>,<span class="number">200</span>),<span class="string">&#x27;YOU DEAD!&#x27;</span>,(<span class="number">227</span>,<span class="number">29</span>,<span class="number">18</span>),<span class="literal">False</span>,<span class="number">100</span>)</span><br><span class="line">    show_text(screen,(<span class="number">150</span>,<span class="number">260</span>),<span class="string">&#x27;press space to try again...&#x27;</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">22</span>),<span class="literal">False</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>



<h1 id="运行和调试"><a href="#运行和调试" class="headerlink" title="运行和调试"></a>运行和调试</h1><p>最后来一个main函数就可以运行游戏了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()</span><br></pre></td></tr></table></figure>

<h1 id="项目源代码地址"><a href="#项目源代码地址" class="headerlink" title="项目源代码地址"></a><a href="%5Bhttps://github.com/ZhangChunXian/learn-python-by-projects/tree/master/%E9%A1%B9%E7%9B%AE%E6%BA%90%E4%BB%A3%E7%A0%81%5D(https://github.com/ZhangChunXian/learn-python-by-projects/tree/master/%E9%A1%B9%E7%9B%AE%E6%BA%90%E4%BB%A3%E7%A0%81)"><strong>项目源代码地址</strong></a></h1><p>github.com/ZhangChunXian/learn-python-by-projects/tree/master/项目源代码</p>
<p><strong>最终效果：</strong></p>
<p><img data-src="/images/Snake/3.gif"></p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢各位的阅读！你的阅读是我更新的动力源泉。请根据博文质量点击相应的星级。</p>
<p>这是我第一次做python方面的项目。在尚无基础的情况下上手，我翻阅了一些书籍，还有不少大牛的博客，最终写下了这篇博文。有许多不足，望诸位谅解并指出在评论区，也可以通过邮件告诉我，我将逐一听取。感谢各位在我成长过程中给予的帮助。</p>
<p>同时也欢迎各位计算机学习者前来交流。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>选择</title>
    <url>/posts/%E6%8F%92%E7%8F%AD%E7%94%9F%E8%80%83%E8%AF%95_%E9%80%89%E6%8B%A9_url.html</url>
    <content><![CDATA[<p><em><strong>为了更好的阅读，请先收藏本文结构的思维导图</strong></em></p>
<img data-src="/images/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE1.png" class="">

<span id="more"></span>

<h1 id="请根据你的身份选择对应的段落进行阅读"><a href="#请根据你的身份选择对应的段落进行阅读" class="headerlink" title="请根据你的身份选择对应的段落进行阅读"></a><strong>请根据你的身份选择对应的段落进行阅读</strong></h1><h1 id="你是一个将要填写高考志愿的准大学生"><a href="#你是一个将要填写高考志愿的准大学生" class="headerlink" title="你是一个将要填写高考志愿的准大学生"></a>你是一个将要填写高考志愿的准大学生</h1><p> <strong>志愿很重要，不要掉以轻心！志愿很重要，不要掉以轻心！志愿很重要，不要掉以轻心！重要的事情说三遍!</strong></p>
<img data-src="/images/application.png" style="zoom:50%;" />

<hr>
<h2 id="插班生考试可以改变本科第一学历，是我已知的本科内唯一改变第一学历的途径，不得不说收益十分可观。但笔者认为，单纯因为想依靠插班生考试逆袭而孤注一掷的报考上海地区本科高校的行为是极其不明智的。原因如下"><a href="#插班生考试可以改变本科第一学历，是我已知的本科内唯一改变第一学历的途径，不得不说收益十分可观。但笔者认为，单纯因为想依靠插班生考试逆袭而孤注一掷的报考上海地区本科高校的行为是极其不明智的。原因如下" class="headerlink" title="插班生考试可以改变本科第一学历，是我已知的本科内唯一改变第一学历的途径，不得不说收益十分可观。但笔者认为，单纯因为想依靠插班生考试逆袭而孤注一掷的报考上海地区本科高校的行为是极其不明智的。原因如下:"></a>插班生考试可以改变本科第一学历，是我已知的本科内唯一改变第一学历的途径，不得不说收益十分可观。但笔者认为，单纯因为想依靠插班生考试逆袭而孤注一掷的报考上海地区本科高校的行为是极其不明智的。原因如下:</h2><h3 id="可选择学校少："><a href="#可选择学校少：" class="headerlink" title="可选择学校少："></a>可选择学校少：</h3><p>上海插班生考试终究是局限于上海地区部分学生的一种小众性考试，往年的报考人数只有几千人，远远不如高考这种全国性统考。相应的，实行插班生招生的高校局限于上海地区部分本科高校，虽不乏上海地区四大985名校，但是也少了上海财经大学，上海外国语大学这样的专业特色型大学。（图片取自上海市教委官网）</p>
<img data-src="/images/gaoxiao.png" style="zoom: 33%;" />

<h3 id="专业选少，限制多："><a href="#专业选少，限制多：" class="headerlink" title="专业选少，限制多："></a>专业选少，限制多：</h3><p>在专业上，插班生也会有很大的限制。其专业可选择的范围也远不如高考录取那么广泛，且大部分高校的插班生不能转专业，不能转专业，不能转专业（个人所知仅上海大学插班生可以转专业）。笔者以同济大学为例，该高校插班生仅招生8名学生，且仅限两个专业，招生简章中明确说明插班生不能转专业。此外，部分专业还要求插班生从大一就读。（图片取自2020年同济大学插班生招生简章）</p>
<img data-src="/images/同济.png" style="zoom:75%;" />

<img data-src="/images/转专业.png" alt="同济大学" style="zoom: 67%;" />

<h3 id="报录比悬殊，竞争激烈。"><a href="#报录比悬殊，竞争激烈。" class="headerlink" title="报录比悬殊，竞争激烈。"></a>报录比悬殊，竞争激烈。</h3><p> 尽管只有几千名学生参与上海插班生考试，但是插班生名额更少，造成一种僧多粥少的局面。特别是部分“热门专业”，竞争更是激烈。一个残酷的事实是，绝大部分备考插班生的学生最后都会失败。下图是2019年华师大插班生考试报名与录取的相关数据。</p>
<img data-src="/images/proportion.jpg" style="zoom: 150%;" />

<h3 id="考试流程特殊，学校自主命题，题型与难度不固定。"><a href="#考试流程特殊，学校自主命题，题型与难度不固定。" class="headerlink" title="考试流程特殊，学校自主命题，题型与难度不固定。"></a>考试流程特殊，学校自主命题，题型与难度不固定。</h3><p> 插班生的录取规则与高考截然相反，与考研大同小异。具体来说，考生选择自己报考的学校与专业，参与报考学校自主命题的考试。录取与否将以每个学校，每个专业划定的分数线为准。一些学校还会有复试，面试等流程。<strong>如果你高考没考好，你还可以选择其他大学读；如果你考插没考好，对不起，你只能回到你的原学校就读</strong></p>
<p> 各个高校的插班生考试均没有考纲，虽然规定了学科与考试范围，但由于自主命题，不同学校，不同专业的题型，难度等每年都在变化。如华师初始数学一反往年以高数上册为主的基调，加入了大量下册内容，考察知识点更多，难度却下降了。（/窃喜 还好难度下降了，不然数学菜鸡我就跪了）  (下图为往年录取流程)</p>
<p><img data-src="/images/process.png"></p>
<h3 id="小众群体孤军奋战，缺乏合理的参照。"><a href="#小众群体孤军奋战，缺乏合理的参照。" class="headerlink" title="小众群体孤军奋战，缺乏合理的参照。"></a>小众群体孤军奋战，缺乏合理的参照。</h3><p> 一般在学期刚开始，备考插班生考试的人数会达到顶峰，之后会断崖式的下降，特别是寒假之后，基本十之八九选择了放弃（笔者寒假也没好好学，出国交流去了/(ㄒoㄒ)/。在插班生简章出来之后，又会迎来一波插班生学习的热潮。所以，如果备考插班生，你可能成为你身边同学的“异类”——你会牺牲很多与同学之间社交的时间，不能很好的融入群体。你可能会孤军奋战，一个人学习，一个人吃饭，一个人吃苦。但是，最后，也可能只有你一个人享受考插成功的喜悦。</p>
<p> 考插和高考的又一大不同，就是你从来不知道你在人群中的水平。就像考研一样，你没有模拟考试，不知道你的对手的水平如何，甚至你身边的人，你也不知道他们的实力——而他们就可能成为你考插的对手。插班生是靠排名确定录取的，优秀不能保证你会录取，比其他人都优秀才是录取的保证。</p>
<hr>
<p> 列了那么多，对插班生考试的风险与挑战，我认为论述的相对全面了。我对插班生考试在高考填报中的角色的个人观点是 <strong>插班生考试是在选择高考志愿的因素之一，你可以当成选择上海这座城市带来的机遇，但其绝对不是决定性因素。</strong>当你选择了参与插班生考试，请给自己留一条后路。万一你考插失败，你还有一个喜欢的大学，一个喜欢的专业就读，一路上会有你喜欢的风景。</p>
<ul>
<li>笔者自身经历作为参考，我的高考排名比上海大学历年录取排名没有高多少，考虑上大的所在城市，优势的应数专业等因素，我选择了上海大学。我在大一期间成绩凑合，大二分流到喜爱的计算机专业就读。本身我对自己的学校和专业比较满意。插班生考试是我追求个人进步的一次尝试。高考志愿和考插等没有孤注一掷，是经过了理性的思考做出的决定。</li>
</ul>
<p> <em><strong>如果在慎重决定后决定参与上海插班生考试，请认真阅读往年招生简章，请认真阅读往年招生简章，请认真阅读往年招生简章！一些学校如华理等会对报考插班生的考生的专业等做出限制，请务必认真阅读</strong></em></p>
<h1 id="你是一位在上海本科学校就读的学生"><a href="#你是一位在上海本科学校就读的学生" class="headerlink" title="你是一位在上海本科学校就读的学生"></a>你是一位在上海本科学校就读的学生</h1><p> 插班生考试是上海市独有的制度。恭喜你，你比其他城市的学生多了一个改变第一学历的机遇！希望你来到是个上海是一个理性的决策。现在，摆在你面前的还有几个选择</p>
<h2 id="你是否要参加并准备插班生考试？报考哪个学校和专业？"><a href="#你是否要参加并准备插班生考试？报考哪个学校和专业？" class="headerlink" title="你是否要参加并准备插班生考试？报考哪个学校和专业？"></a>你是否要参加并准备插班生考试？报考哪个学校和专业？</h2><h3 id="不是所有人适合参与插班生考试，"><a href="#不是所有人适合参与插班生考试，" class="headerlink" title="不是所有人适合参与插班生考试，"></a><strong>不是所有人适合参与插班生考试</strong>，</h3><p>说白了，这是一个高难度（特别是985高校），强应试（类似于高考），耗时耗力（对大部分人而言），高风险的考试。第二，插班生的专业往往都是一些冷门专业，请理性思考自己是否接受和适合这个专业。</p>
<p> <em><strong>不建议单纯为了改变本科第一学历而盲目选择高校从而忽视了专业。大多数学校的插班生，当初报考的专业是要跟你本科四年的。</strong></em></p>
<p> 高难度，强应试，下图为插班生考试往年难度</p>
<p><img data-src="/images/%E9%9A%BE%E5%BA%A61.jpg"></p>
<p><img data-src="/images/%E9%9A%BE%E5%BA%A62.jpg"></p>
<pre><code>许多头部高校的插班生考试难度以考研作为标准或对比物。解释一下，考研难度指的是全国硕士研究生统一招生考试的难度，是大多数学校招收研究生的考试标准。图标中所讲的难度为试题的平均难度，插班生考试的试题水平会波动，一般会有少量大于平均难度的题目，也会有一些低于平均难度的题目。笔者参与的是华东师范大学的插班生考试，水平仅限于考研，再往上三个学校的备考就不要问我了。
</code></pre>
<p><strong>经过了一年的插班生学习总结下来（考研难度的总结），考研没有想象中那么难，只要花的时间足够了，是能够达到这一水平的，且插班生考试大部分设计数学和英语，比考研少了政治与专业课，不会像考研那样任务繁重的。这就是一个小马过河的问题。与其被吓倒，不如自己尝试一下。</strong></p>
<p><em><strong>读到这部分的读者，建议回头看第1点写给将要填写高考志愿的准大学生的段落中的五点了解一下插班生考试的特点及其风险</strong></em></p>
<h3 id="报考的学校与专业"><a href="#报考的学校与专业" class="headerlink" title="报考的学校与专业"></a>报考的学校与专业</h3><p> 报考准则还是一些正确的废话，对自己的实力有一个合理的预估，对院校与专业有了一定的了解之后合理的决策。</p>
<p> 特别提醒（防踩雷指南）：</p>
<p>1.请认真阅读往年的招生简章，请认真阅读往年的招生简章，请认真阅读往年的招生简章！一些学校会有独特的规则，如2020年交大对每个学校插班生考生的名额做出限制，以绩点为排名，换言之，想报考交大，请注意你的在校绩点，不然可能连考试资格都没有（仅仅提醒，不代表往后的情况）。往年的招生简章，还是有一些参考性的.</p>
<img data-src="/images/交大要求.png" style="zoom:33%;" />

<p>各高校2020年插班生招生简章链接（官网）：</p>
<p><a href="http://www.ao.fudan.edu.cn/index!list.html?sideNav=302&ccid=10703&topNav=282">复旦大学2020年插班生招生简章</a></p>
<p><a href="http://gk.sjtu.edu.cn/Data/View/1639">上海交通大学2020年插班生招生简章</a></p>
<p><a href="https://bkzs.tongji.edu.cn/index.php?classid=3396&newsid=4470&t=show">同济大学2020年插班生招生简章</a></p>
<p><a href="https://zsb.ecnu.edu.cn/webapp/web-news-detail.jsp?newsUuid=a3fd6600-7a43-4f7d-9f67-98f60dbc8de9&moduleId=17">华东师范大学2020年插班生招生简章</a></p>
<p><a href="http://bkzsw.shu.edu.cn/info/1930/8278.htm">海大学2020年插班生招生简章</a></p>
<p><a href="https://zsb.ecust.edu.cn/2020/0617/c2323a109128/page.htm">华东理工大学2020年插班生招生简章</a></p>
<p><a href="http://jw.dhu.edu.cn/b2/19/c9979a242201/page.htm">东华大学2020年插班生招生简章</a></p>
<p><a href="https://zsb.ecupl.edu.cn/2020/0615/c3069a165919/page.htm">华东政法大学2020年插班生招生简章</a></p>
<p><a href="http://zhaoban.usst.edu.cn/2020/0616/c6165a223452/page.htm">上海理工大学2020年插班生招生简章</a></p>
<p><a href="https://zsjy.shou.edu.cn/2020/0612/c13814a271070/page.htm">上海海洋大学2020年插班生招生简章</a></p>
<p><a href="http://xxgk.shupl.edu.cn/_s10/2020/0616/c1141a13557/page.psp">上海海事大学2020年插班生招生简章</a></p>
<p><a href="http://xxgk.shupl.edu.cn/_s10/2020/0616/c1141a13557/page.psp">上海政法学院2020年插班生招生简章</a></p>
<p> 2.不建议报考与自己学校水平差距太大的高校，如二本学校报考复旦。请不要拿这次机遇赌这微乎其微的概率。往年的录取规律是：985的插班生大部分来自211，211的插班生大部分来自普通一本，普通一本的插班生来自而二三本学校。（笔者是211上海大学报考并上岸985华东师范大学）(下图为2020年复旦插班生部分专业预录取名单）</p>
<p><img data-src="/images/%E5%BD%95%E5%8F%96%E5%90%8D%E5%8D%95.png"></p>
<p> 3.对一些有复试的院校和专业的备考，可以不在复试内容上花很多时间。但最起码过一遍复试的内容。如果学校有相关的课程，选这个并好好学，争取得个高分，不要水过去了。如果通过了初试，你将只有几天的时间去准备复试和面试，这种局面是非常紧急的。所以，尽可能在不影响初试准备的前提下学习复试内容。复试被淘汰是非常可惜的，因为所有的院校复试录取比例都非常高，远远大于初试。以华师为例，今年华师大数据专业的分数线为165分，初试报考人数200+，复试人数10人，最终录取8人。（笔者就是那165分压线过的啊啊啊，复试还好都学过了，三天来的及准备，最终以第七名的成绩被录取。）</p>
<p> 华师大的初试发布时间点和复试时间点</p>
<img data-src="/images/结果发布.png" style="zoom:50%;" />

<img data-src="/images/复试时间.png" style="zoom:50%;" />

<h1 id="备考的方向怎么定？"><a href="#备考的方向怎么定？" class="headerlink" title="备考的方向怎么定？"></a>备考的方向怎么定？</h1><h2 id="分享一下我制定备考方向的策略"><a href="#分享一下我制定备考方向的策略" class="headerlink" title="分享一下我制定备考方向的策略"></a>分享一下我制定备考方向的策略</h2><h2 id="知晓目标院校和专业的大致难度。"><a href="#知晓目标院校和专业的大致难度。" class="headerlink" title="**知晓目标院校和专业的大致难度。 **"></a>**知晓目标院校和专业的大致难度。 **</h2><p><img data-src="/images/%E9%9A%BE%E5%BA%A61.jpg"><br><img data-src="/images/%E9%9A%BE%E5%BA%A62.jpg"></p>
<h2 id="根据具体难度制定科学的学习计划，计划最主要的是可行性，体系化与最终效果。"><a href="#根据具体难度制定科学的学习计划，计划最主要的是可行性，体系化与最终效果。" class="headerlink" title="根据具体难度制定科学的学习计划，计划最主要的是可行性，体系化与最终效果。"></a><strong>根据具体难度制定科学的学习计划，计划最主要的是可行性，体系化与最终效果。</strong></h2><pre><code> 可行性有两方面，一是难度的准确把握，超出自己的舒适区同时对自己来说不是特别复杂的难度为佳。二是计划留有余地，留下适当的运动娱乐社交的时间，同时也有利于当计划被不可抗力打断时可以较快的调整到正轨。
</code></pre>
<p>体系化值得是学习的内容要成体系，不要碎片化。如考研数学，请专注与一门辅导书和一个老师的体系。不要东拼西凑或者临时改换，这样不利于知识体系的构建。</p>
<p> 最终效果，就是计划最所达成的目标，要到往年目标院校的水平。一是使自己有录取的实力，二是保证考试时胸有成足心态佳。</p>
<p> 提醒：1. （如果考试涉及到考研难度内容）不要把考研难度妖魔化，复杂化。等自己水平提高了就会发现考研难度没有想象中的那么可怕，所有的恐惧都来源于未知而已。</p>
<p>​            2. 题目每年都会变，难度也飘忽不定。但是除了复旦交大等头部高校，其他学校的插班生考试难度都以考研为天花板。准备到考研难度无疑是最稳妥的。</p>
<pre><code>        3. 请重视基础，切忌眼高手低，这个道理放在任何考试都是一样的。
</code></pre>
<p>​            4.多打听准确的消息，获取珍贵的考试信息。（如往年的回忆试题）</p>
<pre><code>        5.高校招生简章中说的考试范围，请务必基础全部过一遍，不要抱有侥幸心理。如2020年华师一反往年高数只考上册的常态，出的高数试卷中大部分都是下册。虽然题目不难，但是没有下册基础还是做不出来。即使上册再好也无济于事（肯定有这样的考生）。

我自己的经历：虽然最早在七月份就准备插班生考试，但是从七月到20年一月，我其实并没有很清晰的计划，像一个无头苍蝇一样寻找个各种零散的资料学习（不体系化）。甚至在一月到二月，我还花费了一个月出国交流。到二月步入正轨，我从背单词开始，断断续续从四级背到了考研，数学也才开始看网课。到五月份了，英语开始做题，数学开始大量刷题。已知到临考前七天，我才做完了往年的考研试卷，一本数学习题集（都是配套的）。短暂的一星期后，我就上了战场。实际上我大部分时间都没有一个好的计划，如果2020年插班生考试没有延后，我大概率会失败。望大家以我为鉴。
</code></pre>
<h1 id="备考时选择怎么样的学习方法？"><a href="#备考时选择怎么样的学习方法？" class="headerlink" title="备考时选择怎么样的学习方法？"></a>备考时选择怎么样的学习方法？</h1><p>恭喜你看完第一个阶段，请点击下方的链接阅读第二阶段——方法</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><a href="%5Bhttps://zcxblog.cn/posts/%E6%8F%92%E7%8F%AD%E7%94%9F%E8%80%83%E8%AF%95_%E6%96%B9%E6%B3%95_url.html%5D(https://zcxblog.cn/posts/%E6%8F%92%E7%8F%AD%E7%94%9F%E8%80%83%E8%AF%95_%E6%96%B9%E6%B3%95_url.html)">方法</a></h2><ul>
<li> 如果有错误或者是改进的意见，请在下方评论区畅所欲言。笔者第一次做个人博客，没有经验，写作也还有些欠</li>
<li>如果你觉得对你有帮助，请动一动你可爱的小手给我打几颗星，不要下次一定好不好？</li>
<li>(￣▽￣)～■干杯□～(￣▽￣)</li>
<li>最后的最后，如果可以，请到我的GitHub主页给我点个star小星星吧( <em>￣▽￣)((≧︶≦</em>)</li>
</ul>
]]></content>
      <categories>
        <category>插班生考试</category>
      </categories>
      <tags>
        <tag>插班生考试</tag>
      </tags>
  </entry>
</search>
