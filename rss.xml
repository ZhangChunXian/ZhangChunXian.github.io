<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ZhangChunXian</title>
    <link>http://ZhangChunXian.github.io/</link>
    
    <atom:link href="http://zhangchunxian.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>ZhangChunXian</description>
    <pubDate>Wed, 12 Jul 2023 06:59:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>http://zhangchunxian.github.io/posts/undefined.html</link>
      <guid>http://zhangchunxian.github.io/posts/undefined.html</guid>
      <pubDate>Wed, 12 Jul 2023 06:59:47 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;CPU-The-Central-Processing-Unit&quot;&gt;&lt;a href=&quot;#CPU-The-Central-Processing-Unit&quot; class=&quot;headerlink&quot; title=&quot;CPU- The Central Processing Un</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="CPU-The-Central-Processing-Unit"><a href="#CPU-The-Central-Processing-Unit" class="headerlink" title="CPU- The Central Processing Unit"></a>CPU- The Central Processing Unit</h1><p>计算机的心脏是“中央处理单元”, 简称“CPU”.</p><p>CPU用来运行程序, 程序由一个个操作组成, 这些操作叫做“指令”(<code>instruction</code>). 指令指示计算机所做的行为. 例如算数运算指令,  CPU会让ALU进行算数运算, 又例如内存指令, CPU会和内存通信, 然后读写值.</p><h2 id="CPU组件"><a href="#CPU组件" class="headerlink" title="CPU组件"></a>CPU组件</h2><p>从高层次视角, CPU组件之间组合的方式叫做“微体系架构”, 简称“架构”, 如AMD今年10月份发布的zen3架构锐龙5000桌面处理器. 其实不只CPU, 芯片都有架构, 大家9月份听到更多的架构肯定源自于NVIDIA(英伟达)的30系显卡的安培架构等.  架构如此重要, 以至于先进的架构早已经成为了衡量芯片的一项重要指标.</p>]]></content:encoded>
      
      
      
      
      <comments>http://zhangchunxian.github.io/posts/undefined.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://zhangchunxian.github.io/posts/undefined.html</link>
      <guid>http://zhangchunxian.github.io/posts/undefined.html</guid>
      <pubDate>Wed, 12 Jul 2023 06:59:47 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;gitlab-克隆仓库前的操作&quot;&gt;&lt;a href=&quot;#gitlab-克隆仓库前的操作&quot; class=&quot;headerlink&quot; title=&quot;gitlab 克隆仓库前的操作&quot;&gt;&lt;/a&gt;gitlab 克隆仓库前的操作&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://b</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="gitlab-克隆仓库前的操作"><a href="#gitlab-克隆仓库前的操作" class="headerlink" title="gitlab 克隆仓库前的操作"></a>gitlab 克隆仓库前的操作</h1><p><a href="https://blog.csdn.net/Alvin_Lam/article/details/90513353">https://blog.csdn.net/Alvin_Lam/article/details/90513353</a></p><p>通过SSH克隆远程仓库（GitLab）到本地</p><p>由于不是任何用户都能从远程仓库克隆到本地的，也是需要鉴别的，因此本地需要用git bash 创建一个公钥，而远程仓库也要把这个公钥保存下来，进而本地才可以从远程download。主要步骤如下：</p><p>1.首先需要下载一个git for windows，成功安装。</p><p>2.在github或者gitlab上有自己的账户。</p><p>3.打开git bash.exe 输入ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#x75;&#114;&#95;&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#x79;&#111;&#x75;&#114;&#95;&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a>“ 使用你的邮箱用ssh-keygen命令创建密码对。注意ssh-keygen命令中间没有空格，如果在ssh后面加上空格，会得到Bad escape character ‘ygen’.的错误。</p><p>4.在目录C:\Users\your_name.ssh 目录下找到生成的公钥文件id_rsa.pub，记事本打开，将里面的内容复制到剪贴板。</p><p>5.打开新建的github或者gitlab账户，找到SSH Keys选项如图：</p><p><img data-src="/../../images/20170616000042021"><br>将剪贴板内容粘贴到内容框中，title可以用默认的邮箱名字，最后点击add。这就代表这个用户被远程仓库所承认了，接下来就可以克隆仓库了。</p><p>6.可以先选择一个空文件夹用来储存克隆下来的项目，然后鼠标右键选择git bash here，然后输入命令 git clone + 自己Git库的地址，如图</p><p><img data-src="/../../images/20170616001413481"></p><p>Receiving objects :100% Resolving deltas:100%  代表远程仓库项目已经下载到本地。</p><p>创建SSH的目的：</p><p>创建SSH KEY(这个作用是来识别你的电脑，相当于人的身份证号)，在你的c盘用户目录下面（我的目录–C:\Users\LX）看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：$ ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#117;&#x72;&#101;&#109;&#x61;&#105;&#108;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#x79;&#111;&#117;&#x72;&#101;&#109;&#x61;&#105;&#108;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a>“，<br>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>]]></content:encoded>
      
      
      
      
      <comments>http://zhangchunxian.github.io/posts/undefined.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://zhangchunxian.github.io/posts/undefined.html</link>
      <guid>http://zhangchunxian.github.io/posts/undefined.html</guid>
      <pubDate>Wed, 12 Jul 2023 06:59:47 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;code&gt;F12&lt;/code&gt;从定义和调用之间跳转&lt;/p&gt;
&lt;p&gt;可以自己制作头文件, 在‘resource files’中, 后缀为.h, 在&lt;code&gt;Source file&lt;/code&gt;中调用需要&lt;code&gt;#incude &amp;quot;header_file_nam</description>
        
      
      
      
      <content:encoded><![CDATA[<p><code>F12</code>从定义和调用之间跳转</p><p>可以自己制作头文件, 在‘resource files’中, 后缀为.h, 在<code>Source file</code>中调用需要<code>#incude &quot;header_file_name&quot;</code></p><p>黄色箭头可以用鼠标左键来改变位置.</p><p>只有拥有源代码生成的进程才可以调试.</p>]]></content:encoded>
      
      
      
      
      <comments>http://zhangchunxian.github.io/posts/undefined.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo + Github Pages博客配置总结</title>
      <link>http://zhangchunxian.github.io/posts/lab09.html</link>
      <guid>http://zhangchunxian.github.io/posts/lab09.html</guid>
      <pubDate>Wed, 10 May 2023 14:22:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Hexo-Github-Pages博客配置总结&quot;&gt;&lt;a href=&quot;#Hexo-Github-Pages博客配置总结&quot; class=&quot;headerlink&quot; title=&quot;Hexo + Github Pages博客配置总结&quot;&gt;&lt;/a&gt;Hexo + Github P</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Hexo-Github-Pages博客配置总结"><a href="#Hexo-Github-Pages博客配置总结" class="headerlink" title="Hexo + Github Pages博客配置总结"></a>Hexo + Github Pages博客配置总结</h1><h1 id="博客主题及其选择原因"><a href="#博客主题及其选择原因" class="headerlink" title="博客主题及其选择原因"></a>博客主题及其选择原因</h1><p>我是在三年前， 也就是大一入学不久就建立了我的这个博客（<a href="https://zhangchunxian.github.io/%EF%BC%89%EF%BC%8C%E5%BD%93%E6%97%B6%E6%88%91%E7%9C%8B%E4%BA%86%E4%B8%80%E4%BA%9B%E6%9C%AC%E6%A0%A1%E5%AD%A6%E9%95%BF%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%BB%BA%E7%AB%8BHexo%E5%8D%9A%E5%AE%A2%E4%B9%9F%E6%98%AF%E5%8F%97%E5%88%B0%E4%BA%86Godweiyang%E5%AD%A6%E9%95%BF%E7%9A%84%E8%BF%99%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82%EF%BC%88">https://zhangchunxian.github.io/），当时我看了一些本校学长的博客，建立Hexo博客也是受到了Godweiyang学长的这篇博客的影响。（</a> <a href="https://godweiyang.com/2018/04/13/hexo-blog/%EF%BC%89%E3%80%82">https://godweiyang.com/2018/04/13/hexo-blog/）。</a> 在这篇文章中Godweiyang就是使用Hexo框架配置的个人博客。 </p><p>至于Hexo与github pages的好处, 比起自己搭建博客，这两个结合在一起可以省去购买域名和服务器的成本，不需要考虑定期维护，对于不使用全栈的人（比如我），非常省力</p><p>为什么选择Hexo框架的next主题呢? 主要是因为在翻阅Hexo主题时, 最中意的就是这篇博客(<a href="https://blog.ahao.moe/)%E7%9A%84%E6%A0%B7%E5%BC%8F%E4%BA%86">https://blog.ahao.moe/)的样式了</a>, 里面使用的样式就是next, 所以我就选择了next主题.</p><h1 id="博客页面及其设计思路"><a href="#博客页面及其设计思路" class="headerlink" title="博客页面及其设计思路"></a>博客页面及其设计思路</h1><p>博客页面布局如下:</p><ul><li>页面菜单栏: 包含主页, 标签, 分类, 归档, 关于, 搜索等选项</li><li>页面菜单栏: 包含个人联系方式, 博客信息, 友情链接等信息.</li><li>内容栏: 包含最近发布的缩略的博客文章.</li></ul><p><img data-src="/./images/image-20230510192257469.png" alt="image-20230510192257469"></p><h1 id="博客功能实现及其技术选择"><a href="#博客功能实现及其技术选择" class="headerlink" title="博客功能实现及其技术选择"></a>博客功能实现及其技术选择</h1><p>Hexo + github的搭建网上已经有很多文档了, 简单来说可以分为三步</p><ul><li><p>在github上建立公开仓库, 名字必须为  自己的Github用户名.github.io, readme初始化的选项也要选择.</p></li><li><p>在本地安装npm包hexo-deployer-git, 使用<code>hexo new post &quot;article title&quot;</code> 新建一篇文章, 在source/_posts/文件夹下会看到新建的.md文件, 在md文件里面编辑即可.</p></li><li><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦.</p></li></ul><h2 id="选择markdown作为编辑语言"><a href="#选择markdown作为编辑语言" class="headerlink" title="选择markdown作为编辑语言"></a>选择markdown作为编辑语言</h2><p>博客渲染本质上是将markdown转化为html渲染在静态页面上.</p><p>Markdown是一种轻量级的标记语言, 非常简单易学. Markdown其实就是用一些简单符号来起到排版作用，因为纯键盘操作，写作时少调用鼠标，效率能提升很多，不必多花时间在排版上。对于博客来说, 写作本身就是最重要的.</p><h1 id="博客样式及其美学考量"><a href="#博客样式及其美学考量" class="headerlink" title="博客样式及其美学考量"></a>博客样式及其美学考量</h1><h2 id="文章的分类与整理"><a href="#文章的分类与整理" class="headerlink" title="文章的分类与整理"></a>文章的分类与整理</h2><p>每个博客文章都有对应的时间, 标签, 分类. </p><ul><li><h2 id="在菜单栏点击标签页面可以根据标签查看博客"><a href="#在菜单栏点击标签页面可以根据标签查看博客" class="headerlink" title="在菜单栏点击标签页面可以根据标签查看博客"></a>在菜单栏点击标签页面可以根据标签查看博客</h2></li><li>在菜单栏点击归档, 可以按照时间顺序查看博客.<ul><li><img data-src="/./images/image-20230511163338541.png" alt="image-20230511163338541"></li></ul></li><li>在菜单来点击分类, 可以按照分类查看博客.<ul><li><img data-src="/./images/image-20230511163418490.png" alt="image-20230511163418490"></li></ul></li></ul><p>最后, 可以根据文字内容搜索博客相关内容.</p><p><img data-src="/./images/image-20230511163448915.png" alt="image-20230511163448915"></p><h1 id="博客制作过程中遇到的问题及其解决方法"><a href="#博客制作过程中遇到的问题及其解决方法" class="headerlink" title="博客制作过程中遇到的问题及其解决方法"></a>博客制作过程中遇到的问题及其解决方法</h1><h2 id="问题1-Failed-to-connect-to-github-com-port-443-connection-timed-out"><a href="#问题1-Failed-to-connect-to-github-com-port-443-connection-timed-out" class="headerlink" title="问题1 Failed to connect to github.com port 443:connection timed out"></a>问题1 Failed to connect to github.com port 443:connection timed out</h2><p>这个问题可能是因为在本地使用了代理, 我们使用git取消代理一般就可以解决问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取消全局代理：</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line"> </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><h2 id="问题2-推送新文章到博客后还需要手动重新生成Github-pages"><a href="#问题2-推送新文章到博客后还需要手动重新生成Github-pages" class="headerlink" title="问题2 推送新文章到博客后还需要手动重新生成Github pages"></a>问题2 推送新文章到博客后还需要手动重新生成Github pages</h2><p>这个问题说小不小, 每当我们辛苦写完一篇博客文章后, 推送到github上, 万一忘记了重新部署Hexo静态页面. 我们写完的文章是不会出现在博客网页上的</p><p>这里的解决方案是使用Travis CI（持续集成）</p><p>Travis CI（持续集成）是一个在软件开发过程中提供自动化构建、测试和部署的在线平台。它与GitHub等代码托管服务紧密集成，可以轻松地为您的项目设置持续集成流程。</p><p>我们只需要以下步骤:</p><ul><li>配置文件：需要在项目的根目录下创建一个名为<code>.travis.yml</code>的配置文件，该文件用于定义构建和测试的步骤。</li><li>触发构建：每当您向代码库提交新的更改或推送到GitHub仓库时，Travis CI将自动检测到这些更改，并触发构建过程。</li></ul><p>因为Travis CI灵活的配置和能够自动化部署的特性, 我们只需要配置好Travis CI后直接push文章就可以了.</p><p>travis.yml内容如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># node版本</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 设置只监听哪个分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"><span class="comment"># 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">apt:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">yarn:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">theme</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="comment">#  配置git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;ZhangChunXian&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;1836891291@qq.com&quot;</span></span><br><span class="line">  <span class="comment"># 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">curl</span> <span class="string">-o-</span> <span class="string">-L</span> <span class="string">https://yarnpkg.com/install.sh</span> <span class="string">|</span> <span class="string">bash</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">PATH=$HOME/.yarn/bin:$PATH</span></span><br><span class="line">  <span class="comment"># npm模块安装</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">global</span> <span class="string">add</span> <span class="string">hexo-cli</span></span><br><span class="line">  <span class="comment"># - yarn remove hexo-renderer-marked</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-renderer-kramed</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-asset-image</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-searchdb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="comment">#- yarn add hexo-related-popular-posts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-symbols-count-time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-sitemap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-generator-baidu-sitemap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-deployer-git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-helper-live2d</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">theme-next/next-util</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将 GitHub Token 替换到 next.yml 中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/REPO_TOKEN/$&#123;REPO_TOKEN&#125;/&quot;</span> <span class="string">source/_data/next.yml</span></span><br><span class="line">  <span class="comment"># next主题下载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/hexo-theme-next</span> <span class="string">themes/next</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">themes/next</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">v7.7.2</span> <span class="string">&amp;&amp;</span> <span class="string">cd</span> <span class="bullet">-</span></span><br><span class="line">  <span class="comment"># next主题依赖下载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/theme-next-pdf</span> <span class="string">themes/next/source/lib/pdf</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/theme-next-pace</span> <span class="string">themes/next/source/lib/pace</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="comment"># 不用yarn的话这里改成 npm i 即可</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="string">--config</span> <span class="string">source/_data/next.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">--config</span> <span class="string">source/_data/next.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">d</span> <span class="string">--config</span> <span class="string">source/_data/next.yml</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B/">校内课程</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E6%A0%A1%E5%86%85%E8%AF%BE%E7%A8%8B/">校内课程</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/lab09.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>你好世界</title>
      <link>http://zhangchunxian.github.io/posts/hello_world.html</link>
      <guid>http://zhangchunxian.github.io/posts/hello_world.html</guid>
      <pubDate>Tue, 22 Feb 2022 14:22:22 GMT</pubDate>
      
      <description>&lt;p&gt;more标签是分割线, 用来显示查看更多&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>more标签是分割线, 用来显示查看更多</p><span id="more"></span><hr><p><strong>Advertisement :)</strong></p><ul><li><strong><a href="https://nodeca.github.io/pica/demo/">pica</a></strong> - high quality and fast image<br>resize in browser.</li><li><strong><a href="https://github.com/nodeca/babelfish/">babelfish</a></strong> - developer friendly<br>i18n with plurals support and easy syntax.</li></ul><p>You will like those projects!</p><hr><h1 id="h1-Heading-8"><a href="#h1-Heading-8" class="headerlink" title="h1 Heading 8-)"></a>h1 Heading 8-)</h1><h2 id="h2-Heading"><a href="#h2-Heading" class="headerlink" title="h2 Heading"></a>h2 Heading</h2><h3 id="h3-Heading"><a href="#h3-Heading" class="headerlink" title="h3 Heading"></a>h3 Heading</h3><h4 id="h4-Heading"><a href="#h4-Heading" class="headerlink" title="h4 Heading"></a>h4 Heading</h4><h5 id="h5-Heading"><a href="#h5-Heading" class="headerlink" title="h5 Heading"></a>h5 Heading</h5><h6 id="h6-Heading"><a href="#h6-Heading" class="headerlink" title="h6 Heading"></a>h6 Heading</h6><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><hr><hr><hr><h2 id="Typographic-replacements"><a href="#Typographic-replacements" class="headerlink" title="Typographic replacements"></a>Typographic replacements</h2><p>Enable typographer option to see result.</p><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>test.. test… test….. test?….. test!….</p><p>!!!!!! ???? ,,  – —</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h2><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><del>Strikethrough</del></p><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>Unordered</p><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces:<ul><li>Marker character change forces new list start:<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><p>Ordered</p><ol><li>Lorem ipsum dolor sit amet</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><ol><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><p>Start numbering with offset:</p><ol start="57"><li>foo</li><li>bar</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Inline <code>code</code></p><p>Indented code</p><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><p>Block code “fences”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample text here...</span><br></pre></td></tr></table></figure><p>Syntax highlighting</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params">bar</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> bar++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td>ext</td><td>extension to be used for dest files.</td></tr></tbody></table><p>Right aligned columns</p><table><thead><tr><th align="right">Option</th><th align="right">Description</th></tr></thead><tbody><tr><td align="right">data</td><td align="right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="right">engine</td><td align="right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="right">ext</td><td align="right">extension to be used for dest files.</td></tr></tbody></table><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p><a href="http://dev.nodeca.com/">link text</a></p><p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p><p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enable linkify to see)</p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><p><img data-src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img data-src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><p><img data-src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>.</p><h3 id="Emojies"><a href="#Emojies" class="headerlink" title="Emojies"></a><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><blockquote><p>Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:</p><p>Shortcuts (emoticons): :-) :-( 8-) ;)</p></blockquote><p>see <a href="https://github.com/markdown-it/markdown-it-emoji#change-output">how to change output</a> with twemoji.</p><h3 id="Subscript-Superscript"><a href="#Subscript-Superscript" class="headerlink" title="Subscript / Superscript"></a><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><ul><li>19^th^</li><li>H<del>2</del>O</li></ul><h3 id="lt-ins-gt"><a href="#lt-ins-gt" class="headerlink" title="&lt;ins&gt;"></a><a href="https://github.com/markdown-it/markdown-it-ins">&lt;ins&gt;</a></h3><p>++Inserted text++</p><h3 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="&lt;mark&gt;"></a><a href="https://github.com/markdown-it/markdown-it-mark">&lt;mark&gt;</a></h3><p>==Marked text==</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><p>Footnote 1 link[^first].</p><p>Footnote 2 link[^second].</p><p>Inline footnote^[Text of inline footnote] definition.</p><p>Duplicated footnote reference[^second].</p><p>[^first]: Footnote <strong>can have markup</strong></p><pre><code>and multiple paragraphs.</code></pre><p>[^second]: Footnote text.</p><h3 id="Definition-lists"><a href="#Definition-lists" class="headerlink" title="Definition lists"></a><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><p>Term 1</p><p>:   Definition 1<br>with lazy continuation.</p><p>Term 2 with <em>inline markup</em></p><p>:   Definition 2</p><pre><code>    &#123; some code, part of Definition 2 &#125;Third paragraph of definition 2.</code></pre><p><em>Compact style:</em></p><p>Term 1<br>~ Definition 1</p><p>Term 2<br>~ Definition 2a<br>~ Definition 2b</p><h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><p>This is HTML abbreviation example.</p><p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><p>*[HTML]: Hyper Text Markup Language</p><h3 id="Custom-containers"><a href="#Custom-containers" class="headerlink" title="Custom containers"></a><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E5%88%86%E7%B1%BB1/">分类1</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E6%A0%87%E7%AD%BE1/">标签1</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/hello_world.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP程序优化技巧总结</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93_url.html</guid>
      <pubDate>Sun, 08 Nov 2020 12:14:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Chapter-6-存储器层次结构&quot;&gt;&lt;a href=&quot;#Chapter-6-存储器层次结构&quot; class=&quot;headerlink&quot; title=&quot;Chapter 6 存储器层次结构&quot;&gt;&lt;/a&gt;Chapter 6 存储器层次结构&lt;/h1&gt;&lt;h2 id=&quot;1-cac</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Chapter-6-存储器层次结构"><a href="#Chapter-6-存储器层次结构" class="headerlink" title="Chapter 6 存储器层次结构"></a>Chapter 6 存储器层次结构</h1><h2 id="1-cache存储块的抖动问题"><a href="#1-cache存储块的抖动问题" class="headerlink" title="1. cache存储块的抖动问题"></a>1. cache存储块的抖动问题</h2><p>中文版本 P431 6. 直接映射高速缓存总的冲突不命中</p><p>虽然书上的实例针对的是直接映射高速缓存的抖动问题, 但这些也同样适用于组相联映射高速缓存.</p><h2 id="2-编写对高速缓存友好的代码"><a href="#2-编写对高速缓存友好的代码" class="headerlink" title="2. 编写对高速缓存友好的代码"></a>2. 编写对高速缓存友好的代码</h2><p>中文书P440 6.5</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020.11 记录</title>
      <link>http://zhangchunxian.github.io/posts/2020.11%E8%AE%B0%E5%BD%95_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/2020.11%E8%AE%B0%E5%BD%95_url.html</guid>
      <pubDate>Mon, 02 Nov 2020 11:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;C-语言-用EOF代替回车作为终止输入的符号&quot;&gt;&lt;a href=&quot;#C-语言-用EOF代替回车作为终止输入的符号&quot; class=&quot;headerlink&quot; title=&quot;C 语言: 用EOF代替回车作为终止输入的符号&quot;&gt;&lt;/a&gt;C 语言: 用EOF代替回车作为终止输</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="C-语言-用EOF代替回车作为终止输入的符号"><a href="#C-语言-用EOF代替回车作为终止输入的符号" class="headerlink" title="C 语言: 用EOF代替回车作为终止输入的符号"></a>C 语言: 用EOF代替回车作为终止输入的符号</h1><p>EOF 知识链接:</p><p> <a href="https://stackoverflow.com/questions/1782080/what-is-eof-in-the-c-programming-language">What is EOF in the C programming language?</a></p><p>用EOF终止输入需要保证EOF在回车后输入, 否则EOF不会被识别到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用EOF终止字符的输入</span></span><br><span class="line"><span class="keyword">if</span> ( (str = getchar()) != EOF ) <span class="comment">// 继续输入</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*语句*/</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="comment">/*终止语句*/</span></span><br></pre></td></tr></table></figure><p>题目:</p><p><a href="http://oj.kfcoding.com/contest/24/problem/6-1">http://oj.kfcoding.com/contest/24/problem/6-1</a></p><p><img data-src="/../../images/image-20201105145810345.png"></p><p>答案:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCount</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> English_char = <span class="number">0</span>, Space_and_Enter = <span class="number">0</span>,</span><br><span class="line">num_char = <span class="number">0</span>, other_char = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((s[i] = getchar()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">English_char++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">num_char++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span> || s[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Space_and_Enter++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, English_char, Space_and_Enter, num_char</span><br><span class="line">, <span class="built_in">strlen</span>(s) - English_char - Space_and_Enter - num_char - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">StringCount(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C语言-消除输出的最后一位空格"><a href="#C语言-消除输出的最后一位空格" class="headerlink" title="C语言: 消除输出的最后一位空格"></a>C语言: 消除输出的最后一位空格</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>上面这里是输出ASCII码为8的字符，这是一个Backspace控制符。于是可以往回消去一个字符。</p><p>PS: 经过验证, 该方法有效, 但是在学校的oj平台上无用, 且会被判定为未知字符.</p><h1 id="Git-amp-Github"><a href="#Git-amp-Github" class="headerlink" title="Git &amp; Github"></a>Git &amp; Github</h1><p><a href="https://stackoverflow.com/questions/67699/how-to-clone-all-remote-branches-in-git">How to clone all remote branches in Git?</a></p><h1 id="VSCODE-输出中文乱码解决方法"><a href="#VSCODE-输出中文乱码解决方法" class="headerlink" title="VSCODE: 输出中文乱码解决方法"></a>VSCODE: 输出中文乱码解决方法</h1><p><a href="https://www.w3xue.com/exp/article/20203/80007.html">https://www.w3xue.com/exp/article/20203/80007.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/30127242">https://zhuanlan.zhihu.com/p/30127242</a>)</p><h1 id="C语言-strrev-function"><a href="#C语言-strrev-function" class="headerlink" title="C语言: strrev() function"></a>C语言: strrev() function</h1><h4 id="strrev-function"><a href="#strrev-function" class="headerlink" title="strrev() function"></a>strrev() function</h4><p>It is used to reverse the given string expression.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    char s1[50]; </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Enter your string: &quot;); </span><br><span class="line">    gets(s1);  </span><br><span class="line">    printf(&quot;\nYour reverse string is: %s&quot;,strrev(s1)); </span><br><span class="line">    return(0); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output</span></span><br><span class="line">Enter your <span class="built_in">string</span>: studytonight </span><br><span class="line">Your reverse <span class="built_in">string</span> is: thginotyduts</span><br></pre></td></tr></table></figure><h1 id="C语言-scanf输出输出一行包括空格的字符串"><a href="#C语言-scanf输出输出一行包括空格的字符串" class="headerlink" title="C语言: scanf输出输出一行包括空格的字符串"></a>C语言: scanf输出输出一行包括空格的字符串</h1><h3 id="String-Input-and-Output"><a href="#String-Input-and-Output" class="headerlink" title="String Input and Output"></a>String Input and Output</h3><p>Input function <code>scanf()</code> can be used with <strong>%s</strong> format specifier to read a string input from the terminal. But there is one problem with <code>scanf()</code> function, it terminates its input on the first white space it encounters. Therefore if you try to read an input string “Hello World” using <code>scanf()</code> function, it will only read <strong>Hello</strong> and terminate after encountering white spaces.</p><p>However, C supports a format specification known as the <strong>edit set conversion code %[..]</strong> that can be used to read a line containing a variety of characters, including white spaces.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, &amp;str);  <span class="comment">//scanning the whole string, including the white spaces</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C语言-动态分配数组-一维"><a href="#C语言-动态分配数组-一维" class="headerlink" title="C语言: 动态分配数组(一维)"></a>C语言: 动态分配数组(一维)</h1><h2 id="数组元素个数为变量"><a href="#数组元素个数为变量" class="headerlink" title="数组元素个数为变量"></a>数组元素个数为变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="literal">NULL</span>;<span class="comment">// 声明数组头指针</span></span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>;<span class="comment">// 声明变量并初始化</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);<span class="comment">// 变量赋值</span></span><br><span class="line">a = (<span class="type">int</span> *) <span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 动态分配内存</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 之后a的用法与a[N]无异</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//!!!i使用结束后必须释放内存空间</span></span><br></pre></td></tr></table></figure><h1 id="C语言-动态分配数组-二维"><a href="#C语言-动态分配数组-二维" class="headerlink" title="C语言: 动态分配数组(二维)"></a>C语言: 动态分配数组(二维)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nrows, ncolumns;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, nrows, ncolumns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为数组分配行数 注意分配的是整形指针的数量 每行元素是个整形指针</span></span><br><span class="line">    <span class="type">int</span> **<span class="built_in">array</span> = <span class="built_in">malloc</span>(nrows * <span class="keyword">sizeof</span>(*<span class="built_in">array</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每行分配数组的个数(二维数组列数)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nrows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 为每行申请内存空间</span></span><br><span class="line">        <span class="built_in">array</span>[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(ncolumns * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*接下来等于对 a[nrows][ncolumns] 进行操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(<span class="built_in">array</span>);     <span class="comment">// 一定要在最后讲内存空间释放!!</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C语言-Problem-with-scanf-when-there-is-fgets-gets-scanf-after-it"><a href="#C语言-Problem-with-scanf-when-there-is-fgets-gets-scanf-after-it" class="headerlink" title="C语言: Problem with scanf() when there is fgets()/gets()/scanf() after it"></a>C语言: Problem with scanf() when there is fgets()/gets()/scanf() after it</h1><p><a href="https://www.geeksforgeeks.org/problem-with-scanf-when-there-is-fgetsgetsscanf-after-it/">article_links</a></p><h1 id="C语言-fgets函数的一些注意事项"><a href="#C语言-fgets函数的一些注意事项" class="headerlink" title="C语言: fgets函数的一些注意事项"></a>C语言: fgets函数的一些注意事项</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><ol><li><p><code>fets</code>函数中的第二个参数为字符串的允许输入个数, 实际上这个个数是要算上字符串的结尾‘\0’, 除去‘\0’, 有效输入字符为 <code>n-1</code>个.</p></li><li><p>当fgets函数以换行符号作为最后的终止符, 如果当前输入的字符个数小于<code>n-1</code>, 那么换行符<code>\n</code>也会作为输入字符记载到字符串中.</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/2020.11%E8%AE%B0%E5%BD%95_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP_3.8_数组的分配与访问</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE_url.html</guid>
      <pubDate>Sun, 18 Oct 2020 12:04:00 GMT</pubDate>
      
      
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 3.5 算术运算与逻辑运算</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3.5_%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3.5_%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97_url.html</guid>
      <pubDate>Mon, 12 Oct 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;3-5-1-加载有效地址&quot;&gt;&lt;a href=&quot;#3-5-1-加载有效地址&quot; class=&quot;headerlink&quot; title=&quot;3.5.1 加载有效地址&quot;&gt;&lt;/a&gt;3.5.1 加载有效地址&lt;/h1&gt;&lt;p&gt;地址运算指令写法是lea 作为它的助记符，也就是操作码。由于在x86-64位系统中，地址都是64位。所以一般见到的这条地址运算指令，它的这个尾部的数据格式都是以q 作为后缀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/image-20201015100818384-1602738181388.png&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h1><p>地址运算指令写法是lea 作为它的助记符，也就是操作码。由于在x86-64位系统中，地址都是64位。所以一般见到的这条地址运算指令，它的这个尾部的数据格式都是以q 作为后缀。</p><p><img data-src="/../../images/image-20201015100818384-1602738181388.png"></p><span id="more"></span><p>lea指令是一个双操作数指令，有源操作数和目标操作数。源操作数通常是一个类似于寻址模式的一个4元组, 该4元组用来进行地址表达式的计算。目标操作数通常是一个寄存器, 用来存放算术运算的地址的结果，存放到寄存器里。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><img data-src="/../../images/image-20201015101734108-1602738207739.png"></p><p>地址运算指令，它在设计的初衷的时候，主要是用来去计算像c语言中如<code>p = &amp;x[i]</code>的表达式所对应的一个地址。比如说计算变量x 数组的第 i 的下标所在索引的地址, 赋值给p指针，P存放的是一个地址。计算方法是先算出x 的基地址, 再算出x 中每个元素它的位长, 然后再乘以这个下标i , 得到的就是最后的位置。每个元素的大小, 在高级语言中，通常我们能够见到的就是这四种类型, 就是一字节两字节、四字节或者是八字节。所以在计算的时候, 就是乘以每个数组元素的位长，通常就是这四个数值。</p><p><strong>实例</strong> </p><p><img data-src="/../../images/image-20201015101748755-1602738236543.png"></p><p>在这个具体的这条指令中, D缺省，缺省的时候为D = 0, R<del>b</del>为rdi 寄存器中的值, r<del>i</del>也为rdi 寄存器中的值, S = 2。<br>这样再做一个运算, 是r d i加上r d i 乘以2。和move指令最大的区别是, move指令是把计算后的地址所在的值取出来，放到目标寄存器中。而l e a 指令是把地址算出来, 直接把这个地址赋值给目标的操作数，也就是rax寄存器。换句话说，l e a 指令是不会对内存进行任何访问的。r d i 寄存器是用来存放传入的这个参数x 的。所以这条指令的含义就是x 加上x 乘以2, 然后赋值给r a x 寄存器。所以这个时候r a x 应该是3x。</p><p>接下来执行了一个左移指令, 后面会讲到.</p><p>那么最后得到的就是x 乘以12作为这个函数的返回值. </p><p>在这个实例中, 可以看到本身是一个乘法，一个变量乘以一个常数, 通过编译器转换成汇编语言之后，把它转换成, 1个地址计算指令和1个移位运算指令。因为乘法对于处理器来说，它在计算的时候是一个非常耗时的一个操作, 但是对于基本的运算如加减，基本的移位运算, 它们的运算速度要远远的快于乘法运算的速度. 所以编译器不使用乘法指令去做这样一个x 与常数的相乘, 而是把它转换成很多加法和移位指令的组合。虽然一个乘法指令转换成了两条指令, 但是这两条指令执行的速度, 仍然比一条乘法执行的速度要快的多。所以编译器通常会做这样的一个转换。</p><p>l e a 指令虽然最初在设计的时候, 是做地址计算使用, 但是在编译器实际使用的过程中，因为l e a 指令的特性不做任何内存的访问, l e a 指令通常也被用来去进行一些算术运算, 这也是编译器在编译的时候的一个技巧。而l e a 进行的这个算术运算，可以去模拟一些变量与常数之间的运算, 这也是编译器经常使用的一种技巧。</p><h1 id="3-5-2-双操作数指令"><a href="#3-5-2-双操作数指令" class="headerlink" title="3.5.2 双操作数指令"></a>3.5.2 双操作数指令</h1><p><img data-src="/../../images/image-20201015103556287-1602738257370.png"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>**源操作数和目标操作数相加的结果放到目标操作数里. **由于第二个操作数是目标操作数，所以所有的这些二元操作数的这种指令，最后运算的结果都是放到第二个操作数. 尤其减法这种两个操作数之间是有顺序的运算, 是目标操作数，也就是目标操作数是被减数, 源操作数是减数。减完的结果存到原先被减数所在的位置中去。</li><li><strong>注意区分算数移位和逻辑移位.</strong>  移位指令中间有a, 代表算数移位; 中间有h, 代表逻辑移位.</li><li><strong>源操作数可以是立即数, 寄存器和地址, 目标操作数只能是地址和寄存器.</strong></li><li>在加减乘运算中, 并没有区分有符号运算和无符号运算. 因为加法运算和减法运算本质上是相同的, 加法减法运算和乘法运算对于有符号数和无符号数来讲，在位级别的运算规则也是相似的。</li><li>除法运算分为有符号数除法和无符号除法.</li></ol><h1 id="3-5-3单操作数指令"><a href="#3-5-3单操作数指令" class="headerlink" title="3.5.3单操作数指令"></a>3.5.3单操作数指令</h1><p><img data-src="/../../images/image-20201015104631290-1602738277336.png"></p><p> 看图即可</p><h1 id="3-5-4-算数运算示例"><a href="#3-5-4-算数运算示例" class="headerlink" title="3.5.4 算数运算示例"></a>3.5.4 算数运算示例</h1><p><img data-src="/../../images/image-20201015164049061.png"></p><p>左面是进行了一些复杂表达式的运算，最后把运算的结果rval变量作为返回值返回。<br>传入的参数有3个参数，x, y, z ,通过编译器可以将这段高级语言的语句翻译成汇编语言的指令. </p><p><img data-src="/../../images/image-20201015164449186.png"></p><p>用颜色对高级语言中的表达式进行了一个划分, 通过颜色来去确认对应颜色的高级语言的语句。</p><p>第一条指令是将x 和y 的值相加，存在变量t1中。x 存放在r d i 寄存器中。<br>也就是函数的第一个参数是存放在rdi寄存器中的, 函数的第二个参数是存放在rsi寄存器中,函数的第三个参数是存放在rdx寄存器中。函数的参数的顺序和寄存器之间是由某种固定关系的。在x86的linux操作系统下啊，第一个参数，第二个参数和第三个参数会固定的映射到这三个寄存器中。</p><p>第一个指令是x 和y 相加, 把结果存在t1 变量中，它所对应的汇编指令是使用了一个地址计算指令rdi和r s i 相加, 存放到了rax 里。</p><p>为什么在这儿要用地址计算指令, 而不使用标准的算术运算指令add呢? 用add的效果似乎和这个效果是一样的。一个最主要的原因是add指令, 是两操作数的指令, 也就是在运算之后，必然结果会覆盖掉其中一个操作数的值。表达式中后边的运算, 原来的参数x 的值也要参与其他的运算, 原来参数y 的值也要参与其他的运算。所以如果把第一个x +y 这个指令语句转换成add 指令的话，那么必然x 和y 的值有一个值要被破坏。如果不希望它被破坏，那么我们就需要再用一条move指令把某个被破坏的值提前备份出来。这样就变成了move和add两条指令才能完成第一条语句的工作。而地址预算指令可以在多个寄存器之间完成运算, r d i 的值和r s i 的值相加之后，是会存放到r a x 寄存器中, 这样相当于在这个运算的过程中，既做了加法, 同时把加法的结果又放到了一个新的 寄存器中，不破坏原寄存器的值。使用这样一条指令，相当于使用了一条move指令和另一条add指令。这个是编译器的一个设计巧妙的地方。</p><p>第二条语句是把z 和t1 相加存放到第t2中，z的值存放在rdx寄存器中, rax 里边存放的是t1 的值, 相加完了之后存放到rax 寄存器中。那么这个时候rax 寄存器中存放的就已经是t2的值了。t1的变量就已经不存在了。就这点是否合理而言, 可以从左边的语句来分析一下。t1变量最后一次使用就是在第二句, 也就是说后面不使用t1 这个变量。因此在第二句将t1变量覆盖掉是合理的。这体现了编译器的另外一个功能, 就是在寄存器的使用之间进行调度, 合理的去使用寄存器。</p><p><img data-src="/../../images/image-20201015165930299.png"></p><p>紫色的这两条语句对应的是y 乘以48赋值给t4变量。编译器并没有继续执行t 3的这条语句，而是执行了t 4。y 乘以48和我们之前讲到的地址运算的那个例子相似。它是通过两条指令, 从而替换掉了乘法运算指令, 使得计算加速。</p><p>首先做的是r s i 加上r s i 乘以2。这个过程就是实现了y乘以3。y 乘以3的结果存放到rdx寄存器中。r d x 计算器之前存放的是z 的值, 但是在t 2这条指令之后，再也不会使用到z 这个变量, 所以r d x 寄存器器可以回收被重新利用。下面一行指令做的是将r d x 寄存器左移4位，相当于乘以二的四次方, 等于乘以16。y乘以3，再乘以16就等于y 乘以48。因此，这条指令通过这样一个两条汇编指令就可以实现。</p><p>下一条指令在做的实际上是这第三句t3的语句和第五句t5的指令. x加4, 结果作为t3，然后和t4相加。也就是说，在高级语言中的两条语句, 可能对应到汇编语言中只有一条指令。具体的做法是r d i存放的是, x 的值, r d x 存放的是刚才运算的结果，也就是t 4的值。<br>S缺省就等于1，所以就是x 加上t 4。外面还有D=4，所以是x+t4+4, 等于t 3和t5这两条语句在汇编语言中做了一个合并。因为t3是中间变量可以回收, 所以在这里编译器会把这两条指令, 合并合并成一条地址计算指令就可以得到结果。r c x 计寄存器最终存放的是t 5的结果。</p><p>最后t 2要和t 5做一个乘法, 因为t 2是变量，t 5也是一个变量, 所以这样两个变量相乘，是没有办法把它当成是一个变量，当成一个常数，它进行一个分解。所以在这里不得不使用一个惩罚指令来完成。因为惩罚指令是极其耗时的。而在这里没有办法用其他的方法去降低这时间上的开销。</p><p>r c x 存放的是t 5的值，r x 存放的是t 2的值, 两个相乘的结果放到r a x 寄存器中。<br>这里在c 语言中, 返回值是r va l . 而在汇编值令中呢，调用的过程返回的时候, 就是使用rax寄存器来去保存返回值。这个是在汇编语言中的一个固定的用法，也就是<strong>r a x 计算器作为返回值的存储。</strong></p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>第一个特征就是<strong>c 语言中的语句顺序和编译后生成的汇编指令的顺序不一定是完全一样的</strong>。也就是指令在执行过程中顺序并不是c 语言中的逻辑顺序, 但最终运行结果是相同的, 编译器在这个过程中可能会打乱顺序。</p><p>第二点<strong>c 语言和汇编指令之间并不是一个一对一的关系。</strong><br>某些c 语言的表达式的计算可能映射到汇编语言会被映射成多条指令才能完成, 比如说t 4这个例子会被映射成两条汇编指令。在c 语言中，也有可能多条语句都会映射到某一个指令上, 比如说计算t 3和t5, 虽然在c 语言中是两条语句, 但实际上它对应的是一条汇编指令。</p><p>最后一点, <strong>寄存器中进行运算，要比在内存中读取数据进行运算性能要快得多, 编译器会优先把所有的局部变量放在寄存器中。</strong> 如果我们将这样的一个c 语言的语句直接写成return(x+y+z)×((x+4+y×48)), 最终得到的最终的汇编语言指令是相同的。虽然在计算中使用了很多临时变量, 但是这些局部变量不一定需要在内存中存储。在这个例子中，用了6个临时变量。但是这6个临时变量都是存放在寄存器中。换句话说, 这六个变量不消耗内存。这也就是说不要建立一个固定的认识认为声明了变量就会浪费系统内存, 这个概念是错误的。因为我们的编译器已经足够的聪明，足够的智能, 它可以通过合理的去分配寄存器，让这些局部变量优先存储到寄存器中。</p><p>另外一点, <strong>不要以为写了这样一个表达式直接去替代这样一个函数的结果，就可以实现对程序的优化。这种认识是完全错误的，虽然语句少了, 但是代码最后执行的效率是一样的。</strong>千万不要以为在编程的时候，少用一个局部变量，或者把表达式写的极其复杂，就变成了对程序做了某种优化。实际上这种认识是完全错误的。从这个例子中可以看到，其实我更推荐于我们例子上的这种写法。为什么？因为在例子中，语句多的写法更便于阅读, 更便于其他的人再去阅读你的代码的时候，更容易的去了解这个表达式的具体含义。<br>如果表达式计算的每个步骤，它都是有相应的物理意义或者是现实意义的话，我们可以用一些特殊的变量命名表示出这种目的意义，这样就会很清晰的看懂这个表达式。但是如果你把表达式压缩到表达式非常少, 这可能对于代码的阅读来讲是会很困难。</p><p>换句话说, 语句多的写法和语句少的写法，最后的效果和效率都是一样的。那么哪一种更好呢？当然是对于用户可读性更强的这个代码, 效果会更好。</p><h1 id="3-5-5-逻辑运算示例"><a href="#3-5-5-逻辑运算示例" class="headerlink" title="3.5.5 逻辑运算示例"></a>3.5.5 逻辑运算示例</h1><p>看一个以位的逻辑运算为主的一个例子。</p><p><img data-src="/../../images/image-20201015181444447.png"></p><p>这里面主要使用到了异或(^), 右移(&gt;&gt;), 这个右移主要是算术右移, 因为t1和这个常量17都是有符号数。在C语言语句中还用到了左移和减法, 但是在生成的汇编语言表达式中并没有左移和减法运算。之后还用到了位与运算。rdi 存放的是参数x , rsi 存放的是参数y </p><p>第一步是把rdi 复制到rax 中。第二步, rsi和rax 进行一个异或，异或的结果存放在rax。此时rax寄存器中存放的是 <code>x^y</code>, 即t1的值. 第三步把rax 存储的变量进行算数右移17位 , a 表示算数二表示右移, 对应于C语言的第二个语句. 得到的结果为t2, 因为t1在后面的语句中不会再使用, 第二个语句运行的结果可以存放在rax寄存器中.</p><p>第三步, c语言语句的第三步计算mask在汇编代码中没有体现, 因为mask 的结果本身是一堆常量来去进行的计算, 在这个表达式中不涉及任何的变量, 这也就意味着不管在什么情况下，mask 应该都是一个固定的值。在这条语句执行之后。因此这样的一个左移和减法的计算过程，实际上是由编译器在编译阶段就已经完成计算。计算完mask的十进制为 8185. 第四步, 对t2和mask进行一个位运算得到rval. </p><p><strong>常量与常量之间的运算是在编译器完成的，而不是在运行的时候进行的计算。</strong>这样运行的时候少掉了很多指令, 就增加了运行时的速度。</p><p>最后还有一点, 需要注意的是编译器编译出来发现and助记符后缀为l, l表示这是一个32位的指令。运算双方t2和mask都是64位的变量, 但是这里却是用了一个32位的指令.</p><blockquote><p>背景知识;</p><p>在x86-64位处理器上，如果执行一个32位的指令，意味着最后操作的目标寄存器的高32位会被清0。<br>        深层次的说，这是64位处理器，在设计数据通路的时候, 就是用的这种方法去兼容的32位的指令。</p></blockquote><p>这里的原因如下,  mask 虽然是一个long型(在64位系统中为8字节)的变量, 但是它的高32位的运算结果必然为0。因为整数常量在不做任何说明或增加后缀的时候, 都是以int 型的有符号数常量存在的。所以一个常量运算的结果本身是一个int型 的常量。如果把它赋值给了一个long型的变量。那么在这个过程中会发生一个位扩展。位扩展的时候，由于它是一个正数，所以它高32位在扩展的时候必然为0。高32位为零的mask变量与t2进行位与运算, 结果必定高32位全为0. 也就是说rval的值体现在低32位上.</p><p>在and执行32位指令后, 将最终的结果存储到了eax寄存器. 而eax寄存器就是rax寄存器在低32位上的一个别名, 最终返回的还是rax寄存器中的值.</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3.5_%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 3.7 控制(上)</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8A)_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8A)_url.html</guid>
      <pubDate>Sun, 11 Oct 2020 10:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;3-7-1-过程调用&quot;&gt;&lt;a href=&quot;#3-7-1-过程调用&quot; class=&quot;headerlink&quot; title=&quot;3.7.1 过程调用&quot;&gt;&lt;/a&gt;3.7.1 过程调用&lt;/h1&gt;&lt;p&gt;过程对应于c 语言中就是指的函数。函数相当于是对一系列工作流程所进行的一个抽象, 那么函数调用在高级语言中是一个再常见不过的事情。&lt;/p&gt;
&lt;p&gt;在这一部分主要讨论一下函数调用，也就是对应到汇编语言中的过程在机器级是如何实现的. 如下有两段代码&lt;/p&gt;
&lt;p&gt;一个是P 函数，一个是Q 函数。我们可以看到在P 这个函数中, 调用了Q 这样的一个函数, 实现了一个函数的嵌套调用。在这样的一个嵌套调用中。计算机, 底层主要完成了哪些工作呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/image-20201012081916003-1602738888291.png&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="3-7-1-过程调用"><a href="#3-7-1-过程调用" class="headerlink" title="3.7.1 过程调用"></a>3.7.1 过程调用</h1><p>过程对应于c 语言中就是指的函数。函数相当于是对一系列工作流程所进行的一个抽象, 那么函数调用在高级语言中是一个再常见不过的事情。</p><p>在这一部分主要讨论一下函数调用，也就是对应到汇编语言中的过程在机器级是如何实现的. 如下有两段代码</p><p>一个是P 函数，一个是Q 函数。我们可以看到在P 这个函数中, 调用了Q 这样的一个函数, 实现了一个函数的嵌套调用。在这样的一个嵌套调用中。计算机, 底层主要完成了哪些工作呢？</p><p><img data-src="/../../images/image-20201012081916003-1602738888291.png"></p><span id="more"></span><p> 首先第一点是完成了控制上的一个改变。那么这个过程我们把它叫做控制上的一个传递。也就是程序, 在这个代码片段中执行到某一个位置的时候, 打断了当前的顺序执行, 而切换到另外的一个代码片段进行执行。那在这个代码片段中执行结束之后又会回到刚才结束后的那条语句继续执行, 这个过程中就出现了一个控制上的一个变换, 确切的说就是代码执行地址之间的一个改变和切换。进入到一个新的过程后，从一个过程返回到另一个过程中间都有控制传递的问题。</p><p>第二个问题就是关于数据传递的问题。一个函数调用另一个函数可能需要传给这个函数中一些参数。那这样一些参数是通过什么样的方式，什么样的规则进行传入? 一个函数在返回的时候, 可能会将一些函数计算的结果以返回值的形式返回给原函数。那么在这里边还涉及到一个返回值的问题。所以第二个我们要讨论的就是一个数据怎么传入到过程中, 过程中的数据怎么在传回到原过程中。</p><p>第三个问题就是关于在过程内部如何去管理内存的问题。在这里主要讨论的一个管理内存的基本单位叫做栈针。这个概念在后面还会深入的展开。栈针主要是用来负责管理当前这个过程中所使用到的一些内存。这里就涉及到如何去管理这片内存。第一是这片内存空间如何去分配。比如说在这声明了一个数组，这个数组存储到哪里, 如何去保存数组中的数据。另外一个概念就是当过程返回的时候，它内部的使用的局部变量将会被销毁。那么这一部分局部变量如果有在内存中进行存储的，它又如何去完成这样的一个释放？<br>        这都涉及到内存管理的问题。</p><p>所以以上三方面就是控制的传递，数据的传递以及内存管理. 是我们在过程这一部分所讨论的三个主要的问题。而这些机制, 都是在机器级指令的这样的一个水平上完成的实现。这里讨论也是在汇编语言的水平上去讨论这样的一个高级语言的行为, 在底层是如何实现的。</p><p><strong>该章节全部内容针对x86-64</strong></p><p><img data-src="/../../images/image-20201012083438576-1602738903141.png"></p><h1 id="3-7-2-栈的访问"><a href="#3-7-2-栈的访问" class="headerlink" title="3.7.2 栈的访问"></a>3.7.2 栈的访问</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>下面来讨论一种数据结构, 栈(stack)。栈是计算机中非常重要的一种数据结构。之所以首先去讨论栈这种数据结构, 是因为底层过程的调用是依赖于这样的一种数据结构的。换句话说由于这种结构的重要性, 因此导致了处理器本身是原生支持栈这样一种数据结构的, 它有针对于栈的特殊的操作指令。</p><p>栈是一片位于内存中的连续线性空间。栈底通常位于高地址。栈顶, 也就是数据进出的方向, 位于低地址。栈是从高地址向低地址方向生长的。在通用寄存器中有一个<code>rsp</code> 寄存器, 它有一个特殊的功能，就是用来存放栈顶元素的地址的。</p><p><img data-src="/../../images/image-20201013192800468-1602738926037.png"></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><p>对于栈有两个基本操作, 入栈和出栈。</p><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><p>入栈的指令是<code>pushq src</code>, <code>pushq</code> 是操作码, <code>src</code>是操作数。通常操作数只能是立即数或寄存器。它是一个单操作数的指令。这个指令它的工作可以分为三个步骤。</p><p>第一步, 是将操作数中的数据取出. </p><p>第二步, 将rsp 的值减8，rsp 内部存放的是栈顶元素的地址, 减8标志着栈进行了一个生长，因为栈是向低地址方向进行生长。之所以减8，是因为push q 是一个64位的指令, 通过这个指令操作, 入栈的数据也是一个64位的数据, 也就是一个八字节的数据, 所以要进行一个减8的操作。</p><p>第三步, 将取出的src 中的数据存放到当前更新后的rsp所指向的内存位置中。这样就完成了一个入栈的操作, 入栈是一个原子化的操作，也就是通过这样一条指令就可以完成以下三个部分的内容。</p><p><img data-src="/../../images/image-20201013194006836-1602738938709.png"></p><p>第二个操作是出栈操作<code>pop</code> 。pop 是他的操作码, 它的操作数通常是寄存器, 不可以是立即数。pop 的工作方式也可以把它分解成三步。</p><p>第一步, 根据当前的rsp 寄存器中指向的地址，从这个地址中取出数据。</p><p>第二步，将取出的这个数据放入到对应的操作数中。</p><p>第三步, 将rsp 寄存器的值加8, 完成了一个栈的收缩过程。这里面可以看到, 没有任何删除数据的工作, <code>pop</code>指令只是将数据取出，放到操作数中。其实在对应的位置应该还保存着原先的数据. 但是我们要知道rsp指向的是当前栈的栈顶元素。通过rsp加8的操作，保证了栈的边界的一个收缩。这个时候就意味着虽然原先的数据在内存中还存在。但是它已经位于栈的外部了。换句话说，也就是这个位于栈的外部的内存已经被回收了, 未来栈再次生长的时候，将会覆盖掉这片空间。这样就完成了一个出栈的操作。</p><p><img data-src="/../../images/image-20201013193952013-1602738974660.png"></p><h1 id="3-7-3-控制传递"><a href="#3-7-3-控制传递" class="headerlink" title="3.7.3 控制传递"></a>3.7.3 控制传递</h1><p>接下来讨论一下过程调用的过程中是如何发生控制传递的. </p><p>在过程调用中的控制传递，需要借助于之前所讨论到的栈这个数据结构, 用来实现过程的调用和传递。它主要所使用的两条指令是<code>call</code>指令和<code>return</code> ，也就是<code>ret</code> 指令。</p><p><code>call</code>指令</p><p>这条指令是过程调用指令。它的操作码是call，他的操作数是一个标签，也就是对应的过程的入口地址。过程调用指令, 它在执行的时候主要进行了两个工作。首先是把过程调用后过程的返回地址压入栈中, 第二是跳转到标签所指定的位置执行下一条指令。</p><p><img data-src="/../../images/image-20201013194841318-1602738990679.png"></p><p>可以看到这里最重要的一个信息就是将返回地址首先压入栈中。那么返回地址是什么呢？实际上就是call这条指令，接下来的那条指令的位置, 也就是在call指令后面的那条指令，它所在的地址就是返回地址，也就是对应的这个标签的过程，执行完毕之后再返回，就是要执行这条call指令下边的那条指令所在的位置。</p><p>跳转的过程和跳转指令非常类似。它就是将程序的指令计数器也就是<code>rip</code>寄存器设置为了对应目标标签位置地址的值, 这就完成了这样的一个调整。</p><p>下面我们来看过程返回指令return ，也就是<code>ret</code> 指令。</p><p><img data-src="/../../images/image-20201013195806578-1602739003957.png"></p><p>它做的也是两件事。第一件事是从栈顶将返回地址弹出, 并以这个返回地址作为目标地址，再次完成一个跳转。<br>所以call指令和<code>ret</code> 指令都要进行跳转, 只不过是他们在跳转之前, 要对栈进行一些操作. call是要将返回地址入栈。<code>ret</code> 是要将返回地址出栈并进行调整。实际上我们还可以把<code>ret</code> 指令理解为返回地址出栈。出栈到哪个位置? 出栈到<code>rip</code> 寄存器中，这样<code>ret</code> 指令执行完之后，就会从新的位置加载指令。</p><h2 id="下面是一个过程调用的实例"><a href="#下面是一个过程调用的实例" class="headerlink" title="下面是一个过程调用的实例"></a>下面是一个过程调用的实例</h2><p><img data-src="/../../images/image-20201013195941992-1602739030125.png"></p><p>上面定义了multstore 函数。在multstore 这个函数里边调用了mult2 函数。mult2 函数就是将两个变量相乘，并且将结果返回。右面是这两条指令所对应的反汇编程序。</p><p>这里面要说明一些的就是由于反汇编工具，使用的是objectdamp , 所以它反汇编出来的汇编语言的操作码和之前所讲到的汇编程序的操作码有的时候会有一些细微的区别。比如说push 后面没有加q , 其实它是等加于pushq 的。move也是一样。这个callq 和retq 就等价于我们刚才的call指令和<code>ret</code> 指令, 只不过是它在写法上的不同，实际上它的本质是等价的。</p><p>首来看在multstore 中去调用mult2 这个函数发生了什么。它首先通过call指令指向了mult2 的标签。那么在机器指令级别mult2 这个标签会被转换成一个地址, 也就是mult2 这个指令的一个目标位置。当前状态下，假设<code>rsp</code> 寄存器也就是栈顶的地址为0x120即将要在执行call之前<code>rip</code> 这个寄存器的存储的地址应该是call这条指令的地址即<code>0x400544</code>, 这是在执行call这条指令即将要执行之前当前的处理器的状态。</p><p><img data-src="/../../images/image-20201013201233306-1602739041725.png"></p><p>当call指令开始执行的时候, rsp 寄存器就会由于call指令所导致出现了一个入栈的操作。入栈首先是要<code>rsp</code> 寄存器减8，然后把数据放进去。这个时候放入的数据是哪个数据？放入的数据是返回地址，也就是call指令的紧接着的这条指令的地址就是0x400549,<br>放到栈中. 紧接着call指令还要做另外一件事，就是将<code>rip</code> 寄存器设置为mult2 。mult2 这个过程的入口地址是0x400550。因此，call这个指令完成之后，<code>rip</code> 寄存器的值应该变成了0x400550。那么接下来即将要执行的这条指令就是mult2 中的第一条指令，也就是这条move指令. </p><p><img data-src="/../../images/image-20201013201726103-1602739052283.png"></p><p>过程返回的时候发生了什么?在即将执行过程返回指令，也就是return 这条指令之前。<code>rip</code> 寄存器的值应该是0x400557，表示这条指令即将被执行。<code>rsp</code> 寄存器的值存放的还是栈顶地址。在过程返回时, <code>rsp</code> 寄存器和刚进入过程之前的时候<code>rsp</code> 寄存器的值应该指向的都是压入的返回地址的那个元素所在的位置。接下来<code>ret</code> 指令执行。它要做的一件事就是将栈顶的数据弹出。这个数据弹出的地址就是<code>ret</code> 指令返回的地址, 也就是这个数据弹出被加载到了<code>rip</code> 寄存器里。那么<code>ret</code> 指令执行完毕，接下来即将要执行的指令的地址就是0x400549这个地址。这样就完成了一个过程的返回。</p><p><img data-src="/../../images/image-20201013201929109-1602739063821.png"></p><h1 id="3-7-4-数据传输"><a href="#3-7-4-数据传输" class="headerlink" title="3.7.4 数据传输"></a>3.7.4 数据传输</h1><p>在过程调用中，如何相互在过程之间传输数据？</p><p>这主要就包括两方面的内容，一个是过程调用时如何传入参数。另一个内容就是在过程返回的时候，如何将返回值传出？</p><h2 id="过程调用时传入参数"><a href="#过程调用时传入参数" class="headerlink" title="过程调用时传入参数"></a>过程调用时传入参数</h2><h3 id="x86-64系统"><a href="#x86-64系统" class="headerlink" title="x86-64系统"></a>x86-64系统</h3><p>在x86-64系统中。参数的传递是优先使用寄存器来去完成传递的。对于过程的前六个参数都是要放到寄存器中的。剩余的参数将会使用栈来去传递。</p><p>在前六个参数中，第一个参数使用rdi 寄存器，第二个参数使用rsi 寄存器。然后是rds，rcx, r8, r9。这是按照这样的一个顺序来去把对应的参数放在规定好的寄存算器内。<br>这种规定方法是在x86-64系统linux 操作系统下使用gcc 编译器的调用规范, 对应的在linux 系统下，其他的编译器也遵循这样的规范。但是不同的操作系统之间，它的规范稍微有一些出入。比如说在windows 系统上, 它也是将其6个参数使用寄存器来传递, 但是这6个寄存器和寄存器的顺序, 是有区别的.</p><p>对于超出6个以上的这些参数是在栈中进行传递的。在栈中参数的分布规则是最后一个参数最靠近于栈底, 也就是说最后一个参数应该位于这些参数中地址最高的位置上, 也就是最后一个参数，最先入栈, 然后是第n-1个n-2个，一直到最后是第8个第7个。第7个参数应该是在栈的顶部。这是在x86-64位系统中过程参数的传递规范。这里特别强调一点是在x86-64位处理器上采用这样的一种方式去传递的。</p><p><img data-src="/../../images/image-20201013204645921-1602739103193.png"></p><h3 id="x86-32位系统-仅作了解"><a href="#x86-32位系统-仅作了解" class="headerlink" title="x86-32位系统(仅作了解)"></a>x86-32位系统(仅作了解)</h3><p>在x86-32位系统中，是完全使用栈来去传递参数，而不使用寄存器。因为在x86-32位处理器中, 是没有r8到215这样8个通用寄存器的, 也就是x86-32位系统的通用寄存器要比64位处理器中的通用寄存器要少一半。它没有足够的通用寄存器来去传递参数, 所以完全都使用栈了去传递。</p><h3 id="寄存器传递参数的优点"><a href="#寄存器传递参数的优点" class="headerlink" title="寄存器传递参数的优点:"></a>寄存器传递参数的优点:</h3><p>用栈去传递参数，使用这些参数，将会首先进行内存的访问。而在寄存器中的参数访问起来速度更快，不需要涉及内存。所以如果参数比较少, 那么这些参数是会优先都放在寄存器中，这样可以提高整个程序在执行时的性能。</p><h2 id="过程调用时返回参数"><a href="#过程调用时返回参数" class="headerlink" title="过程调用时返回参数"></a>过程调用时返回参数</h2><p><strong>返回值仅仅使用rax 寄存器来去保存</strong>。这也就决定了在c 语言和类似于c++语言中这样的程序中, 函数的返回值只能有一个，而不能有多个。比如说某些脚本语言，它可以返回类似于元组之类的数据类型。在c语言和c++语言中是不行的，它只能返回一个数据。就是因为C和C++的返回值只使用一个寄存器去保存。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img data-src="/../../images/image-20201013205621146-1602739118096.png"></p><p>multstore 这个过程本身有3个参数。这三个参数第一个参数是x 。x是存在rdi寄存器里, y是存在rsi寄存器里, dest这个指针是存在rdx这个寄存器里。</p><p>在 multstore 去调用mult2这个过程之前, 并没有对rdi 和rsi 这两个寄存器做任何的复制。这样也就意味着在调用mult2的时候, 就是将multstore 的x 的变量和y 变量直接传到mult2中, 并作为mult2 的变量a 和变量b 来去进行运算。运算的过程，它使用了一条乘法指令，实现了a乘以b。</p><p>a是保存在rax 寄存器里，b是存在rsi 寄存器里。a乘以b 的结果，最后要存到rax寄存器里。最后return 返回。那么返回值就是存在rax 寄存器.</p><p>当mult2 返回的时候会回到call指令的下一条指令继续执行。call指令的下一条指令就是将rax 移动到rbx 所指向的那个地址中去。call指令之前，首先做了一个操作，是将r d x 的值放入到r b x 中。也就是说r b x 中的值就是dest 这个指针所指向的地址, 就是将mult2 的乘法结果存入到dest这个指针所指向的那片内存中。这样就完成了一个将mult 2的返回值赋值给在这个指针指向这个地址的过程。</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8A)_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020_10_record</title>
      <link>http://zhangchunxian.github.io/posts/2020_10_record_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/2020_10_record_url.html</guid>
      <pubDate>Sun, 11 Oct 2020 09:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;显示隐藏文件夹&quot;&gt;&lt;a href=&quot;#显示隐藏文件夹&quot; class=&quot;headerlink&quot; title=&quot;显示隐藏文件夹&quot;&gt;&lt;/a&gt;显示隐藏文件夹&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ls -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如.git&lt;/p&gt;
&lt;h2 id=&quot;Vim-粘贴会因为编辑器内置的‘智障’缩进从而形成乱码&quot;&gt;&lt;a href=&quot;#Vim-粘贴会因为编辑器内置的‘智障’缩进从而形成乱码&quot; class=&quot;headerlink&quot; title=&quot;Vim 粘贴会因为编辑器内置的‘智障’缩进从而形成乱码&quot;&gt;&lt;/a&gt;Vim 粘贴会因为编辑器内置的‘智障’缩进从而形成乱码&lt;/h2&gt;&lt;h1 id=&quot;Visual-Studio&quot;&gt;&lt;a href=&quot;#Visual-Studio&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio&quot;&gt;&lt;/a&gt;Visual Studio&lt;/h1&gt;&lt;h2 id=&quot;vs设置语言&quot;&gt;&lt;a href=&quot;#vs设置语言&quot; class=&quot;headerlink&quot; title=&quot;vs设置语言&quot;&gt;&lt;/a&gt;vs设置语言&lt;/h2&gt;&lt;p&gt;在Visual Studio中，点击**”工具”–&amp;gt;”选项”–&amp;gt;”环境”–&amp;gt;”区域设置”–&amp;gt;”语言”**[&lt;a href=&quot;https://zhuanlan.zhihu.com/p/120183174#ref_1&quot;&gt;1]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;visual-studio-调试&quot;&gt;&lt;a href=&quot;#visual-studio-调试&quot; class=&quot;headerlink&quot; title=&quot;visual studio 调试&quot;&gt;&lt;/a&gt;visual studio 调试&lt;/h2&gt;&lt;p&gt;按F9设置断点, F5从断点处开始执行语句, F10从断点处一步一步执行代码.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="显示隐藏文件夹"><a href="#显示隐藏文件夹" class="headerlink" title="显示隐藏文件夹"></a>显示隐藏文件夹</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><p>如.git</p><h2 id="Vim-粘贴会因为编辑器内置的‘智障’缩进从而形成乱码"><a href="#Vim-粘贴会因为编辑器内置的‘智障’缩进从而形成乱码" class="headerlink" title="Vim 粘贴会因为编辑器内置的‘智障’缩进从而形成乱码"></a>Vim 粘贴会因为编辑器内置的‘智障’缩进从而形成乱码</h2><h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><h2 id="vs设置语言"><a href="#vs设置语言" class="headerlink" title="vs设置语言"></a>vs设置语言</h2><p>在Visual Studio中，点击**”工具”–&gt;”选项”–&gt;”环境”–&gt;”区域设置”–&gt;”语言”**[<a href="https://zhuanlan.zhihu.com/p/120183174#ref_1">1]</a></p><h2 id="visual-studio-调试"><a href="#visual-studio-调试" class="headerlink" title="visual studio 调试"></a>visual studio 调试</h2><p>按F9设置断点, F5从断点处开始执行语句, F10从断点处一步一步执行代码.</p><span id="more"></span><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><ol><li><p>C语言中清屏操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">// 必须头文件</span></span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>)   <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure></li><li><p>程序执行暂停操作</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10</span>)<span class="comment">// sleep函数中填暂停时间, 单位: ms</span></span><br></pre></td></tr></table></figure></li><li><p>不需要回车就可以得到输入字符(scanf需要输入回车)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line">input = getch()<span class="comment">// 用input变量来接受输入的字符</span></span><br></pre></td></tr></table></figure><p>注: visual studio需要输入 _kbhit</p></li><li><p>kbhit函数, 在用户右键盘输入时返回1, 否则返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(kbhit())<span class="comment">// 判断是否右键盘输入</span></span><br></pre></td></tr></table></figure><p>注: visual studio需要输入 _kbhit</p></li></ol><p>C语言实现四舍五入到int类型语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = (int)(a + 0.5);</span><br></pre></td></tr></table></figure><p>C语言中用乘法的话, 优先使用库函数, 因为自己磨的轮子没有C语言库的好</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/2020_10_record_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP_3.7_控制(下)</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8B)_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8B)_url.html</guid>
      <pubDate>Sun, 11 Oct 2020 02:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;3-7-5-1-栈上的局部存储&quot;&gt;&lt;a href=&quot;#3-7-5-1-栈上的局部存储&quot; class=&quot;headerlink&quot; title=&quot;3.7.5(1) 栈上的局部存储&quot;&gt;&lt;/a&gt;3.7.5(1) 栈上的局部存储&lt;/h1&gt;&lt;h2 id=&quot;语言特性角度的过程存储管理问题&quot;&gt;&lt;a href=&quot;#语言特性角度的过程存储管理问题&quot; class=&quot;headerlink&quot; title=&quot;语言特性角度的过程存储管理问题&quot;&gt;&lt;/a&gt;语言特性角度的过程存储管理问题&lt;/h2&gt;&lt;p&gt;接下来我们讨论一下过程中的存储管理问题。首先我们先从语言特性的角度上去分析这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/image-20201013212326391-1602738675000.png&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="3-7-5-1-栈上的局部存储"><a href="#3-7-5-1-栈上的局部存储" class="headerlink" title="3.7.5(1) 栈上的局部存储"></a>3.7.5(1) 栈上的局部存储</h1><h2 id="语言特性角度的过程存储管理问题"><a href="#语言特性角度的过程存储管理问题" class="headerlink" title="语言特性角度的过程存储管理问题"></a>语言特性角度的过程存储管理问题</h2><p>接下来我们讨论一下过程中的存储管理问题。首先我们先从语言特性的角度上去分析这个问题。</p><p><img data-src="/../../images/image-20201013212326391-1602738675000.png"></p><span id="more"></span><p>现今大多数的编程语言都是支持递归的, 比如说C语言，C++，java c# 等等。这些可以支持递归的语言的一个最基本的要求是需要代码可以重入, 也就是一个过程或者一个函数在调用没有返回之前被再次调用, 能够实现可重入就决定了这个代码内部所使用的局部变量是不能在各个相同的过程调用的实例中共享的, 也就是这个过程在同一时刻可能调用了多次，但是每个过程都有他自己的过程的实例。内部的状态在每个过程之间也是不相同的，也就是它使用的一些变量之类的也是不同的。</p><p>这就需要有一个特殊的空间为每个过程实例去存储它的状态。这个状态都包含什么呢？比如说这个过程在调用的时候，它的参数, 可重入的每个过程可能它调用的参数都是不同的, 所以参数就是表示这个过程的状态的情况的一个因素。除此之外，过程内部所定义的一些局部变量也用来描述过程的状态, 还有就是返回地址。虽然过程可重入，但并不意味着每个过程的返回地址都是相同的位置。它也是过程在去运行的时候，这个过程实例的一种状态。</p><h2 id="过程调用与栈"><a href="#过程调用与栈" class="headerlink" title="过程调用与栈"></a>过程调用与栈</h2><p>那么基于这样一个特性，我们在结合着栈这样的一个数据结构，可以有一个什么样的结论呢？</p><p>过程的状态啊本身是有一个生命周期的概念。就是当过程调用的时候, 这些过程的状态被创建出来，用于存储过程的状态。当过程返回的时候，这些状态就可以释放掉。它存在着这样的一个生命周期，就是调用时创建返回时销毁。</p><p>从另一个角度上看过程的调用是什么样子呢？是调用者(<code>caller</code>)。在内部调用被调用者(<code>callee</code>), 就是一个过程去调用另一个过程。那被调用的过程, 是要先于调用者返回。</p><p>换句话说，多个过程嵌套调用。最后一个返回的过程应该是最开始的那个过程。最先返回的过程一定是最后被调用的过程。这样的一个特性和栈的特性是非常相似的。因为<strong>栈的特点也是先入后出后入先出</strong>。</p><p><img data-src="/../../images/image-20201013212914555-1602738697092.png"></p><p>了解了过程调用的特点和栈的特点，把它们结合在一起，就可以发现。将栈与过程调用结合在一起是一个非常完美的结果, 可以把每个过程实例的状态存储在栈上。因为它都是先入后出的特点。所以栈可以和过程非常完美的结合在一起。存储在栈中的这些过程的状态。在这里边叫做帧(“Frames”), 也把这个帧叫做栈帧。</p><h2 id="实例-——-栈帧的形成和销毁"><a href="#实例-——-栈帧的形成和销毁" class="headerlink" title="实例 —— 栈帧的形成和销毁"></a>实例 —— 栈帧的形成和销毁</h2><p><img data-src="/../../images/image-20201013213227007-1602738710546.png"></p><p>这里面我们给出了一个程序, 这个程序由中包含着3个函数。就是yoo, who和amI函数. 它们之间可以形成这样的一个调用关系, 就是在yoo函数中调用who函数，在who函数中要做两次amI函数的调用。第一次amI函数的调用会进行一个递归。递归一共有3层, 然后返回. 返回后再进入第二个amI的函数, 但是这个函数不会形成递归, 然后返回。</p><p><img data-src="/../../images/image-20201013213617686-1602738722325.png"></p><h3 id="实例过程分析"><a href="#实例过程分析" class="headerlink" title="实例过程分析"></a>实例过程分析</h3><p><strong>PS: 每段文字所对应的图片都是上方的第一张图片</strong></p><p><img data-src="/../../images/image-20201013214016571-1602738736863.png"></p><p>首先程序进入到yoo函数。这个时候在栈中会为yoo函数分配一个栈帧。<code>rsp</code>指向的是栈的顶部元素，目前指向的也就是yoo元素的顶部的位置。</p><p>rbp 是在某些情况下也是一个具有特殊作用的寄存器, 它用来去指向当前这个栈帧的底部。但是在最新版本的x86-64位gcc编译器中，rbp已经没有了这样的一个特殊作用。它只可以向其它寄存器一样啊，作为通用寄存器正常使用, 没有为它赋予特殊的功能。但是通过某些编译选项的设置，rbp 仍然可以让它指向栈的底部。</p><p><img data-src="/../../images/image-20201013214045211-1602738753512.png"></p><p>接下来在yoo函数中调who函数。进入who函数会为who函数分配一个栈帧。<code>rsp</code>和<code>rbp</code> 指向了who函数的栈帧顶部和栈帧底部。当然<code>rsp</code>指向的who函数的栈帧顶部也是整个栈的顶部。</p><p><img data-src="/../../images/image-20201013214444291-1602738763643.png"></p><p>在who函数中调用amI 函数在为amI 函数分配栈帧。rst 和rbp 进行了更新。amI 函数在第一次调用的时候要进行三次递归, 所以amI函数要重入3次，在栈上也是有对应的amI函数的三个栈帧。</p><p><img data-src="/../../images/image-20201013214511006-1602738774982.png"></p><p>当最内部的amI 函数开始返回的时候，这个时候栈中的相应的栈帧也要会被释放。<br>最后返回who函数.</p><p><img data-src="/../../images/image-20201013215024029-1602738792255.png"></p><p>这个时候开始调用who函数的第二个amI 函数再次为它分配栈帧。</p><p><img data-src="/../../images/image-20201013215118990-1602738804294.png"></p><p>这个amI 函数没有进行递归，直接返回回到了who函数。再一次栈帧释放。</p><p><img data-src="/../../images/image-20201013215156043-1602738815122.png"></p><p>who函数执行完成之后，who函数栈帧释放. 最后yoo函数执行完成之后，yoo函数的栈帧也会从栈帧释放。这就是栈帧与函数调用之间的这样的一个过程。</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3_7_%E6%8E%A7%E5%88%B6(%E4%B8%8B)_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 3.6 控制结构(上)</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8A)_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8A)_url.html</guid>
      <pubDate>Sat, 10 Oct 2020 10:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;3-6-1-条件码&quot;&gt;&lt;a href=&quot;#3-6-1-条件码&quot; class=&quot;headerlink&quot; title=&quot;3.6.1 条件码&quot;&gt;&lt;/a&gt;3.6.1 条件码&lt;/h1&gt;&lt;p&gt;条件码是处理器中的一些特殊标志位.&lt;/p&gt;
&lt;p&gt;首先从程序员的角度上去看一下处理器。假设一个程序正在处理器上运行, 那么这个程序当前的状态,可以通过处理器中的一系列信息可以表示出来。那么这些处理器就是所有对于程序员可见的处理器, 以及一些标志位组成的。&lt;/p&gt;
&lt;p&gt;之前所谈到的 16个通用寄存器。在寄存器中大量的寄存器被用于表示当前程序中所使用到的一些局部变量, &lt;/p&gt;
&lt;p&gt;除此之外，还有两个特殊的寄存器，一个是&lt;code&gt;rsp&lt;/code&gt; 寄存器，它表示当前这个程序运行时的栈的顶部地址。还有一个寄存器，就是程序计数器。在x86-64位系统中叫做&lt;code&gt;rip&lt;/code&gt; 寄存器。这个寄存器中存放的是当前所执行的这条指令的下一条指令, 也就是接下来要执行的那条指令的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/image-20201011211824400-1602738474650.png&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="3-6-1-条件码"><a href="#3-6-1-条件码" class="headerlink" title="3.6.1 条件码"></a>3.6.1 条件码</h1><p>条件码是处理器中的一些特殊标志位.</p><p>首先从程序员的角度上去看一下处理器。假设一个程序正在处理器上运行, 那么这个程序当前的状态,可以通过处理器中的一系列信息可以表示出来。那么这些处理器就是所有对于程序员可见的处理器, 以及一些标志位组成的。</p><p>之前所谈到的 16个通用寄存器。在寄存器中大量的寄存器被用于表示当前程序中所使用到的一些局部变量, </p><p>除此之外，还有两个特殊的寄存器，一个是<code>rsp</code> 寄存器，它表示当前这个程序运行时的栈的顶部地址。还有一个寄存器，就是程序计数器。在x86-64位系统中叫做<code>rip</code> 寄存器。这个寄存器中存放的是当前所执行的这条指令的下一条指令, 也就是接下来要执行的那条指令的地址。</p><p><img data-src="/../../images/image-20201011211824400-1602738474650.png"></p><span id="more"></span><p>除了这些信息之外,还有一些标志位,也用来表示当前处理器的状态,那么这些状态也是非常重要的,如果要让处理器正常的工作，正常的执行程序，这些标志位是必不可少的。这些标志位存放在处理器的一个叫做标志寄存器的专用寄存器中, 标志寄存器是不能通过汇编语言指令直接访问,但是可以间接的修改标志寄存器和间接的访问标志寄存器。</p><p>标志寄存器中,包含着一些bit,其中每个bit都有它各自的含义。在这里面我们主要讨论最重要的四个标志位。这四个标志位也把它叫做条件码, 分别是CF, ZF, SF和OF.</p><p><img data-src="/../../images/image-20201011212037093-1602738504868.png"></p><p><img data-src="/../../images/image-20201011212414609-1602738526768.png"></p><p><code>CF</code> 是表示进位标志位。它是对于无符号数而言的, 也就是对于无符号数的两个数进行运算, 如果产生了进位，或者是借位, 这个时候, <code>CF</code>这个标志位会被置1。无符号数出现进位或者借位，就意味着无符号运算出现了溢出。</p><p><code>SF</code>是符号标志位, 针对于有符号数, 是表示当前指令运算的结果的符号，它的符号也就是这位和当前指令运算后得到的结果的符号位是一致的。如果运算后的结果为非负数, 那么<code>SF</code>标志位为0, 如果为负数, <code>SF</code>标志位为1。</p><p>第三个标志位叫做<code>ZF</code> , 它是零标志位。当运算的结果为零的时候，<code>ZF</code>的标志位会被置1。</p><p>最后一个标志位<code>OF</code>。溢出标志位, 溢出标志位是针对于有符号数运算而言的。有符号数运算, 它有可能出现溢出，而不是进位。溢出有一些条件可以判断它。如果对于两个数，如果把它们看作是有符号数，它们在运算的时候产生了溢出。那么溢出标志位则会被置位。标志位被置位有两种方法可以进行，一种叫做隐式置位。另外一种叫做显示置位。隐式置位是通过运行一些算术运算指令之后, 可能会对这些标志位进行置位。</p><h2 id="隐式置位-Implicitly-set"><a href="#隐式置位-Implicitly-set" class="headerlink" title="隐式置位(Implicitly set)"></a>隐式置位(<code>Implicitly set</code>)</h2><p><img data-src="/../../images/image-20201011213019033-1602738555592.png"></p><p>比如说有一条指令<code>addq</code> 。源操作数和目标操作数进行运算。这实际上就是做了一个两个操作数之间相加，并且把它的和复制给目标操作数这样一个过程。那么每当执行一个算术运算或者逻辑运算指令的时候, 都有可能导致这些标志位的变化, 也就是指令运算后的结果，会影响标志寄存器。</p><p>那这里可能会有一个最大的问题, <code>ZF</code>标志位比较容易理解。剩下这些标志位与有符号数和无符号数有关, 但是在处理器去执行汇编指令的时候, 它操作的是寄存器，操作的是内存。寄存器和内存中到底存放的是有符号数还是无符号数呢？实际从汇编语言的角度上是不清楚的。那么这些标志位怎么去置位呢？标志位在置位的时候，实际上是把结果既看做了有符号数，也看做了无符号数。也就是, 假设两个寄存器中的值相加, 如果是无符号数，它会不会有进位？如果有进位<code>CF</code> 就会被置位。如果把这两个寄存器中存放的数字看作是有符号数。那么它会不会溢出？如果会溢出, 它的溢出标志位就会置位。那么还要看最高位，如果是无符号数无所谓。如果要是把这个数看作是一个有符号数，如果它前面有符号位, 那还要根据符号位的值去置<code>SF</code> 。也就是说最后运算出的结果，既把它当做无符号数，也把它当做有符号数。 无符号数如果要是相关的标志位满足条件的话，会置位. 有符号数，满足相关条件的话，对应的标志位也就是条件码会被置位。</p><p>溢出标志位，它在什么情况下会被置位?就是当a 和 b 都大于零的时候, 运算的结果小于0。这个时候是必然会被置位的。另外还有一种情况就是a 和b 都小于0, 运算的结果大于0, 这个时候溢出标志位也会置位。也就是溢出的条件就是, 两个加数, 它的符号位。和和的符号位不同, 这个时候就会被置位。</p><p><img data-src="/../../images/image-20201011214135849-1602738580755.png"></p><p>当然除了加法运算之外, 减法运算、乘法运算以及其它的一些位运算每经历一条指令, 这条指令的效果都会导致这些标志位被置位或者是被复位，也就是被置为1或者置为0。</p><p>那么在算术运算和逻辑运算指令中，<strong>有一条指令是不会影响条件码的, 这条指令就是地址计算指令。</strong>(<code> NO set by leaq instruction</code>)也就是地址计算这几个指令执行之后，条件码是不会有任何变化的。不管它是否进位是否溢出，是否为0等等。</p><h2 id="显式置位-Explicit-set"><a href="#显式置位-Explicit-set" class="headerlink" title="显式置位(Explicit set)"></a>显式置位(<code>Explicit set</code>)</h2><p><img data-src="/../../images/image-20201015192237287.png"></p><p>显式置位就是用汇编语言中一些专门的指令去修改条件码的值. 这些指令本身运算完是不会去修改操作数的。但是这些指令运算之后会影响条件码的值。</p><h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>比如cmp 这条指令, 它是对两个操作数进行比较。其实这个比较的过程和减法的过程非常像，也就是cmpq 这条指令和subq 这条指令非常像。它是把目标操作数减去源操作数得到一个差, 这个差的结果就会影响对应的条件码, 也就是说影响对应的标志位。但是算完的这个差不会去修改参与运算的这两个操作数。所以说它和减法运算的结果最大的不同之处是在于减法运算之后会把差放到目标操作数里。但是在 cmp 这个指令中会做减法，但是不会存放结果, 所以这条指令呢，可以认为它就是做一个比较的指令，怎么做呢？src1减去src 2。那减完了之后，可以根据符号标志位也就是<code>SF</code>和零标志位<code>ZF</code>去判断src1 和src 2 里存放的这两个数之间的关系。如果减完为负数，说明小于。如果减完了符号位为0，这个时候还需要查看0标志位。如果零标志位为1，那说明是等于。如果零标志位不为1为0，那说明是大于。那就通过这样的一个方法就可以实现这两个操作数据之间的比较。当然在这个运算的过程中也会影响进位标志位和溢出标志位。但是在通常使用的时候，使用c m p 指令之后主要观测的就是<code>ZF</code>和<code>SF</code>这两个标准。</p><h3 id="testq指令"><a href="#testq指令" class="headerlink" title="testq指令"></a>testq指令</h3><p><img data-src="/../../images/image-20201015194112213.png"></p><p>另一个可以用于显示对这些条件码进行置位的指令是testq 。testq这条指令非常像andq ，andq处理指令是按位与运算, 但是andq 会把与的结果放到对应的目标操作数中。testq它不会去存放结果, 但是它运算的结果会影响标志寄存器。</p><p>testq可能会影响到的标准寄存器只有<code>ZF</code> 和<code>SF</code> 。因为位与运算是不会影响进位和溢出的。通常用testq 检查某个操作数中的某一位是否为0, 相当于一个操作数里存放的是一个数据, 另一个操作数里存放的是一个掩码。比如说检测src1源数据中最低位是否1, 那这个掩码就可以写成1, 那么它们两个与运算就是看如果最低位为1的话，那么与出来结果就是1就是非零的; 如果最低位为0，他们两个与完必然为零, 这样就可以检测最低位的情况。所以testq主要是用来进行一个掩码的检测, 当然这种方式呢还可以做更多位的同时检测. </p><h1 id="条件码的访问"><a href="#条件码的访问" class="headerlink" title="条件码的访问"></a>条件码的访问</h1><p>条件码是不能够直接被修改.  就像使用move指令直接给某个寄存器赋值, 对于条件码是无法实现的。条件码的修改只能通过算术运算或者逻辑运算指令, 间接的显示或者是隐式的完成条件码的修改。同样, 访问条件码也没有像move这样的指令可以直接访问, 它也是需要间接的来去完成访问。这些指令就是一组指令, 就是set 这一组的指令是可以去访问条件码的。</p><h2 id="SetX-Instructions"><a href="#SetX-Instructions" class="headerlink" title="SetX Instructions"></a>SetX Instructions</h2><p>set这一组的指令是一个8位的指令。这个指令的格式是set作为操作码后面接着一个寄存器，这个寄存器应该是一个8位的寄存器。set这一组的指令如图所示</p><p><img data-src="/../../images/image-20201015194841249.png"></p><p>可以在这组指令中看到，不是每条指令都能够读对应的标志寄存器或者叫做条件码的值，而是条件码通过某种运算之后得到的值，可以用set 指令可以得到。</p><p>比如说第一条指令sete。它是用来访问零标志位, 如果零标志为1，它通过这个sete 的指令可以实现将对应的这个8位寄存器的最低位置1, 高7位置0这样的一个效果, 后面的这些set 指令也是一样, 都是用来将这8位寄存器的最低位置0或者置1. 置0还是置1，是基于条件也就是一个个位运算的逻辑表达式。<br>        有一个简单的方法用来记忆这些指令, 是根据英文名称的缩写. sete 是什么？sete 是前面用c m p 指令去比较的这两个操作数。如果是相等的话，sete 这条指令就会将对应的这个低八位这个寄存器的最低位置1, 也就是e 表示的是equal, 两个操作数相等就会置1。setne 呢就是当<code>CF</code> 为零的时候置1, 也就是not equal 的时候, sets 是设置符号位也就是说，如果对应这个符号为负, 那么sets 会将这这个寄存器置1。setns 就是不为负的时候置1。</p><p>下面的这几个指令setg, setge, setl, setle, 这4个set指令是用来去做有符号数的比较的。首先我们来看setg , setg这个g 就是greater 的首字母, 意味着比较的是两个有符号数是否一个大于另一个, 那么setge是greater or equal, 就是大于等于, 相对于大于来讲，就是把判零的这样一个条件去掉了, 也就是说要么符号位为0且不溢出, 要么就是说符号位为1且溢出了。小于呢？是setl,  less的首字母l 。它在做判断的时候和setge 正好是相反的, 就是把g e 的这个取反去掉了。setle和setg正好是取反, 这样呢就是4条对于有符号数的判断.</p><p>最后这两个是基于无符号数运算如果要去判断大于和小于的方法。set a , a就是above 就是大于, 大于是当没有进位, 其实这里边的进位其实上是表示借位的意思, 且不为零的时候, 这个时候是above 。那么set b 呢是below的意思, 这是判断两个无符号数相减, 如果出现了进位, 无符号数减法如果出现了进位实际上是借位。如果出现了借位, 那么就是小于的意思。所以可以用这种方法就可以去理解set这一组指令的设计方法。</p><h2 id="低八位寄存器"><a href="#低八位寄存器" class="headerlink" title="低八位寄存器"></a>低八位寄存器</h2><p>在x86-64位寄存器里,每个寄存器的低八位都有一个别名的。之前a b c d 4个寄存器，它的最低位的别名是a l, b l, c l, d l, 除此之外，s i, d i, s p ,b p, 它也有低八位的寄存器。r8到r155也有低八位寄存器的编码。set这一组的指令可以对这低八位的寄存器进行操作。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p><img data-src="/../../images/image-20201015201003733.png"></p><p>这有两个long形的有符号数, 如果x大于y , 这时候返回一, 如果x 要是小于等于y , 这个时候返回0。</p><p>翻译为汇编语言后, 首先rdi 是放存放的x 的值，那么rsi 是存放y 的值，rax 是作为返回值。</p><p>判断x 大于y 还是小于等于y, 使用的指令就是cmpq, 就是做rdi 和rsi 的比较。如果rdi 是大于rsi , 那么这个时候r a x 中的数据应该是1, 否则应该是0。他怎么做的？比较这两个数用setg 这是一个有符号数的大于, 如果大于的话，那么al 寄存器最低位会被置1,  高7位被置0, 否则al 寄存器就为0。这个是大于还是小于等于通过al 寄存器就可以判断。但是注意返回值是int型的, int型是一个四字节的数据。那么现在最低的8位是受影响的, 那么还有高24位, </p><p>实际上在这里边是没有对它做任何操作的。这里边要注意一点, 8位指令操作的时候，它的高位是不受任何影响的, 这和32位的指令操作64位寄存器是不一样的。这个8位指令只影响最低8位, 高位是不发生变化的。那为了保证最后返回的值是0或者是1。还需要把高24位填充成0, 这时候就使用了一个指令叫做movzbl 。</p><p>movzbl 做的是零扩展. move指令都知道是做数据移动。c 是零扩展的意思。b是拓展源表示的是bite ,一个字节，也就是8位。l是long world, long word 是四字节, 也就是双字。通过这样一条指令，就是告诉计算机要做一个零扩展。扩展源是8比特, 扩展后是32比特, 那么这个是原操作数这是目标操作数，最后执行了这条指令, 会将eax 寄存器的高24位填充成了0, 但实际在这个里面还隐含着做了一个零的填充。因为movezbl 是一个32位的指令, 所以他也会把rax的高32位同样填充成0, 这就是之前我们讲到过的, 一个32位指令去操作64位寄存器的话, 对应目标寄存器的高32位是会被清零的。所以最后rax寄存器它的最高31位都为0, 最低一位就是我们判断出来的结果。</p><h1 id="3-6-3-跳转指令"><a href="#3-6-3-跳转指令" class="headerlink" title="3.6.3 跳转指令"></a>3.6.3 跳转指令</h1><p><img data-src="/../../images/image-20201015202411869.png"></p><p>在x86-64汇编中，跳转指令也是一个组的指令, 在跳转指令中，可以把它分成两个大类.</p><p>第一类是一条指令，就是jmp这条指令。jmp这条指令叫做无条件跳转, 其他的指令。<br>都叫做条件跳转。条件跳转和无条件跳转的指令格式都是相同的, 就是前面是这条指令的。<br>操作码, 后面跟的是一个标签, 这个标签就是说明这个标签儿如果发生跳转，跳转的目标位置, 也就是说这个标签表示的就是跳转的目标地址。条件跳转和无条件跳转最大的区别也在于跳转产生的时机的不同。</p><h2 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h2><p>首先来看最简单的无条件跳转。无条件跳转, 也就是说在任何情况下都会发生跳转, 其他的条件跳转呢都是在一定条件满足的情况下才能够完成跳转。如果这个条件不满足, 就顺序执行下面的指令, 如果条件满足是跳转到目标位置去执行指令, 那么这个满足条件的情况和set 这一组的指令也非常像, 通常跳转指令也是和类似于cmp指令或者是test指令联合配合进行。</p><h2 id="有条件跳转"><a href="#有条件跳转" class="headerlink" title="有条件跳转"></a>有条件跳转</h2><p>je就是当比较的两个数相等，或者说最后运算的结果为0的时候跳转。<br>       jne是当不相等或者是结果不为零的时候跳转。<br>      js 是根据符号位, 如果为1进行跳转，jns 就是符号位为0的时候进行跳转。<br>      jg 是在做有符号数比较大于的时候跳转, 或者是有符号数大于零时跳转。<br>      jge 是有符号数比较大于等于时跳转, 或者是有符号数大于等于零时跳转。<br>      jl 是有符号数比较小于时跳转, 或者是有符号数小于零时跳转。<br>      jle 是有符号数比较小于等于时, 或者是有符号数小于等于零时跳转。<br>      ja 是无符号数大于时跳转。<br>      jb 是无符号数小于时 跳转。<br>      这就是跳转的基本条件。当条件码满足这样一种情况的时候, 条件码的表达式运算结果为1的时候, 这个跳转才能够发生。</p><h1 id="3-6-4-跳转指令的编码"><a href="#3-6-4-跳转指令的编码" class="headerlink" title="3.6.4  跳转指令的编码"></a>3.6.4  跳转指令的编码</h1><p>讨论一下跳转指令的机器指令级别的底层实现,也就是看看在机器指令水平上是如何对跳转指令进行编码的。</p><p><img data-src="/../../images/image-20201015203536404.png"></p><p>上面给出的是一段C语言程序, 它内部包含着两条和跳转相关的指令, 一条是无条件跳转, 也就是执行这一条指令的时候，是会立刻跳转到L2标签所对应的testq 这条指令, 也就是紧挨着jmp 指令的sarq 指令是不会在jmp指令执行后获得执行的机会的。第二个跳转相关的指令是jg 指令, jg 指令是当满足jg 指令的触发条件的时候，它会跳转到L3所对应的这个标签的sarq 处这条指令所在的位置。转换成汇编代码如下</p><p><img data-src="/../../images/image-20201015203756684.png"></p><p>最左边表述的是每一条指令的地址。jmp 这条指令被进行编码之后，它的机器指令编码是两个字节, eb 03。eb是用来描述操作码，也就是jmp。真正的跳转目标信息是在后边的这个字节中描述，也就是在03这个位置描述的是跳转信息。那么为什么可以用03去描述跳转目标呢？通常所使用的跳转指令, 它在进行编码的时候, 对于跳转目标都是采用相对位置进行编码, 所以03用来描述的实际上是一个偏移量。跳转的目标是一个偏移是03这样的一个量。那么这个跳转目标他这个03是怎么计算出来的呢？要跳转到的目标位置是test q 这条指令的位置, 4004d8。在当前执行jmp 这条指令的时候, rip 计算器中的值应该是4004d5。因为rip 寄存器存放的是即将要加载的那一条指令的地址。当jmp 在执行的时候, 它下面要加载的地址是4004d5。这是一个顺序的过程, 但是在jmp指令中，它会改变rip 寄存器, 因为它要把rip 寄存器改成新的目标位置的地址, 这样jmp 指令执行完之后, 处理器才能从正确的地址去加载testq这条指令。所以jm p 指令在执行的时候, 在jm p 指令没有执行完之前，它的r i p 寄存器中的值是4004d5。这个偏移量就是根据4004d8，也就是目标位置和当前的指令执行时的rip 计算器的值去计算出来的。换句话说，通过jmp 指令去跳转目标地址。这个目标地址就是根据jmp 指令中的这个偏移量3, 和当前的指令计数器rip寄存器的值进行相加。这样就可以算出真正跳转的绝对地址, 就是4004d8。同理。下面j g 的指令也是类似, 7f 表示的是jg 这个操作码, f8用来编码的是跳转的相对偏移位置信息。f8表示的是什么呢？这里边它采用的是补码表示。所以f8对应的是应该是十进制数-8。执行j g 这条指令的时候，i p 计算器的值应该是4004dd。加上-8, 也就算出来了j g 指令，如果要是满足条件发生跳转时候，它应该跳转到4004d5这个位置。</p><p>x86指令集包含一些跳转范围更长的跳转指令。那么编译器呢再去生成机器指令的时候，它会根据实际跳转范围的不同, 选择不同格式的指令去进行跳转，以保证呢这个跳转过程可以满足偏移量的的范围的要求。</p><p>总体上我们要了解一点的就是使用的是一个相对偏移量, 用来去存储跳转目标。这样再去实现的时候，可以获得更高的灵活度, 因为不管编译器最后将这些指令分配到哪个地址上去, 它们相对的位置都是不变的。</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8A)_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 3.6 控制结构(下)</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8B)_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8B)_url.html</guid>
      <pubDate>Sat, 10 Oct 2020 10:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;3-6-5-使用跳转指令实现条件分支&quot;&gt;&lt;a href=&quot;#3-6-5-使用跳转指令实现条件分支&quot; class=&quot;headerlink&quot; title=&quot;3.6.5 使用跳转指令实现条件分支&quot;&gt;&lt;/a&gt;3.6.5 使用跳转指令实现条件分支&lt;/h1&gt;&lt;p&gt;这节探讨C语言if else 语句在使用汇编指令表示是采用什么样的方式去表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../images/image-20201015205526690.png&quot; alt=&quot;image-20201015205526690&quot;&gt;&lt;/p&gt;
&lt;p&gt;这有一个c 源的代码片段, 它定义了一个函数。这个函数的目标是计算了x 减y 的绝对值, 传入了两个参数x 和y , 如果x 大于y,  就用x 减去y , 否则就用y 减去x 。其实就是去算x 减y 的绝对值, 这样的一个程序，我们通过上面的这样一个指令，把它翻译成汇编指令。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gcc -0g -S -fno-if-conversion control.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="3-6-5-使用跳转指令实现条件分支"><a href="#3-6-5-使用跳转指令实现条件分支" class="headerlink" title="3.6.5 使用跳转指令实现条件分支"></a>3.6.5 使用跳转指令实现条件分支</h1><p>这节探讨C语言if else 语句在使用汇编指令表示是采用什么样的方式去表示</p><p><img data-src="/../../images/image-20201015205526690.png" alt="image-20201015205526690"></p><p>这有一个c 源的代码片段, 它定义了一个函数。这个函数的目标是计算了x 减y 的绝对值, 传入了两个参数x 和y , 如果x 大于y,  就用x 减去y , 否则就用y 减去x 。其实就是去算x 减y 的绝对值, 这样的一个程序，我们通过上面的这样一个指令，把它翻译成汇编指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -0g -S -fno-if-conversion control.c</span><br></pre></td></tr></table></figure><span id="more"></span><p>rdi存放的是x的变量，rsi存放的是y 的变量，rax存放的是返回结果.进入这个函数之后，首先把x 和y 做了一个比较。如果x小于等于y 则跳转到.L4. 跳转到L4的时候做了一件事, 把rsi也就是y放到了iax中, 然后用rax 减去x 的值, 然后差放到rax 里, 函数返回。<br>如果不是小于等于，那么就是把x 的值放到rax里, 然后用r ax 去减去y 的值，最后结果存到rax 里，然后过程返回。</p><p>如果使用了一个c 语言的goto语句的版本，可以让我们更清晰的去看到条件跳转语句在刚才的汇编语言中的这个跳转分支的过程发挥了一个什么样的作用。</p><p><img data-src="/../../images/image-20201015210226351.png" alt="image-20201015210226351"></p><p>当然在c 语言中还有一种可以实现简单的条件分支的方法, 就是采用表达式中的三目运算符。</p><p><img data-src="/../../images/image-20201015210442197.png" alt="image-20201015210442197"></p><h1 id="3-6-6-使用条件数据传输语句实现条件分支"><a href="#3-6-6-使用条件数据传输语句实现条件分支" class="headerlink" title="3.6.6 使用条件数据传输语句实现条件分支"></a>3.6.6 使用条件数据传输语句实现条件分支</h1><p>介绍另一种实现高级语言条件分支语句的形式, 就是使用条件数据传输语句来去实现。</p><p><img data-src="/../../images/image-20201015210751884.png" alt="image-20201015210751884"></p><p>条件数据传输语句其实也可以认为是一个条件赋值语句。它本质上是实现了这样的一个过程, 就是根据条件码的具体状态来决定是否把源操作数中的值, 赋值到目标操作数中。<br>这个过程和传统的move指令非常相似, 只不过是他在move之前需要判断一下条件码。<br>如果条件码不符合要求，相当于这条指令什么都不做，继续向下执行。如果符合要求就进行复制, 这就是条件数据传输指令的基本功能。</p><p>为什么我们还需要引入条件数据传输指令？这是因为条件跳转指令本身具有很大性能上的问题。这个其实涉及到我们处理器体系结构中一个非常重要的技术，叫做流水线技术。现代处理器中都包含着流水线, 流水线技术可以实现对于指令执行的加速, 而且这种加速的效果是非常可观的。但是对于流水线来讲，它需要进行指令的预取, 通常的一个预取策略就是顺序取值。如果遇到跳转指令，那么对于流水线来讲会具有更大的挑战。因为流水线无法判断当前这个语句是否真正进行跳转, 尤其是条件跳转，因为还没有计算出条件的结果，所以流水线没有办法去计算到底是否完成跳转。所以这样就引发了一个问题，就是条件跳转语句其实对于流水线的指令预取是具有破坏性的。因此, 跳转语句本身对于流水线来讲会构成巨大的性能上的挑战, 但是条件数据传输语句将不会出现这种情况, 因为条件数据传输语句不需要实现跳转。</p><p><img data-src="/../../images/image-20201015211202045.png" alt="image-20201015211202045"></p><p>比如说前面我们谈到的这个三目运算符的例子。如果使用的是条件跳转语句，那么就会分成两个语句块。当不满足条件的时候，会跳入else 这个语句块会执行, 这样就会出现一个跳转。那如果要是采用条件数据传输语句，它怎么去执行的呢？它会首先把then的这个表达式和else 的这个表达式都提前计算出来, 接下来去判断一下是否满足条件。<br>如果满足条件就不进行条件数据传输语句进行复制。如果不满足条件，就把else的结果赋值给最终的结果。注意标红色的这样的一条语句, 在汇编语言指令中使用一条条件，数据传输指令就可以达到这样的一个效果。所以从宏观上看, 这个汇编指令本身都是顺序执行的, 不存在分支和跳转, 这样呢就可以对流水线进行一个优化。使用条件数据传输语句虽然会在前面增加了一些计算量, 但是由于他对流水线进行了优化, 所以流水线性能的优化要高于前期计算所消耗的代价, 所以整体上的优化效果仍然是明显的。</p><p>下面来看一个例子</p><p><img data-src="/../../images/image-20201015211648837.png" alt="image-20201015211648837"></p><p>计算机会把x 减y 的值计算出来，放到rax 寄存器里。把y-x 的值计算出来，放到rdx 计算器里, 然后它再去比较x 和y 之间的大小。cmovle就是一个条件数据传输指令, 它和条件跳转指令的后缀和set 这一组指令的后缀的用法是相同的。它的意思是如果前面的这个比较是小于等于的话，会把rdx 赋值到rax寄存器中。如果要是大于rax 寄存器的值，保持原状也就是说这条指令不做任何的工作。这样我们看在整个的这个过程中，就消除了分支跳转, 对流水线进行了优化。</p><h2 id="不适用与条件数据传输指令的场景"><a href="#不适用与条件数据传输指令的场景" class="headerlink" title="不适用与条件数据传输指令的场景"></a>不适用与条件数据传输指令的场景</h2><p><img data-src="/../../images/image-20201015212036490.png" alt="image-20201015212036490"></p><ol><li>两个表达式计算量都非常大, 这时计算开销要远大于对流水线的优化</li><li>表达式具有一些临界的风险情况.</li><li>计算中会出现一些副作用. 如两个表达式冲突时.</li></ol><h1 id="3-6-7-1-do-while循环"><a href="#3-6-7-1-do-while循环" class="headerlink" title="3.6.7 (1) do-while循环"></a>3.6.7 (1) do-while循环</h1><p><img data-src="/../../images/image-20201015212512469.png" alt="image-20201015212512469"></p><p>在通过之前条件分支的讨论可以知道。在汇编指令中, 条件跳转, 等价于c 语言中的一个if 的条件判断加goto语句。</p><p><img data-src="/../../images/image-20201015212812282.png" alt="image-20201015212812282"></p><ol><li>位移操作数只有1位的时候, 唯一一个操作数为目标操作数, 移位量为1.</li><li>rep指令是一个字符串操作指令, 这里相当于在goto和ret之间插入一个空指令, 作用是优化x86处理器的流水线功能.</li></ol><p><img data-src="/../../images/image-20201015213209975.png" alt="image-20201015213209975"></p><h1 id="3-6-7-2-while循环"><a href="#3-6-7-2-while循环" class="headerlink" title="3.6.7(2) while循环"></a>3.6.7(2) while循环</h1><p>看图就可以了.</p><p><img data-src="/../../images/image-20201015213304490.png" alt="image-20201015213304490"></p><p><img data-src="/../../images/image-20201015213324421.png" alt="image-20201015213324421"></p><p>使用<code>-o1</code>编译选项.</p><p><img data-src="/../../images/image-20201015213421900.png" alt="image-20201015213421900"></p><p><img data-src="/../../images/image-20201015213530857.png" alt="image-20201015213530857"></p><h1 id="3-6-7-for循环"><a href="#3-6-7-for循环" class="headerlink" title="3.6.7 for循环"></a>3.6.7 for循环</h1><p><img data-src="/../../images/image-20201015213618699.png" alt="image-20201015213618699"></p><p>将for循环改造成while循环</p><p><img data-src="/../../images/image-20201015213815083.png" alt="image-20201015213815083"></p><p>将for循环转化成等价的while循环</p><p><img data-src="/../../images/image-20201015213934995.png" alt="image-20201015213934995"></p><p><img data-src="/../../images/image-20201015214033525.png" alt="image-20201015214033525"></p><p>优化后</p><p><img data-src="/../../images/image-20201015214146556.png" alt="image-20201015214146556"></p><h1 id="3-6-8-1-switch-语句的机器级实现"><a href="#3-6-8-1-switch-语句的机器级实现" class="headerlink" title="3.6.8(1) switch 语句的机器级实现"></a>3.6.8(1) switch 语句的机器级实现</h1><p>switch 语句可以实现的所有功能都可以被条件分支语句，也就是类似于if else , if 的一种形式来表达。既然switch 语句有它的等价表示方式, 为什么在高级语言中还定义switch 这样的一种特殊的语法呢？这是有特殊原因的。</p><p><img data-src="/../../images/image-20201016095956782.png" alt="image-20201016095956782"></p><h2 id="基于跳转表的switch语句实现"><a href="#基于跳转表的switch语句实现" class="headerlink" title="基于跳转表的switch语句实现"></a>基于跳转表的switch语句实现</h2><p>switch是语句在机器级实现的时候，主要是基于了一个跳转表的数据结构来实现。具体如下</p><p>Jump Table是一个数组, 数组中的每一个元素都是一个地址。这个地址指向的是对应的case 语句块的起始地址。switch语句在工作的时候是根据变量的值去跳转表中找到对应位置的元素, 从对应位置的元素中，将某个数组元素的值也就是跳转的目标地址取出来, 然后执行一条跳转语句，跳转到真正目标入口的语句块的起始地址位置上。</p><p><img data-src="/../../images/image-20201016100421674.png" alt="image-20201016100421674"></p><p>和if else语句相比, switch语句有一个非常大的优势, 就是在整个这个过程不管跳转到哪一个目标语句块, 它所花费的时间都是固定的, 也就是说它的时间复杂度是一个常数类型。</p><p>而if else 语句, 如果想执行if else 语句的最后一个语句块, 必须是先做了前n 个语句块的判断之后, 才能够执行。这就说明if else语句查找到目标并进入目标语句块进行执行的时间复杂度是n 。</p><p>switch语句利用跳转表这样一个结构，将时间复杂度转换为常数。所以, switch语句的变量必须是整数. 因为只有这个变量是整数，它才能作为查找表的下标, 去进行查表的这样的一个操作。</p><h1 id="3-6-8-2-间接跳转"><a href="#3-6-8-2-间接跳转" class="headerlink" title="3.6.8 (2) 间接跳转"></a>3.6.8 (2) 间接跳转</h1><p><img data-src="/../../images/image-20201016101709718.png" alt="image-20201016101709718"></p><p>变量的判断主要使用了一个判断的指令cmp去判断rdi和6的大小, 6是一个立即数。接下来用ja指令去进行跳转, ja 是用于无符号数大于的判断。<br>但是x 是一个有符号数。为什么要使用一个无符号数的指令去做判断？因为在case 语句中, 有效范围是从0到6范围内。大于6和小于0的数都会进入到default 这样的一个语句块里,那如果将rdi 的范围换算成无符号数的话，可以认为rdi 就是一个小于等于6的一个无符号数, 因为在有符号数转换成无符号数的时候，负数会被转换成大的一个正数。所以通过ja 这样一条指令，就既可以排除掉小于零的数也可以排除掉大于六的数字。如果是大于6, 指定跳转到某个固定的位置, 否则执行间接跳转。</p><h2 id="间接跳转与直接跳转"><a href="#间接跳转与直接跳转" class="headerlink" title="间接跳转与直接跳转"></a>间接跳转与直接跳转</h2><p><img data-src="/../../images/image-20201016104201079.png" alt="image-20201016104201079"></p><p>可以根据跳转目标的不同, 将跳转划分成两种类型, 一类叫做<strong>直接跳转</strong>。直接跳转就是在去做跳转的时候,  跳转的目标是一个确定的位置, 那么这种跳转就叫做直接跳转。比如下图中的jmp .L8, 不管在什么情况下，只要执行这条跳转语句，只要它发生了跳转，它就一定会跳转到某个确定的位置。</p><p><img data-src="/../../images/image-20201016104524068.png" alt="image-20201016104524068"></p><p>另外一种就是<strong>跳转到某个不确定位置的跳转叫做间接跳转</strong>。不确定的位置并不是计算机不知道跳转的确定位置, 而是在执行到这条指令之前是无法提前预知的。地址是基于某个变量去计算出来的。在这里面上图中的<code>jmp *.L4(, %rdi, 8)</code>就是一个间接跳转。这个间接跳转是基于rdi 中的值来去计算出跳转的具体目标。<br>后边这一部分<code>(, %rdi, 8)</code>可以认为就是寻址方式的那个4元组, 就是的D(R<del>b</del>, R<del>i</del>, S)。<br>L4是一个地址, 是跳转表的地址，跳转表是在编译器编译的时候为我们生成的一个固定的只读数据, 就是在内存中分配出一个区域，这个区域不可被修改。但是它内部的变量已经初始化。<br>跳转表的起始地址的标号是L4, 每个数据的数据宽度是八字节, 对应的每个数据的值在后面也定义了就是对应的标签, 标签就是一个地址, 地址本质上也是一种类型的数据。<br>在L4的这个表中,一共包含着7个元素, 7个元素，每个元素都对应着一个标签，也就是都对应着一个地址, 这个地址就是x 等于0的跳转到x 等于6的跳转的目标地址。</p><p>rdi和8决定了rdi ，就是这个查找表要访问的下标. 8表示查找表中每个元素的大小, 可以看到这个查找的地址就是L4为起始地址,  加上下标乘以元素大小的偏移量所查到的就是对应这个r d i 的这个下标的地址。最后前面有一个<code>*</code>是把这个地址中的数据取出来作为跳转语句的目标地址。比如说rdi是1, 最后计算后的地址就是L4中的第1个元素的起始地址。<br>从它中间取出来的值就是L3, 跳转语句就是跳转到L3这个标签所指向的位置。</p><p>因为这个查找表只有7个元素，所以它只是支持x也就是rdi变量, 从0到6范围内的变化, 小于零和大于6都会跳到某个默认的位置上去, 这个默认的位置就是对应的default . </p><h1 id="3-6-8-3-switch语句示例分析"><a href="#3-6-8-3-switch语句示例分析" class="headerlink" title="3.6.8(3) switch语句示例分析"></a>3.6.8(3) switch语句示例分析</h1><p>跳转表和case语句块的映射关系</p><p><img data-src="/../../images/image-20201016120257181.png" alt="image-20201016120257181"><br>在整个的这个条件变量里, 0和4是没有所对应的case语句块的, 所以0和4都指向了default 这个语句块, 除此之外，其他的跳转表中的值都是指向了对应的语句块的位置, 可以看到的是x=5和x=6的时候，它指向的语句块都是L7这个语句块, 所以case5和case6它有相同的语句块的处理。</p><p><img data-src="/../../images/image-20201016121022303.png" alt="image-20201016121022303"></p><h2 id="有break语句的情形"><a href="#有break语句的情形" class="headerlink" title="有break语句的情形"></a>有break语句的情形</h2><p>当x=1的时候，会跳转到L3这个语句块里. 在L3这个语句块里, 它首先把rsi复制给rax, rsi中存放的是参数y的值。第二部做了一个乘法y*z, 结果存到rax 中。由于在函数中，w 是作为最后的返回值出现的, 所以switch语句后也不出现对任何w的处理, L3在计算完成后，由于有break语句，它也不会再执行其他的语句, 调用了过程返回指令导致函数返回。</p><p><img data-src="/../../images/image-20201016121558504.png" alt="image-20201016121558504"></p><h2 id="落下-Fall-Through-的情形"><a href="#落下-Fall-Through-的情形" class="headerlink" title="落下(Fall-Through)的情形"></a>落下(<code>Fall-Through</code>)的情形</h2><p>case2中, 首先会做一个 <code>y/z</code> 的操作, 完成之后，它会继续执行到case3的语句, 做w+=z的操作.在之前可以看到, 对于把w赋初值为1(<code>long w=1</code>), 在进入switch语句之前。<br>并没有进行, 原因是并不是所有的语句块都需要有把w赋值为1的这样一个操作, 比如说case2这个语句块就不需要对w赋初值, 因为在case 2这个语句块中为w 再一次做赋值。所以w 等于1这个赋值并不是在所有的语句块中都需要。</p><p>所以w 等于1是不会在switch 语句之前去做这样一个复制的。因为这样做会浪费指令, 导致程序性能的下降。w=1赋值是按需出现的。比如说在case3的时候, 计算w+=z时，之前是需要w先去赋初值的。所以它在这个位置case 3的时候，才会去先把w赋值成一。<br>但是case2的时候，由于它不需要赋初值，所以给<code>w=y/z</code>之后，紧接着就需要跳转到merge语句块,  因此在case3中需要分成两个语句块。</p><p>case2完成后会跳转到merge, case3完成后也会顺序执行到merge语句块,</p><p>下图为case3和case2 在一起的汇编代码</p><p><img data-src="/../../images/image-20201016122543333.png" alt="image-20201016122543333"></p><h2 id="共用标签的情形"><a href="#共用标签的情形" class="headerlink" title="共用标签的情形"></a>共用标签的情形</h2><p><img data-src="/../../images/image-20201016122757174.png" alt="image-20201016122757174"></p><h1 id="3-6-8-4-对switch的进一步探讨"><a href="#3-6-8-4-对switch的进一步探讨" class="headerlink" title="3.6.8(4) 对switch的进一步探讨"></a>3.6.8(4) 对switch的进一步探讨</h1><h2 id="查找表的局限"><a href="#查找表的局限" class="headerlink" title="查找表的局限"></a>查找表的局限</h2><p>switch 语句使用查找表去进行实现的时候, 会有非常大的一个性能上的提升。但是查找表本身也具有一定的局限性。</p><p>前面例子中所有的case 语句中值都比较小, 是从0到6这样的一个范围内, 那如果case 语句中的值都比较大的时候怎么办呢？如果仍然是从零作为查找表的起始地址到10006。作为一个结束的这样的一个元素。这个查找表的规模就会变得非常大, 而且10000之前的这些查找表中的地址存储的都是相同的，标签都是指向default 。这样就会变得没有意义, 使得查找表大量的数据存储的，实际上都是没有意义的数据, 或者说查找表在所引起的空间复杂度的提高所得到的这个效果要远远大于性能上的提升。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><img data-src="/../../images/image-20201016123010908.png" alt="image-20201016123010908"></p><p>第一种解决方法, 是观察一下case 语句它在数轴上的取值是不是相对密集的。如果相对密集比如说上面这个例子是从1万到10006, 它在数轴上仍然相对密集, 只不过是它相对于0, 有了一个整体的偏移。编译器会首先去减去一个固定的偏移量, 使得最后case 语句的这些值处在从零开始的每个某个很小的范围的区间内。这样仍然可以去很有效率做查找。在这个例子中，它是从10000到10006, 可以把它近似成为把x 减去10000，然后继续把减完的这个结果和6去比较，因为它就变成了一个从0到6的这样一个范围, 然后接下来仍然可以使用间接跳转去进行查表来去实现。</p><p>那如果在数轴上排列不密集呢?</p><p><img data-src="/../../images/image-20201016123655875.png" alt="image-20201016123655875"></p><p>更普遍的一种情况处理起来就更加的复杂了, 就是数据的范围是很大。值很大, 而且这些数据在数轴上分布的不密集, 即这些数值在数轴上的分布非常稀疏。</p><p>这个时候switch语句通过编译器去实现的时候，就不是以查找表的方式来去实现了。<br>而是以二分搜索的方式来去实现。二分搜索，这是一个数据结构中提供的概念。由于我们的case 语句都是一些孤立的值, 这些值编译器可以给他们进行排序，进行一个二分搜索，或者叫做二分查找。编译后的结果近似等价于这样的一个if else 语句的一个嵌套的过程。<br>注意这个是if 语句中间嵌套if else , else一句话中间再嵌套if else 。使用二分搜索的方式,<br>去查找对应的语句块的时间复杂度是log<del>2</del>n。如果采用if else if ,期望的时间复杂度是n 也就是一个线性时间复杂度。</p><p>即使对于case 中的值比较稀疏的这样的一个情况, 编译器仍然可以提供比较高的查找效率。而这个查找要比简单的，if else if 的这样的一种查找要快。<br>所以说这就是switch语句它仍然存在的价值。所以switch 语句是基于值进行查找的。<br>所以可以进行一定程度的优化。编译器足够的聪明，足够的智能, 可以根据不同case 语句的值对整个switch语句进行不同程度的优化. 在C语言c++语言中。在高级语言中，如果有switch 这样的语法,基本实现都是类似的。</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3.6_%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84(%E4%B8%8B)_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 3.4 数据访问</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3_4%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3_4%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4_url.html</guid>
      <pubDate>Sat, 10 Oct 2020 02:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;3-4-1-数据访问指令&quot;&gt;&lt;a href=&quot;#3-4-1-数据访问指令&quot; class=&quot;headerlink&quot; title=&quot;3.4.1 数据访问指令&quot;&gt;&lt;/a&gt;3.4.1 数据访问指令&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../images/image-20201015082522584-1602737646018.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据访问指令, 它的助记符是move。通过这个名称，可以看出来，它实际上进行的是在源操作数以及目标操作数之间移动数据。虽然它的助记符是move, 但是更确切的去描述的话，可以理解为, 它是将源操作数中的数据复制到目标的位置，也就是源操作数中的数据是不会发生改变的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="3-4-1-数据访问指令"><a href="#3-4-1-数据访问指令" class="headerlink" title="3.4.1 数据访问指令"></a>3.4.1 数据访问指令</h1><p><img data-src="/../../images/image-20201015082522584-1602737646018.png"></p><p>数据访问指令, 它的助记符是move。通过这个名称，可以看出来，它实际上进行的是在源操作数以及目标操作数之间移动数据。虽然它的助记符是move, 但是更确切的去描述的话，可以理解为, 它是将源操作数中的数据复制到目标的位置，也就是源操作数中的数据是不会发生改变的。</p><span id="more"></span><h2 id="操作数的形式"><a href="#操作数的形式" class="headerlink" title="操作数的形式"></a>操作数的形式</h2><p><img data-src="/../../images/image-20201015082751288-1602737692203.png"></p><p>对于操作数, 有三种形式。</p><p>第一种形式叫做立即数。立即数通常是一个常数的整数类型, 比如0x400, 是一个十六进制数, 或者是-533。对于-533, 进行一个数据移动实际存到目标位置的数据是-533所对应的补码值, 对应的补码值的位长是由操作数中所携带的数据格式信息所确定的。在这个例子中, 操作码是moveq , q 所表示的信息是八字节，也就是64位。所以如果用moveq 去对这个立即数输出操作, 目标操作数所在的位置应该是-533的一个64bit的补码形式, 最后存储到目标操作数的位置.</p><p>立即数与c 语言的常数是类似的，但是在立即数中, 它需要增加一个前缀$(dollar) 符号去描述，这是一个常数。对于立即数操作，可以有1字节、2字节、4字节, 8字节四种操作方式, 这主要取决于操作码的最后一位。也就是, 操作码的最后一个字母, 用来去描述这一次操作的数据位长。</p><p><img data-src="/../../images/image-20201015083236038.png"></p><p>第二种类型叫做寄存器类型。寄存器也可以作为move指令的操作数存在。16个通用寄存器中的任意一个都可以作为操作数。除了64位的16个通用寄存器之外，在这些寄存器中的低32位或者低16位、低八位或者是第八位到第15位，也可以通过move指令去操作, move指令操作的数据位长是由它所决定。</p><p><img data-src="/../../images/image-20201015083802875-1602737794950.png"></p><p>在64位的指令中, r a x, r13前面都有百分号, 这些都是一个合法的操作书. 所有的通用寄存器都可以采用这种方式去做操作。但要注意的是r s p 寄存器, 一般在编写汇编语言程序的时候, 不能把它当做一个普通的寄存器去使用。因为r s p 寄存器有特殊的用途，r s p 寄存器在汇编语言中用于存放程序运行时栈的栈顶数据的地址的。其它的寄存器在某些应用场景下也有一些特殊的用途。</p><p><img data-src="/../../images/image-20201015084014208-1602737814639.png"></p><p>move指令的第三类操作数是内存。move指令可以通过访问内存的某个地址的方式，从内存中加载数据，或者是把数据存放到内存中。</p><p>最简单的一个例子。<code>(%rax)</code>, 它用来描述的是rax 中存放的数据，实际上是一个地址。那么加上括号也就是去访问对应rax 所在地址的数据。这点非常像c 语言中的指针类型指针表示一个地址, 通过在指针前面增加星号，意味着是对这个地址中的数据进行访问. 在汇编语言中是使用括号中间加寄存器的方式也可以进行访问。</p><h2 id="move指令操作数的组合"><a href="#move指令操作数的组合" class="headerlink" title="move指令操作数的组合"></a>move指令操作数的组合</h2><p>move指令以及三类的操作数，它们之间有一些固定的组合关系。具体如图所示</p><p><img data-src="/../../images/image-20201015084519071-1602737851348.png"></p><p>注意事项:</p><p><strong>1. 立即数只能作为源操作数出现，不能作为目标操作数出现.</strong> 因为我们无法给一个常量进行赋值。</p><p>2  <strong>如果源操作数为内存的某个地址的话, 目标操作数必须为寄存器。</strong>move指令是不支持直接将一片内存地址所指向的数据赋值给另一个内存地址. 因为在冯诺依曼体系结构中，处理器是整个计算机的核心, 所有的指令都要通过处理器来去完成, 也就意味着在这个过程中是需要有处理器参与的。如果将一片内存中的数据赋值给到另一片内存中，意味着绕过了处理器。所以在x86的指令中，不提供这样的指令。</p><p>如果想在两片内存之间搬运数据，需要以寄存器作为中间媒介进行过渡, 也就是先从内存中, 把数据加载到寄存器里, 然后再通过寄存器把数据放到另外一片内存中。</p><h1 id="3-4-2数据访问指令实例"><a href="#3-4-2数据访问指令实例" class="headerlink" title="3.4.2数据访问指令实例"></a>3.4.2数据访问指令实例</h1><p><img data-src="/../../images/image-20201015085120154-1602737875466.png"></p><p>左边是c 语言的源码。它实现了一个两个内存区域之间的数据交换, 也就是传入的x p 指针所指向的long形数据和yp指针所指向的long形数据进行了一个交换。在c 语言中定义了两个临时变量，用来暂时存储xp 数据的值和yp 数据的值. 然后分别把这个值交换位置存储回x p 和y p 。这也就实现了两个指针所指向地址数据的交换。</p><p><img data-src="/../../images/image-20201015085433948.png"></p><p><img data-src="/../../images/image-20201015085433948-1602737904577.png"></p><h1 id="3-4-3-寻址模式"><a href="#3-4-3-寻址模式" class="headerlink" title="3.4.3 寻址模式"></a>3.4.3 寻址模式</h1><h2 id="完全寻址模式"><a href="#完全寻址模式" class="headerlink" title="完全寻址模式"></a>完全寻址模式</h2><p><img data-src="/../../images/image-20201015091100840-1602737988337.png"></p><p>在x86汇编指令中, 对于内存寻址的方式是非常灵活的. 一个完全内存寻址方式可以采用这样的一个4元组来去表示。<br>                                                       <strong>D(R<sub>b</sub>, R<sub>i</sub>, S)</strong></p><p>D是一个偏移量, 它是一个基于内存地址的偏移量，可能是1字节两字节、4字节或者8字节的一个常数。D是一个有符号数. R<del>b</del> 表示内存的基地址, 它是任意的一个整数都可以去描述。R<del>i</del> 叫做索引寄存器, R<del>i</del>寄存器。除了rsp寄存器不能作为R<del>i</del>去表示, 其它的寄存器都可以在R<del>i</del>的位置所表示。</p><p>S是表示大小, 它只能是1, 2, 4, 8这几个常数中的一个。因为在高级语言处理数据类型的时候, 基本数据类型的位长, 只有这样的四个值。</p><p>该4元组遵循下列规则完成完全寻址模式. </p><p>​                                        <strong>Mem[Reg[R<del>b</del>] + S * Reg[R<del>i</del>] + D]</strong></p><p> 把R<del>b</del>寄存器中的一个值, 加上R<del>i</del>寄存器中的值乘以S, 再加上D 。利用这样一个运算算出来的值，作为实际内存的访问地址, 从内存的这个地址中去访问数据。这是一个非常灵活的寻址方式. 在这里可控的有两个可变的东西，一个是R<del>b</del>寄存器，一个是R<del>i</del>寄存器。</p><h3 id="完全寻址模式特例"><a href="#完全寻址模式特例" class="headerlink" title="完全寻址模式特例"></a>完全寻址模式特例</h3><p>完全寻址模式有一些特例</p><p><img data-src="/../../images/image-20201015092446296-1602738014275.png"></p><p>进一步的去理解这样的一个完全寻址模式。它和对于数组中的某个下标所在元素进行地址计算的时候的选址非常类似。可以理解为R<del>b</del>是数组的首元素地址, 可以把R<del>i</del>理解为数组的下标。那么想访问R<del>i</del>这个下标的元素，这个元素的地址在哪？就是数组的首地址，加上数组的下标乘以数组中每一个元素的数据位长就可以得到。因为完全寻址模式通过这样的一个灵活的寻址，可以在处理器中很好的去支持数组的访问。通过增加了一个偏移量D, 它可以对于结构体的支持可以实现的更好。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img data-src="/../../images/image-20201015093309854-1602738037965.png"></p><p>需要注意的是, 使用move指令去做访问的时候, 采用这样的内存寻址方式, 不是将这样的一个数值赋值给目标操作数, 而是将这个地址所指向的内存中的数据复制给目标操作数。</p><h1 id="3-4-4-操作码的后缀"><a href="#3-4-4-操作码的后缀" class="headerlink" title="3.4.4 操作码的后缀"></a>3.4.4 操作码的后缀</h1><p><img data-src="/../../images/image-20201015093512664-1602738060240.png"></p><p>数据传输指令，它的助记符是move。在实际应用中，move等指令后面通常包含一个后缀。</p><p>对于单字节, 它的后缀表示为d . 双字节, 又叫做字,是word 的首字母, 所以被称为w. double word 叫做双字，实际上是四字节, 对应的操作后缀是l Quadword 表示叫4字，也就是8个字节, 它的后缀是q 。注意一个地址，它的类型也是Quadword, 因为一个地址也是64位的，所以对地址做操作的时候，也是要用q 后缀. 单精度浮点数，它的后缀是ss,  双精度浮点数，它的后缀是sd 。</p><p>在<code>AT&amp;T</code> 汇编语言中, 所有的指令助记符后面都会跟有这样的一个后缀用来去描述当前指令所操作的数据的位长.</p><p>后缀决定了源操作数和目标操作数的位长. 比如说我们用的是moveb, ，注意后面的两个操作数, 也必须是一字节的两个寄存器。</p><p>如果使用move指令, 进行内存访问的时候, 根据后缀决定了我们从内存对应的地址到底访问几个字节的数据, 也就是从那move操作内存的时候，不是只访问那个地址的一个字节的数据。那个地址只是起始地址. 访问几个字节, 是由这个后缀来去决定的。</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3_4%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 3.3 x86寄存器中内存的组织</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_3.3_x86%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_3.3_x86%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87_url.html</guid>
      <pubDate>Fri, 09 Oct 2020 03:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;/../../images/image-20201014161839928.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在正式介绍汇编语言之前，首先介绍一下x86处理器中寄存器的组织形式。在x86系统中，对于所有的程序员都可见的寄存器一共是有16个。这16个我们也把它叫做通用寄存器。&lt;br&gt;包括rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, 以及r8到r15一共16个寄存器。这些以r作为打头的寄存器都是64位寄存器, 也就是说，每个寄存器可以存储8个字节的数据。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img data-src="/../../images/image-20201014161839928.png"></p><p>在正式介绍汇编语言之前，首先介绍一下x86处理器中寄存器的组织形式。在x86系统中，对于所有的程序员都可见的寄存器一共是有16个。这16个我们也把它叫做通用寄存器。<br>包括rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, 以及r8到r15一共16个寄存器。这些以r作为打头的寄存器都是64位寄存器, 也就是说，每个寄存器可以存储8个字节的数据。</p><span id="more"></span><p><img data-src="/../../images/16jicunqi.png" alt="16个通用寄存器"></p><p>汇编语言再去操作这些寄存器的时候，是以这些寄存器的名称作为操作数进行操作的。<br>对这些寄存器的低32位。在汇编语言中可以使用特殊的名称进行直接访问。</p><p>所有的低32位的寄存器的名称, 对于a b c d, s i, d i, s p, b p 都是以e 作为前缀进行访问的, 对于r8到r15的低32位则是增加了一个d 的后缀去访问. 那么这些寄存器是可以单独去访问它的低32位用这样的一个别名。</p><h1 id="x86-32位处理器寄存器形式"><a href="#x86-32位处理器寄存器形式" class="headerlink" title="x86-32位处理器寄存器形式"></a>x86-32位处理器寄存器形式</h1><p>要想真正的去了解64位系统中的寄存器组织，就不能够不了解在x86-32位处理器中的寄存器的组织。</p><p><img data-src="/../../images/image-20201014162545556.png"></p><p>在x86312位系统中, 通用寄存器也就是对于所有程序员都可见的寄存器一共是有8个。它们的名称和64位系统中的寄存器相比, 去掉了r8到r15这8个寄存器, 仍然保留了a b c d, s i, d i, s p, b p 。每个寄存器的位长是32位。在32位系统中，这8个寄存器的低16位也包含着它的别名, 它的别名就是去掉了前缀e。那么就可以作为, 这32位寄存器中的低16位，而使用汇编语言单独进行访问, 尤其特殊的是对于a b c d 4个寄存器来讲, 它们的低8位和高8位也是有别名的。通过这些别名, 也可以实现对特定寄存器中的位进行访问。</p><p>x86-64位指令集是可以对x86-32位指令集进行兼容的。<br>因此, 对于x86-64位系统的处理器中的寄存器进行访问也可以通过上述32位系统中，这些寄存器的别名去访问到寄存器的第16位。对于a b c d 4个寄存器, 它的低八位,和从第八位到第15位，也是可以采用这样的别名来去访问。</p><p><strong>在x86-64位系统和x86-32位系统中, 所有的s p 寄存器, 都有一个特殊的用途, 用来存放帧顶指针。</strong></p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_3.3_x86%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 程序的机器级别表示基础</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%88%AB%E8%A1%A8%E7%A4%BA%E5%9F%BA%E7%A1%80_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%88%AB%E8%A1%A8%E7%A4%BA%E5%9F%BA%E7%A1%80_url.html</guid>
      <pubDate>Tue, 06 Oct 2020 12:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;程序的机器级别表示：基础&quot;&gt;&lt;a href=&quot;#程序的机器级别表示：基础&quot; class=&quot;headerlink&quot; title=&quot;程序的机器级别表示：基础&quot;&gt;&lt;/a&gt;程序的机器级别表示：基础&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="程序的机器级别表示：基础"><a href="#程序的机器级别表示：基础" class="headerlink" title="程序的机器级别表示：基础"></a>程序的机器级别表示：基础</h1><span id="more"></span><p>该章开始就是<strong>整本书，整个课程的真正核心部分</strong>，我们将深入学习机器级别编程，关心计算机为了运行我们的程序，所执行的一串独立的指令。<strong>以汇编语言为媒介，去理解高级语言的种种行为。</strong></p><p>实际上有两种形式的机器程序，一个是在计算机上运行的实际目标代码，它们是一串字节，编码处理器执行的指令。由于实际目标代码难以理解，我们利用汇编代码等去理解其含义，这是没有问题的，因为汇编代码与实际目标代码有一对一的映射关系。不同于以前程序员们直接编写汇编代码，现在汇编代码的生成由编译器负责.</p><p>但是汇编语言仍然对程序员来说至关重要，作为一个桥梁，它将你的程序和这些代码实际在机器上运行的形式连接起来——汇编代码就是它们的中间形式。该课程不会写很多的汇编代码，取而代之的是阅读由C语言编译器GCC生成的汇编语言，理解编译器产生结果与输入它的内容的联系。</p><p><strong>本课程针对是英特尔64位版本的指令集（<code>x86-64</code>）</strong></p><h2 id="3-1-历史展望"><a href="#3-1-历史展望" class="headerlink" title="3.1 历史展望"></a>3.1 历史展望</h2><h3 id="Inter-x86-Processors"><a href="#Inter-x86-Processors" class="headerlink" title="Inter x86 Processors"></a>Inter x86 Processors</h3><p>x86对于英特尔处理器来说是一个口头的称谓，因为第一个芯片被称为8086，随后推出了8286，8386等等，共同点是都有86，所有人们只称它为x86。</p><p>x86有时汇编称为<code>CISC</code>(<code>Complex Instruction Set Computer</code>), 即复杂指令集.</p><h2 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h2><p>假设我们把一个C程序写成两个文件<code>p1.c</code>和<code>p2.c</code>。我们可以用一条<code>Unix</code>命令（<code>Linux</code>系统下）来编译它们。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure><p><code>gcc</code>命令代表的是C语言编译器<code>GCC</code>，<code>-Og</code>选项指示编译器应用某种程度的优化，从而产生遵循原始C代码的整体结构且更易于理解的机器代码。调用更高层次的优化，会提高程序的运行效率，但会使得生成的机器代码更加难以理解。</p><p><code>gcc</code>命令调用整个程序序列，将源代码转换为可执行代码。首先，C语言预处理器（<code>preprocessor</code>）对源代码进行拓展，包括<code>#include</code>命令指定的任何文件（通常为头文件如<code>stdio.h</code>和<code>#define</code>声明指定的任何宏定义。)<code>.c</code>后缀文件经过预处理器后得到<code>.i</code>后缀文件，如这里会产生<code>p1.i</code>和<code>p2.i</code>文件。<code>.i</code>后缀文件仍然是文本文件。第二步，编译器(<code>complier</code>）将<code>.i</code>后缀文件翻译为<code>.s</code>后缀文件，它们是源文件的汇编码版本。之后，汇编程序（<code>assembler</code>）将汇编码转换为二进制机器码文件<code>p1.o</code>和<code>p2.o</code>。此时<code>p1.o</code>和<code>p2.0</code>虽然是二进制文件，但是还不能执行。最后，链接器（<code>linker</code>）将这两个二进制机器码文件和实现库函数的代码（例如<code>printf</code>）合并，并生成可执行代码文件<code>p</code>（由命令行指令<code>-o p</code>所确定）。</p><p>流程图如下</p><p><img data-src="/../../images/image-20200929142625325-1601949350254.png"></p><h3 id="3-2-1机器级代码"><a href="#3-2-1机器级代码" class="headerlink" title="3.2.1机器级代码"></a>3.2.1机器级代码</h3><p>计算机系统采用了几种不同的抽象形式，通过使用了更简单的抽象模型来隐藏实现的细节。其中两个对机器级别的编程来说十分重要。</p><p>第一个是机器级程序的格式和行为是由指令集结构（<code>instruction set architecture </code> or <code>ISA</code>)定义的。大部分的指令集，包括<code>x86-64</code>，描述程序的行为，就好像程序是按顺序执行的，每条指令都是在前一个指令结束时开始。而真实情况是，处理器硬件要复杂的多，它们会同时执行许多指令，同时也采用了保障措施，以确保整体行为符合指令集规定的顺序。</p><p>第二，在机器级程序中使用的内存地址被称做”虚拟地址“（<code>visual addresses</code>）。它提供了看上去像一个巨大的字节数组的内存模型。而内存系统的真实运行模式包含了硬件的多重内存结构和操作系统软件。这会在<code>CS:APP</code>第九章中展开具体讨论。</p><p>编译器大部分的工作都是完全遵循编译顺序的，它将表达在由C语言提供的相对抽象（对机器而言）的运行模型中的程序转换为处理器能够执行的非常基础的指令。而汇编代码在表达上非常接近机器码。相对于机器码中的二进制形式，汇编码采用是一种更可读的文本形式。<strong>理解汇编代码本身以及它和最初的C语言代码的联系</strong>是深入理解计算机执行程序的关键步骤。</p><p><code>x86-64</code>指令集的机器码与最初的C语言代码差别很大。处理器的状态对于C程序员来说通常是隐藏的，仅有部分状态时可见的</p><ul><li><p>程序计数器（<code>program counter</code> or <code>PC</code>, 在<code>x86-64</code>指令集下被称为<code>%rip</code>寄存器)存储下一条要执行的指令在内存中的地址。</p></li><li><p>寄存器文件包含16个用来存储64位值的已命名区域。这些寄存器能够存储地址（对应与C语言中的指针）或者整数数据。一些寄存器被用来记载程序状态的关键部分，其他则用来容纳暂存数据。</p></li><li><p>条件代码寄存器保存最近执行的算术或逻辑指令的状态信息。它们是用来实现数据流中的条件变化，在实现<code>if</code>和<code>while</code>表达式的操作中，它们是必不可少的。</p></li><li><p>向量寄存器能容纳一个或多个整数或者浮点数。</p><p>x86-64架构寄存器一览</p><p><img data-src="/../../images/bc4fgr6WeEOPw5i.png"></p></li></ul><p>机器代码将内存简单的看作一个巨大的可寻址字节数组。C语言中的数据类型，无论是单个数据类型还是聚合数据类型（如<code>array</code>和<code>struct</code>），标量还是向量数据类型，无符号还是有符号数据类型，在机器代码看来都是单个字节或者字节的集合。</p><p>程序所需要的内存，包括对应的可执行机器代码，一些操作系统所需要的信息，一个用于管理过程调用和返回的运行时间堆和用户自主分配的内存空间（比如用<code>malloc</code>函数申请的内存空间）。正如前面所提到的，程序内存使用虚拟地址来寻址。在任意给定的时间里，只有虚拟内存中限定的子范围才是有效的。例如，<code>x86-64</code>虚拟地址用64位表示。在64位机器目前的实施来看，前面的16位必须设置成0，这样做才有可能在<code>64TB</code>范围内指定一个字节。</p><p><img data-src="/../../images/image-20200929200544859.png"></p><p>操作系统管理这些虚拟地址空间，将虚拟地址翻译为在真正的处理器内存中值的物理内存。</p><p>一个单一的机器指令，只能执行一个非常基础的操作。编译器必须要产生这些指令的序列去实现程序的种种功能。</p><h3 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> t = mult(x, y);</span><br><span class="line">    *dest = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在命令行中用<code>-S</code>来查看由C语言编译器产生的汇编代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure><p>GCC编译器运行，产生汇编文件<code>mstore.s</code>后不再继续执行下一步操作。</p><p>汇编文件会包含各种各样的声明，包括以下几行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">pushq %rbx</span><br><span class="line">movq %rdx, %rbx</span><br><span class="line">call mult2</span><br><span class="line">movq %rax, (%rbx)</span><br><span class="line">popq %rbx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>在代码中每个缩进行都对应一条机器指令。比如说<code>pushq</code>表明寄存器中的内容<code>%rbx</code>应该被推送到程序栈中。所有关于本地变量名或数据类型的信息都已被删除。</p><p>如果我们用<code>-c</code>命令，GCC会编译+处理代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure><p>这会产生二进制格式文件<code>mstore.o</code>，因此不能被直接查看。在<code>mstore.o</code>文件1,368字节的文件中有这样的一个14字节的十六进制文字序列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure><p>这些代码对应于前面列出的汇编指令。从中我们得出，<strong>机器执行的程序只是一个编码一系列指令的字节序列。</strong>机器对源代码几乎一无所知。</p><p>为了看到机器代码文件的内容，我们需要用到一类名为<strong>反编译器</strong>（<code>disassemblers</code>的程序。这些程序从机器代码中生成类似于汇编的格式。<code>Linux</code>系统中的<code>OBJDUMP</code>能实现这一功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">liunx&gt; </span><span class="language-bash">objdump -d mstore.o</span></span><br></pre></td></tr></table></figure><p>反编译结果如下图所示</p><p><img data-src="/../../images/image-20200929183022928.png" alt="image-20200929183022928">一些机器代码和它的反编译表示的特征值得说明一下</p><ul><li><p><code>x86-64</code>指令长度为1到15个字节。指令编码的设计使常用的指令和操作数较少的指令比不常用的指令或操作数较多的指令所需的字节数更少。</p></li><li><p>指令格式的设计使是这样的，从一个给定的起始位置开始，有一个唯一的字节解码成机器指令。例如，只有指令<code>pushq %rbx</code>可以从字节值53开始。</p></li><li><p>反编译程序纯粹根据机器码文件中的字节序列来确定汇编代码。它不需要访问程序的源代码或汇编码版本。</p></li><li><p>反编译程序对指令使用了与gcc生成的汇编代码稍有不同的命名方式。</p><p>产生实际可运行代码需要在对象代码文件集上运行一个链接器。这些对象代码文件中必须包含主函数<code>main</code>。</p><p>假设在文件<code>main.c</code>中有如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>, <span class="type">long</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 --&gt; %ld\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Linux</code>命令行中，我们用如下的命令就可以生成可执行文件<code>prog</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gccc -Og -o prog main.c mstore.c</span></span><br></pre></td></tr></table></figure><p><code>prog</code>文件增长到8,655个字节，因为它不仅包含了我们为该过程提供的机器码，还有用来与操作系统互动，开始和终止这段代码的程序。</p><p>我们来反编译下<code>prog</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">objdump -d prog</span></span><br></pre></td></tr></table></figure><p>反编译器会提取各种代码序列，包含以下内容。</p></li></ul><p><img data-src="/../../images/IMG_1095(20200929-184140).JPG" alt="IMG_1095(20200929-184140)"></p><p>这个代码与之前<code>mstore.c</code>文件反编译得到的几乎一致。</p><p><code>mstore.c</code>反编译结果（部分）</p><p><img data-src="/../../images/image-20200929183022928-1601949386047.png" alt="image-20200929183022928-1601949386047"></p><p>一个重要的不同是在左边列出的地址不同。链接器已将该代码的位置转移到不同的地址范围。第二个不同是链接器已经填好了调用函数<code>mult2</code>时<code>callq</code>指令应该使用的地址。链接器的任务之一用为函数调用匹配这些函数可执行代码的位置。最后一个不同是我们会在前一个反编译结果中看到两行额外的代码（代码行8，9）。尽管它们出现在return 指令的后面，但是实际上对程序没有任何影响。它们的作用是占位，使代码到达16个字节的长度，使下一段代码在内存系统性能上有更好的放置位置。</p><p>机器指令例子</p><p><img data-src="/../../images/image-20201006130849519.png" alt="image-20201006130849519"></p><h3 id="3-2-3-汇编语言格式"><a href="#3-2-3-汇编语言格式" class="headerlink" title="3.2.3 汇编语言格式"></a>3.2.3 汇编语言格式</h3><p>本课程采用的是<code>AT&amp;T</code>格式汇编语言。格式为：</p><p><img data-src="/../../images/image-20201006133443721.png" alt="image-20201006133443721"></p><p>标号是可选的，标号用来显示右边的指令在内存中的位置，不会生成机器指令。</p><p>操作码是必选的，操作码用来说明当前指令所进行的行为，例如加减乘除等算术运算。</p><p>操作数的个数可以是0个，1个或者两个，两个操作书之间用逗号分隔。操作数的作用是说明当前指令所操作的数据对象。控制指令等不需要操作数。操作数1是源操作数，操作数2是目标操作数。</p><p>带解释的汇编语言程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void multstore(long x, long y, long *dest)</span><br><span class="line"> // x in %rdi, y in %rsi, dest in %rdx</span><br><span class="line"> multstore:</span><br><span class="line">pushq %rbx# Save %rbx</span><br><span class="line">moveq %rdx, %rbx# Copy dest to %rbx</span><br><span class="line">call mult2# Call mult(x, y)</span><br><span class="line">movq %rax, (%rbx)# Store result at *dest</span><br><span class="line">popq %rbx# Restore %rbx</span><br><span class="line">ret # return</span><br></pre></td></tr></table></figure><h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><p>由于历史上曾经从16位结构转换到32位架构，Intel用“word”指16字节的数据类型。因此32位数据类型被乘坐“double words”，以此类推。</p><p><img data-src="/../../images/IMG_1098(20201006-135031).JPG" alt="IMG_1098(20201006-135031)"></p><center>x86-64指令集中C语言数据类型的大小</center><p>操作码后必须跟上前缀(<code>Assembly-code suffix</code>), 使用什么数据类型，后面的操作数就必须跟该数据类型一样的位数的寄存器。</p><h2 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h2><p>一个x86-64指令集下的CPU包含一组16个存储64位值的通用寄存器(<code>general-purpose register</code>)。这些寄存器用来存储整数和指针数据。它们的名字以<code>%r</code>开头，但是由于历史原因，之后的名称命令规则就不同了。<img data-src="/../../images/IMG_1099(20201006-140309).JPG" alt="IMG_1099(20201006-140309)"></p><center> 处理器中的16个寄存器</center><p>最初的8086处理器有8个16位寄存器，即从<code>%ax</code>到<code>%bq</code>。</p><p>随着32位的拓展，寄存器扩充到了32位，即图中从<code>%eax</code>到<code>%ebq</code>。</p><p>之后有拓展到了64位，于是寄存器扩充到了64位，即图中从<code>%rax</code>到<code>%rbq</code>。此外，8个新的寄存器也被添加进来，它们有了新的命名规则，即从<code>%r8</code>到<code>%r15</code>。</p><p>汇编语言操作这些寄存器的时候，是以这些寄存器的名称作为操作数进行操作的。 </p><p>对于这些寄存器的低32位，在汇编语言中可以使用特殊的名称进行直接访问。对于<code>%rax</code>到<code>%rbq</code>，是以<code>%eax</code>到<code>%ebq</code>进行访问，对于<code>%r8</code>到<code>%r15</code>，是以<code>%r8d</code>到<code>%15d</code>进行访问的。</p><p>不同的寄存器在程序中担任不同的角色。</p><p>其中最特殊的是栈指针，即<code>%rsp</code>， 用来存放栈顶指针。</p><h3 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h3><h3 id="数据访问指令"><a href="#数据访问指令" class="headerlink" title="数据访问指令"></a>数据访问指令</h3><h4 id="Moving-data"><a href="#Moving-data" class="headerlink" title="Moving data"></a>Moving data</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq Source, Dest# 移动64位数据</span><br></pre></td></tr></table></figure><h5 id="操作数种类"><a href="#操作数种类" class="headerlink" title="操作数种类"></a>操作数种类</h5><ol><li> 立即数(<code>Immediate</code>)</li></ol><p>   通常是一个为常数的整数类型，例如 <code>$0x400</code>, <code>$-533</code>。</p><p>   与C语言常数类似，但额外添加了<code>$</code>前缀。</p><p>   有1, 2, 4和8字节三种编码方式，具体取决于操作码的最后一个字母，该字母用来描述该次操作所涉及的数据位长。</p><ol start="2"><li><p>寄存器(Register)</p><p>16个通用寄存器都可以作为操作数</p><p>例如：<code>%rax</code>, <code>%r13</code></p><p><code>%rsp</code>有特殊用途，用于存放栈顶数据地址。</p></li><li><p>内存(<code>Memory</code>)</p><p>move指令可以通过访问内存中某个地址，从内存中加载数据或者存放数据。</p><p>例如：(%rax) 用来描述 （）里存放的数据实际上是一个地址,加上括号，就是去访问<code>%rax</code>所在地址的数据。</p></li></ol><h5 id="move指令组合"><a href="#move指令组合" class="headerlink" title="move指令组合"></a>move指令组合</h5><p><img data-src="/../../images/image-20201006153832873.png" alt="image-20201006153832873"></p><h5 id="move指令实例"><a href="#move指令实例" class="headerlink" title="move指令实例"></a>move指令实例</h5><p><img data-src="/../../images/image-20201006163553131.png" alt="image-20201006163553131"></p><p><code>ret</code>代表是C语言中的过程返回操作，类似<code>return</code>。</p><p>函数调用前</p><p><img data-src="/../../images/image-20201006164033124.png" alt="image-20201006164033124"></p><p>函数调用后</p><p><img data-src="/../../images/image-20201006164236498.png" alt="image-20201006164236498"></p><h4 id="完全内存寻址模式"><a href="#完全内存寻址模式" class="headerlink" title="完全内存寻址模式"></a>完全内存寻址模式</h4><p>在x86汇编指令中，内存寻址是十分灵活的。</p><p><img data-src="/../../images/image-20201006183926488.png" alt="image-20201006183926488"></p><p>D(R<del>b</del>, R<del>i</del>, S) 四元组</p><p>D: 基于内存地址的偏移量，有符号数.是1，2，4，8字节的一个常数。</p><p>R<del>b</del>：表示内存的基地址：可以是所有的16个寄存器。</p><p>R<del>i</del>:  索引寄存器：除了<code>%rsp</code>，其他寄存器都能表示R<del>i</del>。</p><p>S:  表示大小。1，2，4，8中的一个. 因为高级语言处理数据类型时，基本数据类型的宽度只有1，2，4，8字节。</p><p>Mem[Reg[R<del>b</del>]+S×Reg[R<del>i</del>]+D]: R<del>b</del>寄存器中的值 + R<del>i</del>寄存器中的值×S + D，<strong>运算值作为实际内存的访问地址。</strong></p><p>特例：</p><ol><li><p>某些元素可以不出现在表达式中，如</p><p>(R<del>b</del>, R<del>i</del>)                Mem[ Reg[R<del>b</del>] + Reg[R<del>i</del>] ] 此时 D = 0， S = 1</p><p>D(R<del>b</del>, R<del>i</del>)                Mem[ Reg[R<del>b</del>] + Reg[R<del>i</del>] + D] 此时  S = 1</p><p>(R<del>b</del>, R<del>i</del>, S)                Mem[ Reg[R<del>b</del>] + S * Reg[R<del>i</del>] ] 此时 D = 0</p></li></ol><p><strong>实例</strong></p><p><img data-src="/../../images/image-20201006185602512.png" alt="image-20201006185602512"></p><p>采用完全内存寻址模式，不是将最后代表”Address“的数值赋值给目标操作数。而是将这个地址所指向的内存中的数据赋值给内存操作数。</p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="地址运算指令"><a href="#地址运算指令" class="headerlink" title="地址运算指令"></a>地址运算指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaq Src, Dst# lea为操作码，q为后缀</span><br></pre></td></tr></table></figure><p>Src, 源操作数，通常是一个类似于寻址模式的四元组，类似于D(R<del>b</del>, R<del>i</del>， S)。四元组用来进行地址表达式的计算。</p><p>Dst，目标操作数，通常是一个寄存器，用来存放算术运算的地址的结果。</p><p>地址运算指令用来运算无内存引用的地址计算</p><p>比如 p = &amp;x[i]。计算数组x的下标为i的元素所在索引的地址并赋值给指针p。是直接赋值地址。<strong>lea指令不会对内存进行任何访问。</strong> </p><p>计算方法： 算出x的基地址，在算出x中每个元素的大小并乘以下标i得到最后的位置。</p><p><img data-src="/../../images/image-20201006195213558.png" alt="image-20201006195213558"></p><p>%rdi寄存器用来存放传入的long x，</p><p>此外，lea指令也可以用作算术运算。</p><h3 id="3-5-2-双操作数"><a href="#3-5-2-双操作数" class="headerlink" title="3.5.2 双操作数"></a>3.5.2 双操作数</h3><p><strong>一些算术操作指令</strong></p><p><img data-src="/../../images/image-20201006210920968.png" alt="image-20201006210920968"></p><p>目标操作数只能是内存或者寄存器，不能是立即数。源操作数三者都可以。</p><p>为什么不区分无符号和有符号整数运算？</p><p>加法运算对二者在位级别上的运算一致，乘法减法也是如此</p><p>除法运算分为有符号数除法和无符号数除法。</p><h3 id="3-5-3-单运算操作数"><a href="#3-5-3-单运算操作数" class="headerlink" title="3.5.3 单运算操作数"></a>3.5.3 单运算操作数</h3><p><img data-src="/../../images/image-20201006212009656.png" alt="image-20201006212009656"></p><p>实例</p><p><img data-src="/../../images/image-20201006212208668.png" alt="image-20201006212208668"></p><p>在汇编语言中，由<code>rax</code>寄存器存储最终的返回值。并由<code>ret</code>指令返回。</p><p>从中我们发现的现象：</p><ol><li><p>指令和C语言源代码的顺序可能不同。</p></li><li><p>一些表达式需要多个指令去完成。</p></li><li><p>一些指令可以包含多个表达式。</p></li><li><p>局部（临时）变量不一定要在内存中存储。声明了变量也不一定浪费内存。因为将变量放在寄存器中运算速度远远大于将变量放在内存中，编译器会优先把局部变量放在寄存器中。因此，多用局部变量或者表达式不一定会增加程序运行时间。</p></li></ol><h3 id="3-5-5-逻辑运算示例"><a href="#3-5-5-逻辑运算示例" class="headerlink" title="3.5.5 逻辑运算示例"></a>3.5.5 逻辑运算示例</h3><p>在x86-64处理器上，如果运行一个32位指令，意味着最后操作的目标寄存器的高32位会被清0。</p><p><img data-src="/../../images/image-20201007094151811.png" alt="image-20201007094151811"></p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%88%AB%E8%A1%A8%E7%A4%BA%E5%9F%BA%E7%A1%80_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 2.3 整数的运算</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_2_3_%E6%95%B4%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_2_3_%E6%95%B4%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97_url.html</guid>
      <pubDate>Mon, 05 Oct 2020 10:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;2-3-整数的运算&quot;&gt;&lt;a href=&quot;#2-3-整数的运算&quot; class=&quot;headerlink&quot; title=&quot;2.3 整数的运算&quot;&gt;&lt;/a&gt;2.3 整数的运算&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="2-3-整数的运算"><a href="#2-3-整数的运算" class="headerlink" title="2.3 整数的运算"></a>2.3 整数的运算</h1><span id="more"></span><h2 id="2-3-1-无符号整数的加法"><a href="#2-3-1-无符号整数的加法" class="headerlink" title="2.3.1 无符号整数的加法"></a>2.3.1 无符号整数的加法</h2><p>假设有两个w位的无符号整数x与y，当我们计算它们的和时，会发现如下两种情况。</p><ol><li><p>0 &lt;= x+y &lt;= 2^w^-1</p><p>这时我们可以直接用一个唯一的w位二进制数来表示<code>x+y</code>的值。</p></li><li><p>x+y &gt; 2^w^-1</p><p>这种情况称为”溢出“(overflow)。大部分编程语言，包括C语言，仅仅支持固定位数的运算，也就是说两个w位的整数相加，其结果必定是w位的整数，不可能会产生w+1位的整数。<strong>二进制的溢出仅仅会溢出一位。</strong></p><p>两个w位的整数相加从算术上看至多会产生w+1位整数。当产生”溢出“时，计算机会抛弃运算结果的最高位，即第w+1位，留下其余w位作为运算结果。</p><p>例如 考虑以下4位无符号整数运算</p><p>x = [1001] y = [1100]</p><p>从算术结果上来看， sum(x, y) = [10101]， 但是计算机不支持在溢出时进位，所以运算结果需要砍掉最高位的1。计算机的实际运算结果 x+y = [0101]。</p></li></ol><p>综上所述，w位无符号整数的加法运算结果实际上就是   实际运算结果 mod 2^w^。</p><blockquote><p>在执行C语言过程中，”溢出“并不会报错。</p><p>这就需要开发者去留心，去警惕可能会发生的溢出现象。</p><p>当然也可以用专门的函数去检测”溢出现象“</p></blockquote>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be added without overflow*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uadd_ok</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">unsigned</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = x+y;</span><br><span class="line">    <span class="keyword">return</span> sum &gt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当发生溢出时，函数就会返回0， 不发生溢出时返回1</span></span><br></pre></td></tr></table></figure><h2 id="2-3-2-有符号整数（补码）的加法"><a href="#2-3-2-有符号整数（补码）的加法" class="headerlink" title="2.3.2 有符号整数（补码）的加法"></a>2.3.2 有符号整数（补码）的加法</h2><p>对于w位有符号整数的加法，就要更复杂一些了。当两者的和小于-2^w-1^，或者大于2^w-1^-1时，就会发生溢出现象。</p><p>但即使更加复杂，有符号整数的加法遵循的原则与无符号整数无异，仍然时去掉溢出的最高位。<strong>不同点是有符号整数的加法的剩余位数必须视作补码</strong>。</p><ol><li><p>x+y &lt; -2^w-1^</p><p>此时会发生”负溢出“（<code>negative overflow</code>）。计算机会自动抛弃运算产生的最高位，留下其余w位作为运算结果</p><p>eg1 当w=4, x = [1000], y = [1011], 从算术结果上来看，sum(x, y) = [10011], 抛弃最高位后，计算机的实际运算结果 x+y = [0011] = (3)<del>10</del></p></li><li><p>-2^w-1^ &lt;= x+y &lt;= 2^w-1^-1</p><p>此时计算机不发生溢出现象。计算机得到的实际结果等于算术结果。</p><p>eg2 当w=4， x =1000, y = 0101, 算术结果和计算机的实际运行结果都为sum(x+y) = [1101] = (-3)<del>10</del></p></li><li><p>x+y &gt; 2^w-1^-1</p><p>此时会发生”正溢出“（<code>positive overflow</code>）。计算机会自动抛弃运算产生的最高位，留下其余w位作为运算结果</p><p>eg1 当w=4, x = [0101], y = [0101], 从算术结果上来看，sum(x, y) = [1010]..计算机的实际运算结果也是 x+y= [1010] = (-6)<del>10</del></p></li></ol><p>那我们如何检查和分辨出正溢出和负溢出呢？规律如下</p><ol><li>当 x &gt; 0, y &gt; 0, 且计算机的实际运算结果 x+y 小于零时，就说明发生了正溢出现象。</li><li>当 x &lt; 0,  y &lt; 0, 且计算机的实际运算结果 x+y 大于零时, 就说明发生了负溢出现象。</li></ol><p>我们可以用以下代码来检验溢出(int 类型有符号整数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be added without overflow*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tadd_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = x+y;</span><br><span class="line">    <span class="type">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos_over = x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> !neg_over &amp;&amp; !pos_over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h2><h3 id="求有符号正数的相反数"><a href="#求有符号正数的相反数" class="headerlink" title="求有符号正数的相反数"></a>求有符号正数的相反数</h3><p>第一种方法：</p><p>我们知道了一个有符号整数的二进制表示，求出该整数的相反数的二进制表示只需要下列两步</p><ol><li><p>将二进制的所有位取反。</p></li><li><p>将1.得到的结果的最后一位再加1.</p></li></ol><p>eg1. (5)<del>10</del> = (0101)<del>2</del>, 将二进制所有位取反后得到(1010)<del>2</del>， 最后一位加1得到 (1011)<del>2</del>, 按照补码的运算， (1011)<del>2</del> = (5)<del>10</del></p><p>第二种方法：</p><p>找出二进制表示中最右边的1，该1的位置左侧取反，右侧不变。</p><p>eg2. (5)<del>10</del> = (010<em><strong>1</strong></em>)<del>2</del>, 最右边的1已经用粗斜体表示，按照规则转化为 (1011)<del>2</del>。按照补码的运算， (1011)<del>2</del> = (5)<del>10</del></p><p>对于一个w位整数x，x的非（在算术中称为相反数）的规律如下 TMin指x所能表示的最小值。<br>$$<br>-x = \begin{cases}<br>TMin &amp; \text{ if } x= TMin \<br>-x &amp; \text{ if } x&gt; TMin<br>\end{cases}<br>$$</p><p>解释以下唯一的例外，以4位二进制为例， TMin = (1000)<del>2</del>, 所有位取反得到(0111)<del>2</del>, 最后一位加1后得到 (1000)<del>2</del>, 正好是本身。<strong>这是表达式中唯一的例外。</strong></p><h2 id="2-3-4-无符号数乘法"><a href="#2-3-4-无符号数乘法" class="headerlink" title="2.3.4 无符号数乘法"></a>2.3.4 无符号数乘法</h2><p>w位无符号整数的范围为 0 ~ 2^w^-1, 两个w位整数相乘，范围为 0 ~(2^w^-1)^2^, 至少需要2w位才能完成表示。但C语言中仍然用w位表示二者乘积，即抛弃前w位，只留下后w的数据, 在公式中结果用$x * _{u}^{w}\textrm{y}$表示。则<br>$$<br>x * _{w}^{u}\textrm{y} = (x \cdot y ) mod  2^{w}<br>$$</p><h2 id="2-3-5-有符号数乘法"><a href="#2-3-5-有符号数乘法" class="headerlink" title="2.3.5 有符号数乘法"></a>2.3.5 有符号数乘法</h2><p>与无符号数乘法规则基本相同。</p><p>唯一的不同点是，<strong>最后的结果是用补码表示的</strong>。我们用$x * _{t}^{w}\textrm{y}$代表C语言中的乘积值。则<br>$$<br>x * _{w}^{t}\textrm{y} = (x \cdot y ) mod  2^{w}<br>$$</p><p><img data-src="/../../images/IMG_1097(20201005-104026).JPG" alt="IMG_1097(20201005-104026)"></p><p>下面用一个程序来检验乘法运算时的溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether arguments can be multiplied without overflow */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmult_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x*y;</span><br><span class="line">    <span class="comment">/* Either x is zero, or dividing p by x gives y */</span></span><br><span class="line">    <span class="keyword">return</span> !x || p/x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-6-常数的乘除法"><a href="#2-3-6-常数的乘除法" class="headerlink" title="2.3.6 常数的乘除法"></a>2.3.6 常数的乘除法</h2><p>计算机中乘法的运算速度相对于加减法，位运算，移位运算来说时比较慢的。因此，我们可以考虑用较快的位运算，移位等操作来代替缓慢的乘法。</p><h3 id="用移位实现“乘以2的幂“"><a href="#用移位实现“乘以2的幂“" class="headerlink" title="用移位实现“乘以2的幂“"></a>用移位实现“乘以2的幂“</h3><ul><li>无论有符号数还是无符号数<ul><li> u&lt;&lt; k 可得到 u * 2^k^ </li></ul></li></ul><p>如果运算结果溢出，那么遵守和前面乘法一样的规则，去掉溢出的高位，保留原本的位数。</p><p>c编译器会通过移位，加法和减法的组合来消除许多整数与常数相乘的情况。</p><p>例如 表达式 x*14， 因为 14 = 2^3^ + 2^2^ + 2^1^, 所以编译器将这个乘法运算转变为</p><p> (x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)**注意，移位运算与加减法在一个表达式中时一定要加括号！)**，即将一次乘法运算转变为3个移位运算和两个加法运算。 </p><h3 id="用移位实现”除以2的幂“"><a href="#用移位实现”除以2的幂“" class="headerlink" title="用移位实现”除以2的幂“"></a>用移位实现”除以2的幂“</h3><p>在机器中除法的运算比乘法更慢。</p><ul><li><p>整数“除以2的幂”的商</p><ul><li><p>u &gt;&gt; k 得到  小于等于（u / 2^k^ ）的最大整数</p></li><li><p> 无符号整数使用逻辑右移，有符号整数使用算术右移。</p></li><li><p>右移会产生二进制小数，在机器运算最后的结果中被去掉。</p></li></ul></li></ul><p>具体如图所示（以无符号整数为例子）</p><p><img data-src="/../../images/image-20201005185835285.png" alt="image-20201005185835285"></p><p>从中我们可以看出，在C语言中整数与整数做除法得到的一定还是个整数，而且得到的整数是小于等于（u / 2 ^k^ ）的最大整数。</p><p>此外，还可以通过特殊的运算得到 大于等于（u/2^k^)的最小整数。具体见CSAPP英文版p141.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return x&gt;&gt;4</span><br></pre></td></tr></table></figure><h2 id="2-3-8-总结"><a href="#2-3-8-总结" class="headerlink" title="2.3.8 总结"></a>2.3.8 总结</h2><h3 id="算术运算基本规则"><a href="#算术运算基本规则" class="headerlink" title="算术运算基本规则"></a>算术运算基本规则</h3><p>加法：</p><ul><li>无/有符号数的加法：正常加法后再截断，位级的运算相同</li></ul><p>乘法：</p><ul><li>无/有符号数的乘法: 正常乘法后加截断操作,位级运算相同</li></ul><h3 id="使用无符号整数时的常见错误"><a href="#使用无符号整数时的常见错误" class="headerlink" title="使用无符号整数时的常见错误"></a>使用无符号整数时的常见错误</h3><ul><li><p>忽略有符号数隐式转换(casting)到无符号数。</p></li><li><p>无符号数在运算过程中在数学算术上会产生负数结果，在计算机中转换为正数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WARNING: This is buggy code */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">sum_elements</span><span class="params">(<span class="type">float</span> a[], <span class="type">unsigned</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;= length<span class="number">-1</span>; i++)<span class="comment">// bug句需纠正</span></span><br><span class="line">        result += a[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，当<code>length=0</code>时， 第一次判断条件中length-1算术结果为-1，但是无符号整数的运算规则可知，实际产生结果将是一个相当大的正数。</p><p>纠正</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; length; i++)</span><br></pre></td></tr></table></figure></li><li><p>不知道一些函数方法默认返回无符号整数，采用有符号整数的算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether string s is longer than string t*/</span></span><br><span class="line"><span class="comment">/* a buggy function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strlonger</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;<span class="comment">// 待修改代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<strong>strlen函数的返回值是无符号整数。</strong>无符号整数的减法得到的仍然是无符号整数！除非s数组与t数组长度相同，否则该函数输出均为1.</p><p>纠正</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(s) &gt; <span class="built_in">strlen</span>(t)</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_2_3_%E6%95%B4%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAPP 2.1 信息的存储</title>
      <link>http://zhangchunxian.github.io/posts/CSAPP_2_1_%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/CSAPP_2_1_%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8_url.html</guid>
      <pubDate>Sun, 04 Oct 2020 03:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;前言：这篇博文是我学习&lt;em&gt;Computer Systems: A Programmer’s Perspective&lt;/em&gt;这本书整理的笔记，同时参考了B站@刘迪望和@九曲阑干等up主的翻译和原创视频，力求尽我所能将这本神书的笔记写到最好。&lt;/p&gt;
&lt;h2 id=&quot;2-1-信息的存储&quot;&gt;&lt;a href=&quot;#2-1-信息的存储&quot; class=&quot;headerlink&quot; title=&quot;2-1 信息的存储&quot;&gt;&lt;/a&gt;2-1 信息的存储&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>前言：这篇博文是我学习<em>Computer Systems: A Programmer’s Perspective</em>这本书整理的笔记，同时参考了B站@刘迪望和@九曲阑干等up主的翻译和原创视频，力求尽我所能将这本神书的笔记写到最好。</p><h2 id="2-1-信息的存储"><a href="#2-1-信息的存储" class="headerlink" title="2-1 信息的存储"></a>2-1 信息的存储</h2><span id="more"></span><h2 id="1-信息存储"><a href="#1-信息存储" class="headerlink" title="1. 信息存储"></a>1. 信息存储</h2><p>通常情况下，程序将内存视为一个非常大的数组，数组的元素由一个个字节(<code>Byte</code>)表示，每个字节都有一个唯一的数字来表示，我们称之为地址（address）。这些所有地址的集合就称为虚拟地址空间（Virtual Address Space）。</p><h3 id="字节（Byte）"><a href="#字节（Byte）" class="headerlink" title="字节（Byte）"></a>字节（Byte）</h3><p>一个字节是由8个位（bit）组成，在二进制表示法中，每一个值可能由两种状态，0或者1。当这8个位全为零时，表示一个字节的最小值。当这8个位全为1时，表示最大值(大多数情况下)。如果用十进制来表示，那么一个字节的取值范围就在0~255（包含0和255）之间。我们把这种按照一位一位表示数据的方式称为位模式。</p><p>我们引入16进制来表示位模式，对于十六进制，是由0-9和A-F来表示16个可能的值。在C语言中，十六进制是以0x开头的，这个X可大写可小写，字母部分同样部分大小写。</p><h3 id="字长（word-size）"><a href="#字长（word-size）" class="headerlink" title="字长（word size）"></a>字长（word size）</h3><p>任何一个机器都有一个“字长”，字长是地址的名义长度。</p><p>地址指向计算机中指定字节的位置，相邻字的地址相差4（32位机器）或 8（64位机器）。</p><p><img data-src="/../../images/image-20201005195903725.png" alt="image-20201005195903725"></p><p>字长决定了虚拟地址空间的上限。对于一个字长位w位的机器，虚拟地址的范围时0~2的w次放减1。近些年，高性能服务器，个人电脑以及智能手机已经完成了从32位字长到64位字长的迁移。对于32位（32字长）的机器，虚拟地址空间最大位4GB，而64位的机器，虚拟地址空间最大位2^32^*4GB（16EB）。在迁移过程中，64位的机器做了向后兼容，因此位32位机器编译的程序也可以运行在64位机器上。通过特定命令可以在64位机器上编译生成32位机器上运行的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 32bit program</span></span></span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -m32 -o hello32 hello.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 64bit program</span></span></span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -m64 -o hello64 hello.c</span></span><br></pre></td></tr></table></figure><p>hello32可以在32位和64位机器上均可运行，但hello64只能运行在64位的机器上。</p><p>对于32位和64位程序，主要的区别还是在于程序是如何编译的，而不是运行机器的类型。</p><p>C语言中，支持整数和浮点数多种数据格式。</p><table><thead><tr><th>C declaration</th><th></th><th>Bytes</th><th></th></tr></thead><tbody><tr><td>signed</td><td>unsigned</td><td>32-bit</td><td>64-bit</td></tr><tr><td>[signed]char</td><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td></td><td>4</td><td>8</td></tr><tr><td>float</td><td></td><td>4</td><td>4</td></tr><tr><td>double</td><td></td><td>8</td><td>8</td></tr></tbody></table><p><strong>以上表格内容需牢记</strong></p><p>对于我们需要存储的数据，我们需要搞清楚该数据的地址是什么，以及数据在内存中如何排布的。</p><p>通过在不同的系统上运行字节打印程序，可以打印输出程序对象的字节表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>, start[i]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">// byte_pointer 强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节的序列，而不是这个对象原始的数据类型。</span></span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Result</strong></p><table><thead><tr><th align="center">Machine</th><th>Value</th><th>Type</th><th>Byte(hex)</th></tr></thead><tbody><tr><td align="center">Linux 32</td><td>12,345</td><td>int</td><td>39 30 00 00</td></tr><tr><td align="center">Windows</td><td>12,345</td><td>int</td><td>39 30 00 00</td></tr><tr><td align="center">Sun</td><td>12,345</td><td>int</td><td>00 00 30 39</td></tr><tr><td align="center">Linux 64</td><td>12,345</td><td>int</td><td>39 30 00 00</td></tr></tbody></table><table><thead><tr><th align="center">Machine</th><th>Value</th><th>Type</th><th>Byte(hex)</th></tr></thead><tbody><tr><td align="center">Linux 32</td><td>12,345.0</td><td>float</td><td>00 e4 40 46</td></tr><tr><td align="center">Windows</td><td>12,345.0</td><td>float</td><td>00 e4 40 46</td></tr><tr><td align="center">Sun</td><td>12,345.0</td><td>float</td><td>46 40 e4 00</td></tr><tr><td align="center">Linux 64</td><td>12,345.0</td><td>float</td><td>00 e4 40 46</td></tr><tr><td align="center">虽然整型和浮点数都是对数值12345进行编码，但是他们却有着完全不同的字节模式</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th align="center">Machine</th><th>Value</th><th>Type</th><th align="center">Byte(hex)</th></tr></thead><tbody><tr><td align="center">Linux 32</td><td>&amp; ival</td><td>int*</td><td align="center">e4 f9 ff bf</td></tr><tr><td align="center">Windows</td><td>&amp; ival</td><td>int*</td><td align="center">b4 cc 22 00</td></tr><tr><td align="center">Sun</td><td>&amp; ival</td><td>int*</td><td align="center">ef ff fa 0c</td></tr><tr><td align="center">Linux 64</td><td>% ival</td><td>int*</td><td align="center">b8 11 e5 ff ff 7f 00 00</td></tr></tbody></table><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h2 id="2-1-4-字符串的表示"><a href="#2-1-4-字符串的表示" class="headerlink" title="2.1.4 字符串的表示"></a>2.1.4 字符串的表示</h2><p>C中的字符串是由null结尾的一组字符。每个字符都按照某种标准的编码方式表示，最常见的编码标准是ASCII码。</p><p>如对照ASCII表，字符串“123456”由16进制 <strong>31 32 33 34 35 00</strong>表示。（在十六进制中用 <strong>0x00</strong> 表示  <code>NULL</code>）。只要是采用了ASCII码的编码标准的计算机系统，字符串的表示方式都是一样的，在这一点上字符数据比二进制数据更加具有独立性。</p><p>在C语言中<code>strlen</code>函数计算字符串的长度时忽略最后结尾的NULL，返回<code>size_t</code> (the unsigned integer type)类型的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>]=<span class="string">&quot;Program&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">20</span>]=&#123;<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using the %zu format specifier to print size_t</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of string a = %zu \n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length of string b = %zu \n&quot;</span>,<span class="built_in">strlen</span>(b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length of <span class="built_in">string</span> a = <span class="number">7</span></span><br><span class="line">Length of <span class="built_in">string</span> b = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>由于每种数据类型的编码规则都是不同的，所以二进制代码在不同的硬件或者操作系统上一般都是互不兼容的。ASCII码的广泛应用，使不同公司制作的计算机，能相互交换数据。但它有个限制：它是为英语设计的。</p><p>幸运的是，一个字节有八位，可以表示256个不同的值。ASCII码仅仅规定了前128个二进制数的字符表示，因此第128位到255位字符就被空缺出来，给各个国家自己规定标准的编码方式。这些保留下来给每个国家自己安排 准，在一个国家的电脑上打开另一个国家的语言的文档，不可避免的会出现乱码问题。</p><p>随着计算机在亚洲兴起，这种做法彻底失效了。比如汉语这样的语言有成千上万的字符，根本没有办法用8位来表示所有的字符。</p><p>所以Unicode诞生了，统一了所有编码的标准。最常见的Unicode是16位的，有超过一百万个位置，对每个语言的每个字符都够了，甚至还有多余的位置存放数学符号以及Emoji。</p><p>就像ASCII用二进制来表示字母一样，其他格式，比如MP3或者GIF，用二进制编码声音/颜色，表示照片，电影和音乐。</p><h2 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h2><p>C语言中的逻辑运算符有<code>||</code>, <code>&amp;&amp;</code> 和 <code>!</code>,对应于逻辑操作中的 <code>OR</code>, <code>AND</code>, <code>NOT</code>。<strong>注意不要将逻辑运算符与位运算符<code>|</code>, <code>&amp;</code>, <code> ^</code> 弄混，它们的操作是截然不同的。</strong></p><p>C语言的逻辑运算符一个重要的特点是，如果在前一个参数就能判断结果表达的真假，那么后面的参数将不做考虑，无论它们有效与否。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp; <span class="number">5</span>/b</span><br></pre></td></tr></table></figure><p>若参数a为假，则整个表达式的真值可以确认为假，那么参数 5/b的真值将不做考虑，即使b的值为零，即5/b本身为无效表达式，都不会导致编译器报错。</p><h2 id="2-1-9-C语言中的移位操作"><a href="#2-1-9-C语言中的移位操作" class="headerlink" title="2.1.9 C语言中的移位操作"></a>2.1.9 C语言中的移位操作</h2><p>C语言的逻辑位移分为左移和右移。其中右移操作分为两种，算术右移和逻辑右移。</p><p>算数右移以0来填充左边的由右移而来的k个空位。</p><p>逻辑右移以最高位(The most significant bit, 即二进制中权重最大的那个位)来填充由右移而来的k个空位。即若最高位为0，则以0来填充由右移而来的k个空位。同理，若最高位为1，则以1来填充右移而来的k个空位。</p><p>具体如下表格所示</p><table><thead><tr><th align="center">Operation</th><th align="center">Value 1</th><th align="center">Value 2</th></tr></thead><tbody><tr><td align="center">Argument x</td><td align="center">[01100011]</td><td align="center">[10010101]</td></tr><tr><td align="center">x &gt;&gt; 4 (logical)</td><td align="center">[00000110]</td><td align="center">[00001001]</td></tr><tr><td align="center">x &gt;&gt; 4 (arithmetic)</td><td align="center">[<strong>0000</strong>0110]</td><td align="center">[<strong>1111</strong>1001]</td></tr></tbody></table><p>几乎所有的编译器和机器都<strong>以算术右移作为有符号数右移的方式</strong>。另一方面，对于无符号整数，<strong>执行的右移操作一定为逻辑右移</strong>。</p><p>1、什么样的数据类型可以直接移位</p><p>char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long都可以进行移位操作，而double、float、bool、long double则不可以进行移位操作。</p><p><strong>注意事项</strong></p><ol><li><p>在C中移位的数量最好不要超过数据本身的位数，如果超过了数据本身的位数，那么将会对移位数量进行取模操作，以数据本身的位数为除数取模。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lval = <span class="number">0xFEDCBA98</span> &lt;&lt; <span class="number">32</span>;<span class="comment">// int 类型变量有32位。</span></span><br><span class="line"><span class="type">int</span> aval = <span class="number">0xFEDCBA98</span> &gt;&gt; <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">lval <span class="number">0xFEDCBA98</span> <span class="comment">// 逻辑左移0位</span></span><br><span class="line">aval <span class="number">0xFFEDCB49</span> <span class="comment">// 逻辑右移4位</span></span><br></pre></td></tr></table></figure></li><li><p>位移运算符的优先级小于算术运算符，如 <code>1&lt;&lt;2 + 3&lt;&lt;4</code>表达式中实际运算顺序为 <code>1 &lt;&lt; (2+3) &lt;&lt; 4</code>。其实不用记住这么多优先级，<strong>当不清楚运算优先级时，加括号就对了！</strong></p></li></ol>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/CSAPP_2_1_%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8_url.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git 基础回顾</title>
      <link>http://zhangchunxian.github.io/posts/git_foundatoin_url.html</link>
      <guid>http://zhangchunxian.github.io/posts/git_foundatoin_url.html</guid>
      <pubDate>Thu, 01 Oct 2020 04:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;前言: 最近换了一台新笔记本,  需要花费大量时间个人定制笔记本上的编程环境. 对于一个计算机专业的学生来说, git肯定是必不可少的. 说来惭愧, 本人在初次用命令行学习git后就转向了Github Desktop和vscode的图形化界面来进行日常的代码版本控制, 没有很好的将命令行运用在平时的学习中. 加上九月份Github Cli 稳定版发布, Github上的操作也可以用命令行完成, 故趁部署个人开发环境之机回顾所学Git知识与操作, 培养命令行操作的习惯.&lt;/p&gt;
&lt;p&gt;更重要的原因是, 在旁听某个Linux操作系统通识课时, w接触到一位熟练掌握Linux命令行和快捷键的大二软件工程专业学长, 全程脱离鼠标,仅仅在键盘上就完成了平时开发的各项操作. 顿时感到钦佩, 真正领略到了命令行的魅力,并长叹“我要这鼠标有何用”(狗头), 并在学长好基友的怂恿下“入了教”, 悉心向教主学习. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注: 本文仅仅涉及到git的冰山一角, 仅仅满足学生日常小项目开发需求, 更多操作可参考书籍或git官方文档&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;Git-基础回顾&quot;&gt;&lt;a href=&quot;#Git-基础回顾&quot; class=&quot;headerlink&quot; title=&quot;Git 基础回顾&quot;&gt;&lt;/a&gt;Git 基础回顾&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>前言: 最近换了一台新笔记本,  需要花费大量时间个人定制笔记本上的编程环境. 对于一个计算机专业的学生来说, git肯定是必不可少的. 说来惭愧, 本人在初次用命令行学习git后就转向了Github Desktop和vscode的图形化界面来进行日常的代码版本控制, 没有很好的将命令行运用在平时的学习中. 加上九月份Github Cli 稳定版发布, Github上的操作也可以用命令行完成, 故趁部署个人开发环境之机回顾所学Git知识与操作, 培养命令行操作的习惯.</p><p>更重要的原因是, 在旁听某个Linux操作系统通识课时, w接触到一位熟练掌握Linux命令行和快捷键的大二软件工程专业学长, 全程脱离鼠标,仅仅在键盘上就完成了平时开发的各项操作. 顿时感到钦佩, 真正领略到了命令行的魅力,并长叹“我要这鼠标有何用”(狗头), 并在学长好基友的怂恿下“入了教”, 悉心向教主学习. </p><p><strong>注: 本文仅仅涉及到git的冰山一角, 仅仅满足学生日常小项目开发需求, 更多操作可参考书籍或git官方文档</strong></p><h1 id="Git-基础回顾"><a href="#Git-基础回顾" class="headerlink" title="Git 基础回顾"></a>Git 基础回顾</h1><span id="more"></span><h2 id="1-git基本工作流程"><a href="#1-git基本工作流程" class="headerlink" title="1. git基本工作流程"></a>1. git基本工作流程</h2><p>Git基本工作区域可以分为以下三部分</p><ol><li><p>Working Directory(工作区)</p><p>添加, 编辑, 修改文件等动作</p></li><li><p>暂存区</p><p>暂存已经修改的文件统一提交到git仓库中. </p></li><li><p> Git Repository(Git仓库)</p></li></ol><p>   最终确定的文件保存在仓库, 成为一个新的版本. </p><h2 id="2-git本地操作"><a href="#2-git本地操作" class="headerlink" title="2.git本地操作"></a>2.git本地操作</h2><h3 id="基本信息设置-全局"><a href="#基本信息设置-全局" class="headerlink" title="基本信息设置(全局)"></a>基本信息设置(全局)</h3><p>在工程项目文件夹中右键选择<code>Git Bash Here</code>, 打开<code>git</code>命令行.</p><p>设置用户名(username即为Github用户名)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br></pre></td></tr></table></figure><p>设置用户名邮箱(useremail即为Github注册邮箱, <strong>不用加引号</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email useremail</span><br></pre></td></tr></table></figure><p>使用下列命令查看是否设置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>在下面出现的信息中出现<code>user.name:</code>, <code>user.email</code> , 以及后面信息均正确则说明配置成功.</p><blockquote><p>常用Linux命令<br>        <code>pwd</code>查看当前动作目录, 返回当前工作目录的绝对路径</p><p><code>ls</code>查看在此文件夹中的文件(非隐藏文件)<br>        ls -a 查看所有文件包括隐藏文件.  比如git初始化后生成的<code>.git</code>文件夹就是隐藏文件, ls命令是看不到的.</p></blockquote><h3 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h3><ol><li><p>创建文件夹(在Git bash中运用Linux命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir foldername</span><br></pre></td></tr></table></figure><p>foldername对应与创建文件夹的名字</p></li><li><p>在文件内初始化Git(创建git仓库)</p><p>通过Linux命令进入文件夹.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd foldername</span><br></pre></td></tr></table></figure><p>逆操作: 返回上一级文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>初始化Git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>之后在新创建文件夹中会出现隐藏文件<code>.git</code>(如果看不到的话设置电脑显示隐藏文件)</p></li></ol><h3 id="向仓库中添加文件"><a href="#向仓库中添加文件" class="headerlink" title="向仓库中添加文件"></a>向仓库中添加文件</h3><p><strong>一开始的操作均是在本地工作区(Working Directory)</strong></p><ol><li><p>新建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch filename</span><br></pre></td></tr></table></figure><p>文件夹中便会出现目标文件</p><blockquote><p>git常用命令</p><p>git status 可以查看当前工作目录的状态.</p></blockquote><p>在git bash中输入Linux命令 <code>git status</code>, 输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">On branch master# 当前处于仓库中的master分支</span><br><span class="line"></span><br><span class="line">No commits yet# 还没有commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)# 检测到未提交(add)的改变</span><br><span class="line">        filename</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编辑(修改)新文件(可选)</p><p>在git bash中输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim filename                           # 在命令行中打开vim编辑器修改文件</span><br></pre></td></tr></table></figure></li></ol><p> 会出现许多以<code>-</code>开头的空行,并在下方显示<code>filename [unix] (time date) </code>                                                                                                                                                                                                                  在空行区域即可用vim编辑文件, 注意先按 “i”键进入插入模式再开始编辑!</p><p>题外话: vim编辑器是知乎, 学长, Google等都在推荐的编辑器, 目前为止我还不是习惯vim这种极简的编辑器(当然以后会折腾vim的配置), 正在努力适应.</p><p>当然也可以用编辑器或者IDE来编辑(修改文件), 在git bash中输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .# 使用vscode打开当前文件夹</span><br></pre></td></tr></table></figure><p>​    3. 退出文件修改并保存(命令行中, 可选)</p><p>按esc键(结束输入), 并在下方输入<code>:wq</code>,退出编辑.</p><blockquote><p>Linux命令</p><p>cat filename                // 查看当前文件中的内容</p></blockquote><ol start="4"><li> 将修改文件提交到暂存区</li></ol><p>   在修改文件所在文件夹中打开git bash 输入以下命令</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &#x27;filename&#x27;# 将新文件提交到 暂存区</span><br></pre></td></tr></table></figure><p>   当改变的文件较多，git add 逐个提交命令繁琐或者不上传新文件，被删除文件时，以用如下的命令</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A  # 提交所有变化</span><br><span class="line">git add -u  # 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</span><br><span class="line">git add .  #提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</span><br></pre></td></tr></table></figure><blockquote><p>此时输入 git status 会显示如下</p><p>On branch master</p><p>No commits yet</p><p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)<br>       new file:   filename                                                                // 显示暂存区内的新文件</p></blockquote><p><strong>此时文件从本地工作区提交到暂存区.</strong></p><ol start="5"><li><p>将暂存区文件添加到仓库</p><p>在git bash 中输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Your description about this change&quot;# &#x27;&#x27;中填写你对本次修改的说明(必须)</span><br></pre></td></tr></table></figure></li><li><p> 删除文件并提交到仓库</p></li></ol><p>   Linux命令从工作区中删除文件</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf filename # 删除文件</span><br></pre></td></tr></table></figure><p>   从git中删除文件</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm filename# filename指的是需要操作的文件名</span><br></pre></td></tr></table></figure><p>   提交操作</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;Your description about this change&#x27;# &#x27;&#x27;中填写你对本次修改的说明(必须)</span><br></pre></td></tr></table></figure><h2 id="3-Git管理远程仓库"><a href="#3-Git管理远程仓库" class="headerlink" title="3. Git管理远程仓库"></a>3. Git管理远程仓库</h2><p>   作用: 备份, 实现代码共享集中化管理.</p><ol><li><p>将Github远程仓库clone到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone repository_location# repository location指的是需要复制的远程仓库地址</span><br></pre></td></tr></table></figure></li><li><p>对克隆到本地的Github仓库进行操作(详见2.git本地操作)</p></li><li><p>将本地仓库同步到git远程仓库中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>（可选）在本地已经有工作区，需要从GitHub远程仓库更新到本地工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin branchname// branchname指的是需要更新的分支的名称</span><br></pre></td></tr></table></figure><p>使用git pull 更新，相当于是从远程获取最新版本并merge到本地</p></li></ol><h2 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4. 拓展"></a>4. 拓展</h2><blockquote><p>Git website: <a href="http://git-scm.com/">http://git-scm.com</a></p><p>Free on-line book: <a href="http://git-scm.com/book">http://git-scm.com/book</a></p><p>Reference page for Git:<a href="http://gitref.org/index.html">http://gitref.org/index.html</a></p><p>Git tutorial :<a href="http://schacon.github.com/git/gittutorial.html">http://schacon.github.com/git/gittutorial.html</a></p><p>Git for Computer Scientists: <a href="http://eagain.net/articles/git-for-computer-scientists/">http://eagain.net/articles/git-for-computer-scientists/</a> </p></blockquote><p>在命令行中, 输入以下指令获取更多git指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help verb     # verb = config, add, commit, etc</span><br></pre></td></tr></table></figure><p>推荐书籍:</p><h1 id="Pro-Git"><a href="#Pro-Git" class="headerlink" title="Pro Git"></a>Pro Git</h1><p><a href="https://img9.doubanio.com/view/subject/l/public/s4245786.jpg"><img data-src="https://img9.doubanio.com/view/subject/s/public/s4245786.jpg" alt="Pro Git"></a></p><p>作者: <a href="https://book.douban.com/author/4560652/">Scott Chacon</a><br>        出版社: Apress<br>        出版年: 2009-8-27<br>        页数: 288<br>        定价: USD 34.99<br>        装帧: Paperback<br>        ISBN: 9781430218333</p><p>结语: 仅仅掌握这些是远远不够的, 真实的项目开发要复杂的多, git也不是一篇两篇文章可以掌握的. 后续会参考一些书籍与视频, 完善git从入门到精通的种种操作,  争取将git熟练运用于真实的项目开发中.</p>]]></content:encoded>
      
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/">软件应用</category>
      
      <category domain="http://ZhangChunXian.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E5%BC%80%E5%8F%91/">开发</category>
      
      
      <category domain="http://ZhangChunXian.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/">软件应用</category>
      
      <category domain="http://ZhangChunXian.github.io/tags/%E5%BC%80%E5%8F%91/">开发</category>
      
      
      <comments>http://zhangchunxian.github.io/posts/git_foundatoin_url.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
